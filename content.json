{"meta":{"title":"不系之舟- z","subtitle":"人生如逆旅，我亦是行人","description":"不系之舟的个人博客，使用Hexo搭建","author":"不系之舟","url":"http://www.lapland.top","root":"/"},"pages":[],"posts":[{"title":"大数据可视化后端开发工程师","slug":"招聘要求","date":"2019-03-12T07:30:16.000Z","updated":"2019-03-12T08:15:14.968Z","comments":true,"path":"2019/03/12/招聘要求/","link":"","permalink":"http://www.lapland.top/2019/03/12/招聘要求/","excerpt":"职位描述大数据可视化后端开发工程师岗位职责： 负责大数据产品线的开发工作； 负责给产品开发、实施、运维团队提供技术保障； 负责对系统的重用、扩展、安全、性能、伸缩性、简洁等做系统级的把握； 对系统框架相关技术和业务进行培训，指导开发人员开发，解决系统开发、运行中出现的各种问题。 任职资格： 3年以上java/c++开发经验，1年以上大数据数据相关经验； 熟练掌握JavaEE，熟悉linux环境； 熟练掌握Spring开发框架，熟悉VUE、JQurery等前端JS框架； 熟悉数据仓库、BI相关模型 熟悉Hadoop、Spark、MapReduce平台及框架； 有大数据平台可视化经验者优先","text":"职位描述大数据可视化后端开发工程师岗位职责： 负责大数据产品线的开发工作； 负责给产品开发、实施、运维团队提供技术保障； 负责对系统的重用、扩展、安全、性能、伸缩性、简洁等做系统级的把握； 对系统框架相关技术和业务进行培训，指导开发人员开发，解决系统开发、运行中出现的各种问题。 任职资格： 3年以上java/c++开发经验，1年以上大数据数据相关经验； 熟练掌握JavaEE，熟悉linux环境； 熟练掌握Spring开发框架，熟悉VUE、JQurery等前端JS框架； 熟悉数据仓库、BI相关模型 熟悉Hadoop、Spark、MapReduce平台及框架； 有大数据平台可视化经验者优先 知识点列表： 开发： 视图层技术——HTML,CSS,JS,AJAX,Tiles,Velocity,FreeMarker 持久层技术——MyBatis,Hibernate Spring , Spring MVC 项目构建工具Maven 日志Log4j 版本控制 Git数据库技术： SQL语句 参数调优操作系统： 熟练掌握一种Linux系统，原理，Shell命令服务器技术： 熟练使用并理解一个应用服务器技术的原理（Tomcat） 熟练使用并理解一个Web服务器技术的原理（Nginx） 附加：缓存技术： 熟练使用并理解一种缓存技术（Redis,Memcache，EhCache） 非关系型数据库 熟练使用并理解一种非关系型数据库（MongoDB）中间件技术： JMS:activeMQ和kafka RPC: Dubbo设计模式： 了解并能够使用几种最主要的设计模式网络： 熟练使用并理解一个网络开发技术（Netty） 熟悉http，TCP协议Java虚拟机： 熟悉jvm运行原理，内存分布 jvm参数调优","categories":[{"name":"职业规划","slug":"职业规划","permalink":"http://www.lapland.top/categories/职业规划/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://www.lapland.top/tags/大数据/"},{"name":"可视化","slug":"可视化","permalink":"http://www.lapland.top/tags/可视化/"},{"name":"后端开发","slug":"后端开发","permalink":"http://www.lapland.top/tags/后端开发/"},{"name":"招聘","slug":"招聘","permalink":"http://www.lapland.top/tags/招聘/"}]},{"title":"","slug":"个人计划 [ 最新 ]","date":"2019-03-12T06:58:01.332Z","updated":"2018-11-26T07:38:38.000Z","comments":true,"path":"2019/03/12/个人计划 [ 最新 ]/","link":"","permalink":"http://www.lapland.top/2019/03/12/个人计划 [ 最新 ]/","excerpt":"","text":"一、总体计划 散打 个人形象 系统架构师 浙大考研 二、学习计划SpringBoot + Docker 三、个人项目总体计划 以下列项目为主，保持最新状态。 3.1、JavaUtils Java常用工具类及技术点的Demo技术栈：SSM + JSP 3.2、WebNote Markdown 笔记本项目是个人笔记的Git托管，并作为博客内容源。 3.3、Lapland 个人网站采取前后端分离模式 3.4、API_Manager 接口及数据字典管理及测试工具凡涉及到接口规范，皆以此项目为准，保持最新。分普通风格和RestFul风格接口形式,统一返回格式,使用Swagger进行接口文档管理。","categories":[],"tags":[]},{"title":"","slug":"TEMP","date":"2019-03-12T06:58:01.316Z","updated":"2019-02-11T06:12:33.000Z","comments":true,"path":"2019/03/12/TEMP/","link":"","permalink":"http://www.lapland.top/2019/03/12/TEMP/","excerpt":"","text":"@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。 数据库设计 1、表注释 + 字段注释2、相似表自然存在，不同视角一般不需要重复设计3、一个表承担一个功能 classDir = Thread.currentThread().getContextClassLoader().getResource(“/“).getPath(); 主要技术指标简介： 本系统采用多种主流框架技术。比如：采用Mybatis持久层框架；采用Spring容器对Bean进行管理；采用SpringIoC解耦各层之间依赖；采用Maven作为项目构建管理工具；采用slf4j框架+Log4j日志组件生成日志；采用Hibernate validator进行表单验证；采用Redis技术解决接口性能和缓存问题；采用ActiveMQ消息队列进行异步消息处理；采用单点登录技术的统一管理各系统身份认证；采取异常信息及日志文件的国际化（i18n）处理；采用SpringAOP进行统一异常处理、日志、Redis管理；采用Druid数据库连接池技术，提高数据库资源利用率；采用前后端分离技术，使用RESTful风格面向接口编程；采用Shiro安全框架进行身份认证，权限管理和安全加密； java常用返回值标签英语 tag / flag JSON本身没有Date类型，因此，JSON库将Date类型的数据序列化时会转为String。这时，不同环境， 不同平台，以及用不同的JSON解析库，转换后的结果经常会不同。客户端进行反序列化时无疑会失败。所以建议所有Date类型，统一采用时间戳表示。 单表操作、关联操作，bean 并发缓存到引擎优化 ../ 此文件当前位置的上一层目录，就是images_dir test_dir le.php这级目录../../ 上一层目录的上一层，就是web_root这级目录,/则是当前目录，就是test.php这级/则表示根目录，用来写绝对路径的不写就是和./一样，表示当前目录 feed流设计：那些谋杀你时间APP 英语invoke 调用execute 执行received 收到 prpject 项目moudel 模块liberaries 依赖类库/Jar包facets 配置artifaces 编译生成文件（jar、war、pom等） 问题列表 如何制作 SDKjar + javadoc ？ 静态库和动态库 我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。 DLL文件 datatype: “json”,相应格式contentType: “application/json”,提交格式 2K分辨率是1920×1080，4K分辨率是4096×2160，8K分辨率是7680×4320 显示器分辨率是其本身具备的像素的数量，决定了你能显示多少数据；CPU和显卡的能力决定了能向显示器输入多少数据。分辨率最高值是由显卡决定的，能实现的最高值是由显示器决定的。","categories":[],"tags":[]},{"title":"","slug":"README","date":"2019-03-12T06:58:01.308Z","updated":"2018-07-17T03:58:42.000Z","comments":true,"path":"2019/03/12/README/","link":"","permalink":"http://www.lapland.top/2019/03/12/README/","excerpt":"","text":"[TOC] 一、前言 本项目是个人笔记的Git托管，并作为博客内容源。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.17 1.0 ZZ 初稿 三、索引目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330.├── Markdown模板.md├── README.md├── TEMP.md├── 待整理│ ├── contOS 最小化服务端配置.txt│ ├── Linux常用命令.txt│ ├── Tomcat 配置虚拟主机.txt│ └── 各类截图│ ├── Linux.pdf│ ├── 编写优秀 CSS 代码的 8 个策略.pdf│ ├── 抽象：程序员必备的能力.pdf│ ├── 工作截图│ │ ├── 工作截图│ │ │ ├── API.pdf│ │ │ ├── 测试.pdf│ │ │ ├── 大数据整合.pdf│ │ │ ├── 平台数据对接~.pdf│ │ │ ├── 前端.pdf│ │ │ ├── 前端性能优化.pdf│ │ │ ├── 小知识点.pdf│ │ │ ├── 远程控制.pdf│ │ │ └── 智慧城市.pdf│ │ └── 前后端分离│ │ └── 无标题笔记.pdf│ ├── 假如时光能够倒流， 我会这么学习Java.pdf│ ├── 课程截图│ │ ├── Java_Web开发实战1200例.pdf│ │ ├── 计算机英语.pdf│ │ ├── 其他.pdf│ │ ├── 淘淘商城视频截图.pdf│ │ ├── 系统架构师考试.pdf│ │ └── 需要加深了解的技术点（标签）.pdf│ └── 人工智能--写小说.pdf├── 个人计划.md├── [置顶] 博客文章│ ├── SC00 文章导读│ │ ├── 关于.md│ │ ├── [置顶]已发布]Java 项目常用工具箱.md│ │ └── [置顶]已发布]Lapland 建站日记.md│ ├── SC01 程序设计基础│ │ ├── Java多线程并发编程│ │ │ └── Java多线程并发编程.md│ │ ├── Java反射机制及其项目应用.md│ │ ├── Java 非空判断.md│ │ ├── Java乱码问题总结.md│ │ ├── JAVA与JS常用字符串操作.md│ │ ├── Java元注解.md│ │ ├── JVM虚拟机│ │ │ ├── JVM 简介.md│ │ │ └── 从Java.lang.NoClassDefFoundError看JVM的类的加载机制.md│ │ ├── StringUtils常用方法解析.md│ │ ├── Tomcat类加载机制.md│ │ ├── 软件设计概念解析.md│ │ ├── 数据结构与算法 &amp; 编译原理│ │ │ ├── 算法习题.md│ │ │ └── [未发布]计算机编程语言.md│ │ └── 小知识点│ │ ├── 平台目录结构说明.md│ │ └── 如何将从接口返回的JSON数据存入mysql数据库.md│ ├── SC02 编程思想 &amp; 设计模式 &amp; 架构│ │ ├── UML│ │ │ ├── Java代码生成UML.md│ │ │ └── UML 模型.md│ │ ├── 编程风格及命名规范│ │ │ ├── Java编程风格与命名规范.md│ │ │ ├── [已发布] Java开发手册.md│ │ │ └── [已发布] JSON语法及JSON定义规范化.md│ │ ├── 编程思想│ │ │ ├── 抽象，软件设计设计的灵魂.md│ │ │ ├── 面向对象编程SOLID原则.md│ │ │ ├── 面向接口开发.md│ │ │ ├── 浅谈怎样写业务逻辑.md│ │ │ ├── 术业有专攻 - 前后端工程师专注方向.md│ │ │ └── 以快速迭代与敏捷开发应对客户不断变化的需求.md│ │ ├── 软件架构│ │ │ ├── 架构设计和技术选型.md│ │ │ └── 模块化设计.md│ │ └── 设计模式│ │ ├── 23种设计模式概述.md│ │ ├── 策略模式.md│ │ ├── 单例模式.md│ │ ├── 工厂模式.md│ │ └── 责任链模式.md│ ├── SC03 Web开发 &amp; Web框架│ │ ├── JavaWeb中的相对路径和绝对路径.md│ │ ├── Lombok使用方法简介.md│ │ ├── OSWorkFlow工作流框架.md│ │ ├── Quartz任务调度框架 - 实现动态定时任务.md│ │ ├── Redis缓存.md│ │ ├── Web Office│ │ │ └── Java Web在线预览Office文件.md│ │ ├── websocket总结.md│ │ ├── Web框架│ │ │ ├── Bootstrap学习笔记系列│ │ │ ├── EasyUI学习笔记系列│ │ │ ├── Hibernate学习笔记系列│ │ │ │ └── Hibernate 框架概述.md│ │ │ ├── JQuery学习笔记系列│ │ │ ├── Mybatis学习笔记系列│ │ │ │ ├── Mybatis 框架概述.md│ │ │ │ ├── mybatis批量操作.md│ │ │ │ └── Spring的mapper扫描器配置 及 mapper.xml映射文件语法解析.md│ │ │ ├── SpringMVC学习笔记系列│ │ │ │ ├── SpringMVC 返回类型.md│ │ │ │ ├── SpringMVC 框架概述.md│ │ │ │ ├── SpringMVC 中获取Session的几种方法.md│ │ │ │ └── SpringMVC 注解解析.md│ │ │ ├── Spring学习笔记系列│ │ │ │ ├── Spring AOP统一处理异常和日志.md│ │ │ │ ├── Spring AOP增强织入顺序.md│ │ │ │ ├── Spring 基础框架整合SSH(Spring +Struts2+Hibernate）.md│ │ │ │ ├── Spring 基础框架整合SSM(Spring +SpringMVC+Mybatis）.md│ │ │ │ ├── Spring 控制反转IoC.md│ │ │ │ ├── Spring 框架概述.md│ │ │ │ └── Spring 面向切面编程AOP.md│ │ │ └── Struts2学习笔记系列│ │ │ └── Struts2 框架概述.md│ │ ├── 各种中文乱码问题的解决.md│ │ ├── 过滤器 &amp; 拦截器 &amp; 监听器的配置和应用.md│ │ ├── 基于Hibernate validation的注解式参数校验.md│ │ ├── 接口设计│ │ │ ├── HttpClint接口调用.md│ │ │ ├── 使用Swagger或Postman接口文档管理.md│ │ │ └── [未发布]API接口设计指南.md│ │ ├── 前端│ │ │ └── Html引入公共页面的几种方法.md│ │ ├── 前后端分离与RESTful风格│ │ │ ├── [未发布]前后端分离架构模式的实践（附完整Demo）.md│ │ │ └── [未发布]浅谈 REST架构风格.md│ │ ├── 权限控制│ │ │ ├── Shiro+Token实现APP、Web统一登录认证和权限管理.md│ │ │ ├── Shiro安全框架.md│ │ │ ├── 单点登录CAS.md│ │ │ └── 浅谈权限管理.md│ │ ├── 数据字典表设计及加载配置文件的几种方法.md│ │ ├── 网页集成功能模块│ │ │ ├── 网页集成Markdown工具.md│ │ │ ├── 网页集成富文本编辑器.md│ │ │ └── 网页集成思维导图工具.md│ │ ├── 微服务│ │ │ └── Spring Boot入门.md│ │ ├── 也谈上下文对象.md│ │ ├── [已发布]Java加密部署，使用自定义的classloader解密的方法实例.md│ │ ├── [已发布]跨域问题的几种解决方法.md│ │ ├── [已发布]浅谈Java项目日志记录和分析 (基于log4j介绍).md│ │ ├── [已发布]浅谈Java异常处理机制及项目中的的规范处理方法.md│ │ ├── 原型设计及UI效果图│ │ │ └── 墨刀- 强大易用的原型设计与协同工具.md│ │ └── 中间件│ │ └── 消息中间件│ │ └── ActiveMQ消息队列.md│ ├── SC04 数据库应用│ │ ├── Java连接SqlServer实践.md│ │ ├── mysql 主从热备，主主互备.md│ │ ├── Spring配置多数据源，并实现注解切换.md│ │ ├── SQL习题108道.md│ │ ├── 常用SQL语句索引.md│ │ ├── 非关系型数据库和关系型数据库.md│ │ ├── 记录一次数据库恢复.md│ │ ├── 数据库表设计总结.md│ │ ├── 数据库操作的几种方式.md│ │ ├── 数据库外键的使用以及优缺点.md│ │ └── 索引.md│ ├── SC05 项目配置 &amp; 运维 &amp; 容器化│ │ ├── ArcGIS安装配置.md│ │ ├── Docker│ │ ├── IDE &amp; 编程软件│ │ │ ├── InterliJ IDEA 使用总结.md│ │ │ ├── MyEclipse 使用总结.md│ │ │ ├── sublime text 3 简易教程.md│ │ │ └── 插件安装及系统配置.xmind│ │ ├── Linux│ │ │ ├── Linux常用命令.md│ │ │ └── Linux上安装.md│ │ ├── Markdown│ │ │ ├── Atom搭建Markdown写作环境，托管到Git.md│ │ │ ├── 如何使用markdown画思维导图.md│ │ │ ├── 在JavaWeb项目中实现Markdown编辑器.md│ │ │ └── 在web项目中使用MarkDown组件.md│ │ ├── Nginx│ │ │ ├── Nginx+Tomcat实现动静分离、负载均衡.md│ │ │ ├── Nginx安装配置.md│ │ │ └── Nginx的负载均衡方案详解.md│ │ ├── 版本管理│ │ │ ├── Git使用教程.md│ │ │ ├── SVN使用教程.md│ │ │ └── 版本管理分支命名规范.md│ │ ├── 持续集成及自动化运维│ │ │ ├── DevOps 自动化运维.md│ │ │ └── 利用Jenkins进行持续集成的实践.md│ │ ├── 服务器配置及开发环境搭建│ │ │ ├── Java 开发环境搭建及项目部署（Linux系统 ）.md│ │ │ ├── Java 开发环境搭建及项目部署（Windows系统）.md│ │ │ └── 阿里云服务器配置.md│ │ └── 基础知识│ │ ├── 端口及配置索引.md│ │ └── 运维相关的基本概念解析.md│ ├── SC06 软件测试 &amp; 性能优化│ │ ├── 软件测试│ │ │ ├── Code Review与CheckList.md│ │ │ ├── jmeter性能测试和接口测试.md│ │ │ ├── Junit参数化测试.md│ │ │ ├── JUnit测试框架.md│ │ │ └── [未发布]Web性能优化实践.md│ │ └── 性能优化│ │ ├── Web项目系统瓶颈测试.md│ │ ├── 浅谈Web缓存技术.md│ │ └── 网站性能测试工具Yslow使用教程.md│ ├── SC07 网络技术 &amp; Web安全│ │ ├── Web安全│ │ ├── 破解│ │ │ ├── 编程常用工具破解方案汇总.md│ │ │ └── 利用rarcrack破解压缩包.md│ │ ├── 渗透测试│ │ │ ├── Kali Linux渗透测试.md│ │ │ ├── Kali密码攻击工具.md│ │ │ ├── Shodan &amp; zoomeye 搜索引擎.md│ │ │ ├── 记一次渗透测试.md│ │ │ └── 使用Maltego进行互联网情报收集.md│ │ └── 网络基础│ │ ├── Cisco Packet Tracer模拟器使用教程.md│ │ ├── HTTP协议.md│ │ ├── TCP-IP协议.md│ │ ├── web端口说明.md│ │ ├── 静态路由.md│ │ ├── 内网穿透的方法论.md│ │ ├── [未发布]网络基础.md│ │ ├── 正向代理和反向代理.md│ │ └── 抓包.md│ ├── SC08 人工智能 &amp; 数据挖掘与分析 &amp; loT│ │ ├── MATLAB 学习│ │ ├── 大数据基础│ │ │ └── 浅谈ETL.md│ │ ├── 机器学习│ │ ├── 人脸识别API│ │ │ └── 人脸识别SDK 汇总.md│ │ ├── 深度学习│ │ ├── 数据可视化│ │ │ ├── WebGL编程│ │ │ │ ├── Three.js初探.md│ │ │ │ ├── Web HTML5 3D机房尝试.md│ │ │ │ └── 几种Web3D技术比较(HTML5 canvas(Echart)、SVG、webGL).md│ │ │ ├── 地理信息│ │ │ │ └── 地理信息GIS.md│ │ │ ├── 视频直播技术│ │ │ │ ├── Web页面视频最大开窗数测试.md│ │ │ │ ├── 搭建流媒体服务器.md│ │ │ │ ├── 海康威视网络摄像机 SDK二次开发（JavaWeb）.md│ │ │ │ ├── 监控录像容量计算.md│ │ │ │ └── 监控系统 &amp; 视频直播系统开发基础.md│ │ │ ├── 数据可视化的设计原则.md│ │ │ └── 应用场景│ │ │ ├── 电力项目中大数据技术的典型应用.md│ │ │ ├── 数据可视化行业分析.html│ │ │ └── 数据可视化行业分析.md│ │ ├── 数学基础│ │ ├── 网络爬虫│ │ │ ├── Java爬虫框架Crawler4j简介.md│ │ │ ├── Java爬虫框架WebMagic简介.md│ │ │ ├── XPath 选择器简易教程.md│ │ │ └── 正则表达式器简易教程.md│ │ └── 物联网loT│ ├── SC09 项目实战 &amp; 日常瞎折腾系列│ │ ├── Lapland 个人网站│ │ │ └── Lapland开发实录.md│ │ └── 日常瞎折腾系列│ ├── SC100 Windows &amp; Office 使用│ │ ├── 护眼屏保设置.pdf│ │ └── 快速批量提取文件夹中次级文件夹及文件名称的技巧.md│ ├── SC10 移动端开发│ │ ├── Android│ │ │ ├── AndroidStudio.md│ │ │ ├── Eclipse配置Android开发环境.md│ │ │ └── IntelliJ IDEA配置Android开发环境.md│ │ └── 微信公众号│ ├── SC99 面试 &amp; 笔试│ └── 小贴士│ └── 小贴士 - 前端开发.md├── [置顶] 思维体系│ ├── 几点思考 - 工作│ │ ├── 年度总结│ │ │ ├── 2017年年度总结.md│ │ │ └── 开发组现状与存在的问题之我的几点思考.md│ │ └── 项目总结│ │ ├── 12000MPV 培训项目总结.md│ │ └── AnjiOnline 项目总结.md│ ├── 几点思考 - 社会科学│ │ ├── 互联网时代传统产业变革之路.md│ │ ├── 互联网时代的多对多的社会分工选择.md│ │ └── 马克思主义哲学│ ├── 几点思考 - 生活│ │ ├── 堕落的一代.md│ │ ├── 胡思乱想.md│ │ ├── 警示录之一百二十四条军规.md│ │ ├── 如何建立自信心.md│ │ ├── 如何做决策.md│ │ └── 影响一个人成功的决定性因素是什么.md│ ├── 几点思考 - 学习│ │ └── 几点思考.md│ ├── 散打与自由搏击训练│ ├── [未发布] 语录.md│ ├── [未发布][置顶] 那年那兔那些事.md│ └── [未发布][置顶] 诗词欣赏.md└── [置顶] 重要资源备份 ├── 0、My Skill Tree-ZZ.xmind ├── 0、技术点.eddx ├── 0、框架及前后台数据交互.eddx ├── 0、软件架构样板.eddx ├── 0、智慧城市项目架构样板.eddx ├── 3、安吉项目架构.eddx ├── 3、成都文保项目架构.eddx ├── 3、宁波法院架构.eddx ├── 3、宁波交通架构.eddx ├── Shiro时序图.mdj └── 数据库SQL备份-2018.04.27 ├── anjionlinedatabank.sql ├── apidemo_yshow.sql ├── api.sql ├── javautils.sql ├── jeesite.sql ├── jrelax-bi.sql ├── kind_permission.sql ├── lapland.sql ├── lmt_op.sql ├── ningbo_court.sql ├── smart_city.sql ├── smart_city_yshow.sql ├── spider.sql └── zframe.sql 九、结语 版权所有 翻录必究 ★ 如有雷同 纯属巧合","categories":[],"tags":[]},{"title":"","slug":"Markdown模板","date":"2019-03-12T06:58:01.304Z","updated":"2019-01-25T01:24:58.000Z","comments":true,"path":"2019/03/12/Markdown模板/","link":"","permalink":"http://www.lapland.top/2019/03/12/Markdown模板/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用Jenkins 搭建自动化 CI/CD 流水线。以实现软件服务的快速迭代。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.06.22 1.0 ZZ 初稿 三、概念解析3.1、占位版权声明：公司内部资料，禁止外传。 Java异常类层次结构图 Java异常类层次结构图 Java异常类层次结构图 Java异常类层次结构图 六、相关术语七、拓展阅读八、参考资料 异常处理_百度百科 九、结语 文章仅作为个人学习总结之用，水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 社会科学/互联网时代传统产业变革之路","date":"2019-03-12T06:57:57.264Z","updated":"2018-05-19T17:56:25.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 社会科学/互联网时代传统产业变革之路/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 社会科学/互联网时代传统产业变革之路/","excerpt":"","text":"#经济新常态倒逼传统产业升级 可以背取代部分的是重复的劳动力，取代的程度由社会科技发展的程度来决定。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 社会科学/互联网时代的多对多的社会分工选择","date":"2019-03-12T06:57:57.264Z","updated":"2018-05-19T18:28:11.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 社会科学/互联网时代的多对多的社会分工选择/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 社会科学/互联网时代的多对多的社会分工选择/","excerpt":"","text":"[TOC] 一、前言在互联网时代，变化是最大的规则，不变是最大的危机。 成功者总是不约而同的配合时代的需要 不能从今天规划明天，而要从后天规划明天。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.20 1.0 ZZ 初稿 产业结构人口密集型：低廉的劳动力和原材料成本 三、组织结构3.1、项目管理项目的组织能力会作为企业盈利能力重要参考。 3.2、团队管理3.2、资源调配3.3、安全、隐私保护3.3、信息获取方式的改变现在信息获取能力是企业盈利能力的一个表现，发展到一定阶段信息应该是共享的,不能作为一个参考。 3.2、标准化五、多维度分析5.1、纵向分析5.11、基础层思想、Idea、创新力 5.11、技术层云计算、大数据、AI 5.11、应用层5.11、硬件层八、案例分析8.1、共享单车骑行免费，产生的信息收费。数据驱动其他商业组织发展。 八、参考资料 互联网时代的社会分工 - 百度搜索 互联网时代的社会创新与新公益形态 九、结语 劳动力与资本不会成为制约因素。 互联网产品也将是免费的。就像百度搜索，而内容和数据是收费的。 资源和信息不可能共享，因此而会成为盈利能力的要素。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 学习/几点思考","date":"2019-03-12T06:57:57.252Z","updated":"2018-04-13T07:37:30.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 学习/几点思考/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 学习/几点思考/","excerpt":"","text":"学习如爬山。眼睛看一看路，两手攀到合适位置，两腿发力，带动身体前行。眼睛不看路不行，找不准方向。双手伸的太高也不行，能力达不到这种程度。双腿不发力，底盘不稳不行。只有四肢协调，才是最省力，效率最高的形式。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-2","date":"2019-03-12T06:57:57.244Z","updated":"2019-03-02T04:53:24.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-2/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-2/","excerpt":"","text":"一、前言距上次写总结又一年过去了，上次提出的问题有些依旧存在，再加之近期有一些员工更离职，如此下去恐损害公司的根本，故重新做一篇汇报，希望公司能有所措施。 二、公司 / 团队存在的问题2.1、公司方面 公司发展方向不明确，随波逐流。这点对员工来说问题不大，对公司来说是一个值得思考的命题。 老板对公司关注度不够，对提出的管理问题没有实际性措施。对项目接触不够深入，无法理解我们所提出的技术问题和所遇到的技术问题。如若您没有精力对此进行管理，请指定一个人进行管理，并赋予他最大权限（注：我关注点在技术方面，不愿意接受此项工作）。 与员工的交流不够，使之不了解公司的真实想法。 2.2、团队方面 团队氛围懒散，没有凝聚力和战斗力。 2.21、员工离职的原因 1、工资福利待遇 2、现在的工作环境 3、未来的个人发展前景 4、未来的公司发展前景 5、个人身体 / 家庭原因 三、 改善意见3.1、提高福利待遇公司目前的福利待遇，在市场上没有什么竞争力。 3.2、完善制度能力越强的员工承担的责任会越多，被安排的工作也会越多。会越忙。能力越差的员工承担的责任会越少，被安排的工作也会越少。会越清闲。（因为把重要工作安排给能力差的员工，总会出纰漏，并且计划任务无法保证），如果没有区别对待，这些员工肯定就会有意见，凭什么我这么辛辛苦苦和他们整天游手好闲的一样待遇。长此以往就会出现劣币驱逐良币的现象。杨子峰离职时我找他谈过，他有这方面的原因，吴神丽也有这方面的想法。 另外如果做的好的员工和做的差的员工，一样的待遇，那么谁再愿意辛苦工作，大家一起混日子就是。 另外，如果公司觉得会叫的孩子有奶喝，那是在自欺欺人，最终损害的还是公司利益。 对于技术性团队，人员的补充仅仅是招聘这么简单。就像蔡建会，历经两年好不容易培养出来了，然后离职了，对公司是很大的损失。然后在招一个人进来，会不会再次重复蔡建会的过程？公司是学校么？专门给其他公司培养人才。 3.3、责任分清不要胡子眉毛一把抓，避免出现忙的忙死，闲的闲死的状况。 避免出现计划外的任务。 四、人员需求 后端开发1名（有一定工作经验） 前端开发1名（有一定工作经验） UI设计1名（待定，有一定工作经验） 四、思考这部分没有内容，之所以还会写下来，只是为了提醒您，本篇文章的主题是思考。不是我的思考，是您的思考。 五、总结1、本来这些事情本不是我应该思考的范围，然而公司没有任何举措，也不去思考这些问题，如此不查不视，不闻不问，公司发展根本谈不上。 2、我也不愿意接触技术之外的管理工作，因为不是我所擅长。我还要写具体代码，也没有这么多精力。 3、希望公司足够坦诚，不要出现耍心机的状况，占小便宜的人最终会吃大亏。例如：今年年假的处理方法 4、良药苦口，如果公司只愿意听好听的话，那么我以后也就不再提类似意见。 5、时间有限，写的比较仓促，如有疑问，周一当面回复。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-1","date":"2019-03-12T06:57:57.232Z","updated":"2019-03-02T03:57:04.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-1/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/开发组现状与存在的问题之我的几点思考-1/","excerpt":"","text":"来公司已近一年，接任开发组管理职务也有段时间了。针对我们公司及开发组所存在的一些问题，我想谈一谈我的看法。个人见解，水平有限，还望批评指正。` 一、业务首先，我认为业务是最重要的，没有稳定的业务，公司谈不上发展。并且发展技术应该建立在业务需求的基础之上，否则只能是闭门造车。然而，针对公司目前的业务现状，我觉得是否可以暂时拓展一些业务范围。团队需要锻炼、技术需要实践应用，不能只靠研究技术点实现，毕竟学术和应用还有一段距离。问题是在实践中发现和解决的。当然，这个与您对团队的期望有关，如果您期望团队集中力量完善技术体系，以期在后续项目上的应用，那么我们就据此进行今后一段时间的工作安排。 二、技术能力由于我们的业务经验尚浅，在市场上没有突出优势，因此我觉得可以从技术能力上稍加弥补。然而我们公司目前的技术能力方面还不成体系，没有形成一套完整的解决方案。 针对我们公司项目的特点，我认为一个完整的项目应该包括前端（数据可视化） + 后端 + 运维 + 远程控制 + 产品化。并且形成一套归档文件。项目结构具体如下图所示： Yshow可视化解决方案图 2.1、前端技术目前前端所具备的能力有：地理信息可视化、二维图表可视化、视频开窗。所欠缺的是：三维建模可视化、多终端技术（PC/Android/IOS）、硬件控制（灯光、红外、触屏）。三维建模可视化目前已有合适解决方案，我让窦志伟在学习这方面的内容。多终端和硬件控制可作为备选项，有业务需求时再做研究。 您发给我们的照片和视频我们也都已经看过。我认为最主要的区别在于动态效果，这个我们有能力解决，我打算让前端做出一个demo，整合三维模型和动态效果功能，作为公司项目展示。 至于美工，这个需要审美眼光和艺术天分了，也是仁者见仁智者见智的事情，只能多多参考其他公司的界面及素材，逐渐提升和完善自己的设计风格。 2.2、后端技术后端目前只做到了提供数据接口的转换（建议远程控制单独提出做成一个项目，不与具体项目耦合，以后的项目也可以通用，目前杨子峰正在做）。除此之外，我认为后端还应该做到： 其一、保证系统的稳定性和健壮性，不能一出错就宕机，并且生成运行日志，错误告警。 其二、针对页面延迟严重的问题，考虑做服务端缓存或客户端缓存。 其三、安全防护和权限控制本是系统应该具备的功能，然而可视化项目特点多为内网项目，所以根据需求来确定实不实现。 其四、数据的采集、整合、处理、分析、可视化是大数据技术的完整流程，目前我们只做了可视化，其他技术也可作为可以拓展备选项。 2.3、远程控制安吉项目的远程控制，是耦合在前后端代码里的，这样做的好处是，实现简单。然而也有一些问题。如下： 其一、代码同时涉及前后端，前端必须用JSP技术，无法做到前后端分离。 其二、每一个动作都需要实现一段代码，开发工作量大，重复代码多。 其三、每一个项目必须重新开发远程控制代码。 现在杨子峰在用C#重新开发远程控制代码，基本功能已经完成。然而如果杨子峰离职的话，这个程序及程序所可能存在的问题，没人可以接手。因此，我打算去看这段代码，如有可能按照他的思路用Java重新实现。 2.4、运维、测试、产品化目前项目部署是我在做，运行环境目前为Windows，Linux也可以做到。网络环境根据安吉项目的经验，我认为应该尽早确认，因为它会影响系统架构。后续运维暂且不表。 测试没人在做（功能测试、性能测试、代码审查等，详见项目开发规范流程图），然而测试是保证代码质量和产品质量的重要一环，不能不做。并且只有通过测试（性能测试）才能确认系统的瓶颈（如延迟严重）在哪里，如何优化。 产品化也就是封装打包成.exe文件，目前也是用C#写的，问题同远程控制一样，杨子峰一旦离职，无人接手。 因此，我认为团队中至少需要两个人拥有同样的技术，以备不时之需。包括运维。并且应该有开发文档。以供后续开发者参考。 以上罗列了一个完整可视化项目涉及到的技术，技术细节暂且不表。其中每一项都是一门系统工程。人力物力有限，不可能一蹴而就，只能循序渐进的完善，先有计划的做最关键、必须的工作，忽略一些不太重要的工作，有条件再逐步拓展完善。 项目开发规范流程图 三、团队建设3.1、沟通之所以把沟通放在团队建设的第一项，是因为我认为目前沟通存在很大的问题，由于您长期不在公司，而我又不能准确把握公司下一步的计划，只能在力所能及的情况下安排工作。并且工作周期也只能看情况而定。还有可能会被公司突如其来的计划打断，半途而废。因此我希望公司可以完善下面两点： 其一、公司下一步的项目及计划安排，没有上层公司计划，部门计划不好展开。 其二、提出对团队的下一步期望。具体计划可以我来做，并把落实及完成情况按时向您汇报。 3.2、计划我希望下一步，项目及工作可以在计划周期内按时完成，即使不是正式项目。我也不想给团队太大压力毕竟就这么几个人，然而自由散漫的风气不能有，否则什么也做不成。计划规定的事情必须按时按质完成，其他节省下来的时间，可以自由安排学习。也是因为就这么几个人，一个人完不成任务，或者做的很差劲，就必须有别人替他完成任务，长此以往就会有怨言，甚至出现劣币驱逐良币的现象。 3.3、个人发展我觉得团队建设应该考虑到个人发展。杨子峰就是一个例子，本身能力还可以，然而进公司一年有余，总是东打一枪，西放一炮。前端做段时间，C#做段时间，监控再做段时间，技术宽度是够了，但每一项都不精，再如果个人规划做不好，就会觉得碌碌无为，没有进步。虽然我们团队比较小，一人身兼数职的情况难免出现，但是个人发展的基本方向应该得以保证，否则只会越做下去感觉损失越大。 3.4、氛围我觉得一个新生团队，应该有一种积极进取的氛围，这样团队才能发展，个人才能发展。而不应该出现混日子的状态，这是对公司的不负责，也是对自己的不负责，这样的团队也带不起来。一个人只要有责任心，好学，技术可以逐步培养。反之，如果对工作敷衍了事，对计划也没有什么紧迫感，那就不是在写代码，而是在写Bug。 3.5、团队和个人发展的三个思考能做到什么样？想做到什么样？应该做到什么样？答案如果有了的话，接下来就是如何做到。 四、结语思维天马星空，写的有点乱，还请见谅。并且两幅图也并不是仅针对此封信的，仅供参考。以上几点，您如果同意的话，我会安排落实。如有不当之处，也请指出。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 工作/年度总结/2017年年度总结","date":"2019-03-12T06:57:57.228Z","updated":"2018-04-09T06:09:43.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/2017年年度总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 工作/年度总结/2017年年度总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 工作/项目总结/AnjiOnline 项目总结","date":"2019-03-12T06:57:57.224Z","updated":"2018-04-12T08:51:10.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 工作/项目总结/AnjiOnline 项目总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 工作/项目总结/AnjiOnline 项目总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 工作/项目总结/12000MPV 培训项目总结","date":"2019-03-12T06:57:57.224Z","updated":"2018-04-14T16:52:36.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 工作/项目总结/12000MPV 培训项目总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 工作/项目总结/12000MPV 培训项目总结/","excerpt":"","text":"前言近两个月的项目培训，旨在验证新的项目流程及设计标准和对部分员工进行标准化建模出图培训。期间被培训员工的工作技能得以提升知识结构更加系统完善，同时也暴露出新的项目流程所存在的问题或待优化的地方，现将我在项目工作中所闻所想总结如下，个人理解有限，还望批评指正。 一、顶目流程1.1、前期崔备项目或区域工作开始之前,除了与船厂，详设之间的技术交底之外，还应该对项目具体工作者进行项目的常用节点规范、处理方法、常用参考数据的统一讲解，并形成标准文件。以方便项目实施过程中的查阅与修改。有些可以提前做的事情，就不要等到遇见一个处理一个,这样即规范了作业的流程，也减少设计的分歧性失误。这点与项目负责人的经验有关，可能会意识不到后期工作当中可能遇到的普遍性问题。 1.2、项目进行在项目进行过程中应该按照唯一的标准进行，该标准应该是共享的。更新和修改都应该通知到团队每一个人。 在项目工作过程中，项目交流应形成看板，信息共享，关键问题置顶，相似的问题应采取相同的处理方法。形成项目记录，也有利于后期的项目总结。如果所有的问题都等到项目结束后才想起来整理，那么不但浪费时间，而且容易遗漏。 模型问题影响到后续工作修改的，或后续工作应重点关注的地方，应形成备忘录以形成记录和指导后续工作，该处借鉴了管系团队建模出图经验。因为出图及生产信息人员对模型的了解可能不如建模人员深入，有些细节的位置可能没有注意到（例如安装角度、特殊坡口、特殊区域、须持别表达的节点等），因此建模人品有必要记录下来，并提醒后续工作者。也避免时间长了会忘记。 关于详设问题，应该形成”提出- 跟踪 - 反馈修改 - 封闭 - 备份”流程。现在我们一般有”提出一反馈修改”环节，显然不够完善。有可前因为没有跟踪到位，致使问题没有封闭，不了了之，也不利于后期查询，项目总结。 个人在项目进行过程中应养成顺截图记录问题的习惯，目的是备忘和总结问题，交流问题。 1.3、区域及项目结束首先我认为个人工作总结应该分两部分，其一是对项目的工作感想，其二是技术方面的总结，现在我们做的工作总结仅限于工作感想。诚然这点也很重要，但是很难收到预想的效果（一般就是项目很好 - 收获很多 - 继续努力）。但是技术方面的总结，不会掺杂水分， 也能反映员工思考问题的方向，深度及重点。可以在项目总结中借鉴和有据可依。 其次船型/区域典型问题总结，处理方式总结。主题是总结，不是问题。每一个区域与每一种船型都有自己的特点和持有的处理方式。公司做过很多船型，但是设计经验积累仅限于参与项目的员工，没有形成自己船型/区域分析，久而久之，随着时间/人员的流失，做过跟没做过也没太大区别了。 二、考核标准科室试行新的考核评审标准，目的是提高专业的设计水平，减少低级失误。然而整体实行下来普遍认为，标准较高很难达到，于是乎就在考虑标准是否可以适当降低。我认为问题的关键不在的考核标准的高与低（我可以提出标准更高，是否就代表科室的水平就更高呢），而在于问题是客观存在的，团队实力目前也只能达到这个水平，那么与其提出问题，强调问题的严重性，不如提出具体解决方案，如何才能帮助团队达到那个水平，这个靠个人去想显然不现实没有效率的。 三、团队协作心人之智，不如众人之愚。一个优秀的项目负责人不在于能否事无巨细，而在于能够充分调动团队的积极性，集众人之力，为同一个目标而努力。而不是，一两个人忙的焦头烂额费心费力，其他人则是疲于应付繁重的工作任务，靠着惯性来做事情，而不是脑子。 四、知识体系一种文化的厚重与底蕴在于沉定与积累，技术的核心竞争力也在于积累。所以不能像上述所说的那样时间在流逝，经验也在流失。建立系统的知识体系，归类，分析，总结这些经验。把经验转化成知识，作为载体来传承这些知识。对干一个有长远发展眼光的公司或团队来说是很有必要的。当然，工作量也是非常庞大的。 五、其他总的来说，在科室积极向上的工作氛围下，这些问题（其实也不能算是问题，只能说是对自己更高的要求）最终都会得到完美解决。对于此点，我很乐观。然而，问题的本质往往不是问题本身，而是没有意识到问题。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 生活/胡思乱想","date":"2019-03-12T06:57:57.192Z","updated":"2018-07-22T16:37:16.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 生活/胡思乱想/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 生活/胡思乱想/","excerpt":"","text":"如果一本书超过50%看不懂，就不用再看了，说明水平没达到，回头去补一补基础～ 关于知识/信息碎片的回收 在我的字典里没有放弃，有条件最好，没有条件那就死磕 警示录之一百二十四条军规 如何建立自信心 如何做决策 影响一个人成功的决定性因素是什么 空灵、芦管、意境","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 诗词欣赏","date":"2019-03-12T06:57:57.180Z","updated":"2018-06-08T07:46:27.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 诗词欣赏/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 诗词欣赏/","excerpt":"","text":"诗词欣赏 相思 [歌词] 最肯忘却古人诗，最不屑一顾是相思；守着爱怕人笑，还怕人看清。 临江仙·滚滚长江东逝水 [明·杨慎] 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 半半歌 [明·李密庵] 看破浮生过半， 半之受用无边。半中岁月尽悠闲，半里乾坤宽展。半廓半乡村舍， 半山半水田园。半耕半闱半经尘，半土半民姻眷。半雅半粗器具， 半华半实庭轩。衾裳半素半轻鲜，肴馔半丰半俭。童仆半能半拙， 妻儿半朴半贤。心情半佛半神仙，姓字半藏半显。一半还之天地， 让将一半人间。半思后代与沧田，半想阎罗怎见。酒饮半酣正好， 花开半吐偏妍。帆张半扇免翻颠，马放半缰稳便。半少却饶滋味， 半多反厌纠缠。百年苦乐半相参，会占便宜只半。 丑奴儿·书博山道中壁 [宋·辛弃疾] 少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。 醒世恒言 [明·冯梦龙] 暮宿苍梧，朝游蓬岛，朗吟飞过洞庭边。岳阳楼酒醉，借玉山作枕，容我高眠。出入无踪，往来不定，半是风狂半是颠。随身用提篮背剑，货卖云烟。 人间飘荡多年，曾占东华第一筵。推倒玉楼，种吾奇树，黄河放浅，栽我金莲。踤碎珊瑚，翻身北海，稽首虚皇高座前。无难事，要功成八百、行满三千。 桃花扇 [清·孔尚任] 暮晓春来迟，先于百花知。岁岁种桃树，开在断肠时。 贺新郎·寄辛幼安和见怀韵 [宋·陈亮] 老去凭谁说。看几番、神奇臭腐，夏裘冬葛。父老长安今余几，后死无仇可雪。犹未燥、当时生发。二十五弦多少恨，算世间、那有平分月。胡妇弄，汉宫瑟。树犹如此堪重别。只使君、从来与我，话头多合。行矣置之无足问，谁换妍皮痴骨。但莫使、伯牙弦绝。九转丹砂牢拾取，管精金、只是寻常铁。龙共虎，应声裂。 无门关 [宋·黄龙慧开禅师] 春有百花秋有月，夏有凉风冬有雪，若无闲事挂心头，便是人间好时节。饥来食，困则眠，热取凉，寒向火。平常心即是自自然然，一无造作，了无是非取舍，只管行住坐卧，应机接物。 西游记 [明·吴承恩] 观棋柯烂，伐木丁丁，云边谷口徐行。卖薪沽酒，狂笑自陶情。苍径秋高，对月枕松根，一觉天明。认旧林，登崖过岭，持斧断枯藤。收来成一担，行歌市上，易米三升。更无些子争竞，时价平平。不会机谋巧算，没荣辱，恬淡延生。相逢处，非仙即道，静坐讲《黄庭》。 青玉案·元夕 [宋·辛弃疾 ] 东风夜放花千树。更吹落、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。 蛾儿雪柳黄金缕。笑语盈盈暗香去。众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 那年那兔那些事","date":"2019-03-12T06:57:57.176Z","updated":"2018-04-08T01:42:15.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 那年那兔那些事/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布][置顶] 那年那兔那些事/","excerpt":"","text":"那年那兔那些事序言写一篇中长篇记事，算是对人对事的一种不断的自我总结与反思。 一、 夜游杭城–毕业有感该毕业了，大家都绝口不提离别的事。真的到了那一天，才发现一切都要结束。或许带走了太多的遗憾，或许曾年少轻狂，当一切回忆都成为往事，真的不忍心说那句“曲终人散”。 总觉得要离别的人都有些不正常。看着一天比一天少的人，数着一天天邻近的日子，除了心里有些别扭外，却装作一脸漠然。当有一天，你一脚踹开一个你再熟悉不过的寝室的门时，却发现已人去楼空。到那时真的连个相拥而泣的人都没有。 总是抱怨来到杭州一个月，都没有机会出去玩过。6月6日晚寝室一行六人，于凌晨两点，结伴游于杭城，夜风习习，一路无语。那是突然想到一句话“人生苦短，秉烛夜游”。 One Night in Hangcheng 留下许多情…… 2010-06-08 这还是当初大学毕业时写的一篇日志，一晃这么多年过去了再未提笔，姑且算作开篇吧。 二、意识到自己不完美，才是变得完美的开始一个人变得完美，恰恰是从他愿意承认自己不完美开始的… 三、没什么大不了四、对于曾经，我们只是过客五、人生的不同生活状态六、愿你出走半生 归来仍是少年七、随想有一段时间很想去考研，可是一想，现在都二十七了，等考出来毕了业都三十岁了，别人都成家立业，我却刚刚毕业，想想还是算了吧。后来，三年过去了，我也到了三十岁。除了年龄的增长，与三年前没有任何区别。 一直脑海中有一副画面，很模糊，空旷而不沧桑，人迹罕至而又充满生机，灰暗甚至有些空灵，平和而不突兀。。。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 思维体系/几点思考 - 生活/[未发布] 语录","date":"2019-03-12T06:57:57.168Z","updated":"2018-09-03T06:31:45.000Z","comments":true,"path":"2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布] 语录/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 思维体系/几点思考 - 生活/[未发布] 语录/","excerpt":"","text":"陈二狗的妖孽人生 若梁灏，八十二。对大廷，魁多士。 纽约比加州时间早3个小时 纽约时间比加州时间早三个小时， New York is 3 hours ahead of California,但加州时间并没有变慢。but it does not make California slow.有人22岁就毕业了，Someone graduated at the age of 22,但等了五年才找到稳定的工作！but waited 5 years before securing a good job!有人25岁就当上CEO，Someone became a CEO at 25,却在50岁去世。and died at 50.也有人迟到50岁才当上CEO，While another became a CEO at 50,然后活到90岁。and lived to 90 years.有人单身，Someone is still single,同时也有人已婚。while someone else got married.欧巴马55岁就退休，Obama retires at 55,川普70岁才开始当总统。but Trump starts at 70.世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone.身边有些人看似走在你前面，People around you might seem to go ahead of you,也有人看似走在你后面。some might seem to be behind you.但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them.他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours!生命就是等待正确的行动时机。Life is about waiting for the right moment to act.所以，放轻松。So, RELAX.你没有落后。You’re not LATE.你没有领先。You’re not EARLY.在上帝为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE GOD set up for you. 事出无常必有妖。将心比心便是佛心。成大事者不谋于众。可怜之人必有可恨之处。少不读水浒,老不读三国。我心中有猛虎,细嗅蔷薇。山低猴子吊，水浅王八跳。相濡以沫不如相忘于江湖。心有大道，方能风生水起。30年众生马牛,60年诸佛龙象。土地下埋有尸骨,还葬有野心。世间皆为虚幻，刹那便是永恒。恕心养至极处，世间皆无罪过。此心拖泥带水，是人生最苦处。闭门即是深山，心静随处净土。再穷不过要饭，不死终会出头。人相忘于道术。鱼相忘于江湖。世途渺于鸟道，人情浮比鱼蛮。做生意无非做正做奇两个法子。苦到对谁都不能哭，才是真的苦。处事谨慎如鼠，为人却举措雄阔。少年子弟江湖老,红粉佳人两鬓斑。君子挟才以为善，小人挟才以为恶。这是最好的时代，这是最坏的时代。笑里藏刀比怒目金刚更加适合生存。莫道前路无知己，天下谁人不识君！越高度的文明衍化出更极端的野蛮。人生在世,无非三种,立德,立功,立言。人情这东西，用一次就淡一次，很现实。原来世上有种幸福，可以让人哭到心痛。人情这东西，用一次就淡一次，很现实。做一件事情要是走火入魔了就成功了一半。人穷志短,马瘦毛长;饱暖思淫欲,饥寒起盗心。恕心养到极处,世间再无罪过。引自《呻吟语》有个疯癫老头子说过，穷人的穷不是笨，是命。世界有一半在嘲笑另一半,其实全世界都是傻瓜。人生大多如此，相遇不一定相知，相逢未必相亲。从这个世界走到那个世界,需要几代人的攀爬挣扎?一本书先读厚再读薄，这本书，才真的是读进去了。旁门八百，左道三千，骑驴找驴，不可笑，只遗憾。君生我未生，我生君已老。 君恨我生迟，我恨君生早。出八分力,做十分成绩,留两分余地不至于那般身心疲倦。这个社会不缺脑袋灵光的人，可缺持之以恒做傻事地聪明人。人生不过百年，孰能大醉三万六千五百场？能醉一场是一场。与人争吵辩驳，有理要镇定，没理也要稳住，最忌讳自乱阵脚。天底下越是鲜艳越是不劳而获的横财，往往埋藏有致命的横祸。一个男人生前要达到什么高度的不可一世,才可以避免死于无名?25岁前，在人之下，把自己当人；25岁之后，在人之上，要把人当人。官场，只有落水狗没有逍遥人，情场，也从来多是伤心汉少有幸福人。一个人如果没办法30秒内扔掉一切可有可无的东西就注定会被生活抛弃。对地位比自己低地人一定要客气尊重，再势利的人也不喜欢结交势利的人。这个的确世态炎凉的社会也并不拒绝穷人的崛起，它拒绝的只是行动上的懦夫。谁拿流年乱了浮生，又借浮生乱了红尘。此生若能得幸福安稳，谁又愿颠沛流离？道髓和佛谛一般，无用功处,只是平常无事。困来即卧，于小事得道，于小人成佛。在这个无比实际的社会，谁身上沉甸甸的荣华可能是简简单单轻轻松松的唾手可得？假装对别人很宽容，其实就是自己无能，因为不敢伤害别人，就懦弱而苍白地解释成原谅。一个人的知识面是一个圆圈，知识储备越多，圆圈越大，接触到的面积便越广阔，便能掌握和窥视更多的机会。一个女人一辈子总得给某个男人花痴一回，最好是初恋。那个时候可以笨点再笨点，然后便可以把精明和智慧留给婚姻。我可以20岁之前没钱，那很正常，可以不懂事的拿家庭做借口，但30岁之前如果还浑浑噩噩穷困潦倒，那不是宿命，是自作孽。一个男人抛开光鲜的外衣.显赫的身世.不错的相貌.剩下什么?是满腹脏水猥亵?是一腔无病呻吟的怨天尤人?还是一胸襟的山河锦绣?不管是小人物还是富贵子孙,要成功,都得眼睛看远一点,度量放大一点,脑子多想一点,然后怀六分恶毒,三分炎凉,还得给自己给子孙剩一分善心。若无缘，三千大千世界，百万菩提众生，为何与我笑颜独展，惟独与汝相见？若有缘，待到灯花百结之后，三尺之雪，一夜白发，至此无语，却只有灰烬，没有复燃女人跟感情的关系就像猫和老鼠,年轻女孩对待感情就像出道没多久的猫,一见到某只老鼠就以为过了这村没这店了,恨不得吞进肚子里珍藏一辈子,抓丢了就哭的撕心裂肺.逮劳了又患得患失 春生夏长秋收冬藏春雨夏雷秋风冬雪 所经历的一切苦难都源自于不甘心","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/12 - Linux.","date":"2019-03-12T06:57:57.152Z","updated":"2018-11-29T03:15:04.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/12 - Linux./","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/12 - Linux./","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC100 Windows & Office 使用/快速批量提取文件夹中次级文件夹及文件名称的技巧","date":"2019-03-12T06:57:57.152Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC100 Windows & Office 使用/快速批量提取文件夹中次级文件夹及文件名称的技巧/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC100 Windows & Office 使用/快速批量提取文件夹中次级文件夹及文件名称的技巧/","excerpt":"","text":"一、前言想对某个文件夹做个内容列表，把文件名字一个个复制，再粘贴到文本文档——太麻烦了！怎么办？ 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、方法 首先调出MS-DOS窗：win+R -&gt;cmd -&gt;回车。 方法一：tree命令 命令提示符下：tree (要获得文件名的文件夹的路径）/f&gt;（列表文件存放的路径及文件名/filename）注意：“/f&gt;”前面的空格不可少！ 例如：要获得D盘下的所有文件的文件名，并将生成的文件保存到D盘，文件名为123.txt。可使用如下命令： 1tree D: /f&gt;D:/123.txt 方法二：dir命令 1dir c:\\ &gt;d:\\123.txt 将C盘根目录里的文件夹名和文件名都保存在D盘目录下的123.txt里。此文件可导入excel作进一步处理。dir可加参数 /w 等。（加下划线的这条是原作者[1]写的，我还没试过……） 也可以先在命令提示符下进入某文件夹，然后输入： 1dir &gt;&gt; list.txt 回车，目录列表就到list.txt这个文件里了。 小提示： 可以先在记事本中写好，将其粘贴(注意：不能用Ctrl+V)到cmd.exe程序中。例：将下列复制到cmd.exe中即可 1tree D: /f&gt;D:/123.xls 三、tree命令和dir命令的区别 tree能够以字符画的样式清晰的表明所有次级文件夹和文件（包括次级文件夹中的文件）的名称、存储位置隶属关系，而dir只能列出二级子文件夹的名称和根目录下文件的名称； dir能显示各二级子文件夹和根目录下文件的最后修改时间（从年到分钟），tree不能；； dir能分类统计二级子文件夹和根目录下文件各自的个数及总体积（单位：字节），tree不能； tree生成的列表文件体积比dir生成的大（由第1条区别也可猜出这一点）。 四、其他 若是音乐文件，可将音乐文件拖进千千静听等播放软件，然后另存为播放列表。此列表用记事本打开即可查看。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/13 - 优化","date":"2019-03-12T06:57:57.152Z","updated":"2018-11-29T03:15:29.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/13 - 优化/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/13 - 优化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/10 - Java代码查错","date":"2019-03-12T06:57:57.148Z","updated":"2018-11-29T03:14:25.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/10 - Java代码查错/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/10 - Java代码查错/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/11 - 问得稀里糊涂的题","date":"2019-03-12T06:57:57.148Z","updated":"2018-11-29T03:14:43.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/11 - 问得稀里糊涂的题/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/11 - 问得稀里糊涂的题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/9 - 算法与编程","date":"2019-03-12T06:57:57.148Z","updated":"2018-11-29T03:14:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/9 - 算法与编程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/9 - 算法与编程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/6 - 软件工程与设计模式","date":"2019-03-12T06:57:57.144Z","updated":"2018-11-29T03:12:17.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/6 - 软件工程与设计模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/6 - 软件工程与设计模式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/7 - J2EE部分","date":"2019-03-12T06:57:57.144Z","updated":"2018-11-29T03:12:39.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/7 - J2EE部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/7 - J2EE部分/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/8 - websevice部分","date":"2019-03-12T06:57:57.144Z","updated":"2018-11-29T03:13:45.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/8 - websevice部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/8 - websevice部分/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/4 - 数据库部分","date":"2019-03-12T06:57:57.140Z","updated":"2018-11-29T03:11:31.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/4 - 数据库部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/4 - 数据库部分/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/5- 流行的框架与新技术","date":"2019-03-12T06:57:57.140Z","updated":"2018-11-29T03:11:55.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/5- 流行的框架与新技术/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/5- 流行的框架与新技术/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/1- Java基础部分","date":"2019-03-12T06:57:57.136Z","updated":"2018-11-29T08:37:45.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/1- Java基础部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/1- Java基础部分/","excerpt":"","text":"[TOC] 一、前言 基础部分的顺序：基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，IO的语法，虚拟机方面的语法。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.06.22 1.0 ZZ 初稿 三、基本语法3.1、 Java优缺点优点： 1） 指针 任何一个学过C或者C++的人都知道指针的操作对于他们是很重要的,为什么,指针能够支持内存的直接操作,这样的直接操作能够带来的是效率上的提高.但是任何一个东西都是有副作用的,指针给程序员带了的混乱也是无可比拟的.对于一个不是很强劲的C程序员而言,指针是要命的(对我而言也是,我几乎不会写C代码).而JAVA就为我们省去了这样的麻烦,或者说JAVA完整的限制了对内存的直接操作,让程序员能够安心去搞业务逻辑,而不用管自己后院的那堆内存有没有人来收拾.2）垃圾回收 其实垃圾回收也是JAVA对于内存操作的限制之一,也大大解放了程序员的手脚.但是也正是这样的一个内存保姆的存在导致JAVA程序员在内存上几乎没有概念…一个纯粹的JAVA程序员对于内存泄露这样的问题是从来没有概念的,因为他从来不用担心,因为大多数情况下即便他大手大脚也不会有什么问题3）平台无关性 平台无关性的真正意义在于程序的可移植性高，能够在多个平台平滑迁移。这点就特别适合网络应用。缺点：1） 效率 当然首先就是内存操作限制带来安全的同时带来的副面效果了….. 其次呢,就是面对对象的一个很重要的特点所带来的——多态导致的。 平台无关性带来的。由于需要平台无关，所以JAVA是不能直接调用OS的API的，JAVA需要调用自己的API来隐式地调用OS的API，大家可想而知这样的效果。多一层调用，必然多一层代码需要加载到栈内了。2） 逆向编译问题 由于JAVA程序是动态连接的，从一个类到另外一个类的引用是符号化的。在静态连接的可执行程序中，类之间的只是直接的指针或者偏移量，。相反地，在JAVA class文件中，指向另一个类的引用通过字符串清楚地标明了所指向的类的名字。如果引用指向一个字段的话，这个字段的名字和描述符会被详细说明。如果引用指向一个成员变量，这个成员变量的名字和描述符（方法的返回类型，方法参数的数量和类型）也会被详细说明。3）线程调度问题 Java虽然是一个总进程下的多线程，但是线程间的调度没有非常的清晰，由于为了能够支持多种系统的不同的线程支持策略，JAVA只能采取这样笼统而又松散的线程规范。 3.2、 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 3.3、Java有没有goto?Java中的保留字，现在没有在java中使用。 3.4、说说&amp; 和&amp;&amp; 的区别。 &amp; 运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp; 运算符是短路与运算。 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp; 之所以称为短路运算是因为，如果&amp;&amp; 左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。 很多时候我们可能都需要用&amp;&amp; 而不是&amp; ，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp; !username.equals(“”)，二者的顺序不能交换，更不能用&amp; 运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较（会分配空字符串长度的内存），否则会产生NullPointerException异常。 &amp; 还可以用作位运算符，当&amp; &amp; 表示按位与操作，我们通常使用0x0f（0000 1111）来与一个整数进行&amp; 运算，来获取该整数的最低4个bit位，例如，0x01 &amp; 0x0f的结果为0x01。 3.5、 在JAVA中如何跳出当前的多重嵌套循环？ 用break; return 方法。 3.6、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 3.7、 float f=3.4;是否正确？ 答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 3.8、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 加法和赋值运算 VS 自增运算 3.9、char型变量中能不能存贮一个中文汉字?为什么? char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 3.10、用最有效率的方法算出2乘以8等於几? 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方），而位运算cpu直接支持的，效率最高。 3.11、请设计一个一百亿的计算器 首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。 首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。-1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下： 1234int a = Integer.MAX_VALUE;int b = Integer.MAX_VALUE;int sum = a + b;System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum); 先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于210001000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下：• 这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数• 有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中• 提供加减乘除的功能 12345678910111213141516public class BigInteger&#123; int sign; byte[] val; public Biginteger(String val) &#123; sign = ; val = ; &#125; public BigInteger add(BigInteger other)&#123; &#125; public BigInteger subtract(BigInteger other) &#123; &#125; public BigInteger multiply(BigInteger other)&#123; &#125; public BigInteger divide(BigInteger other) &#125;&#125; 备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看jdk中自带的java.math.BigInteger、BigDecimal类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 3.12、Math.round(11.5)等於多少? Math.round(-11.5)等於多少? Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 3.13、main方法通过命令行输入参数 cmd java hello zhang 19。 四、面向对象对象代表对数据和操作的一种封装,类是对象的一种抽象。 4.1、你对面向对象思想的理解面向对象(Object Oriented,OO)是当前计算机界关心的重点，它是90年代软件开发方法的主流。面向对象的概念和应用已超越了程序设计和软件开发，扩展到很宽的范围。如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。 面向对象的特征1）对象唯一性。 每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。 2）分类性。 分类性是指将具有一致的数据结构(属性)和行为(操作)的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。 3）继承性。 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。 在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。 在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。 在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重性。 采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。 4）多态性(多形性) 多态性使指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。 多态性允许每个对象以适合自身的方式去响应共同的消息。 多态性增强了软件的灵活性和重用性。 4.2、数组和链表的理解，及优缺点？ 链表是一种常见的数据组织形式，它采用动态分配内存的形式实现。需要时可以用new分配内存空间，不需要时用delete将已分配的空间释放，不会造成内存空间的浪费。 A）从逻辑结构来看 A-1. 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。 A-2. 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项） B）从内存存储来看 B-1. (静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小 B-2. 链表从堆中分配空间, 自由度大但是申请管理比较麻烦。 数组中的数据在内存中的按顺序存储的，而链表是随机存储的！ 要访问数组中的元素可以按下标索引来访问，速度比较快，如果对他进行插入操作的话，就得移动很多元素，所以对数组进行插入操作效率很低！ 由于连表是随机存储的，链表在插入，删除操作上有很高的效率（相对数组），如果要访问链表中的某个元素的话，那就得从链表的头逐个遍历，直到找到所需要的元素为止，所以链表的随机访问的效率就比数组要低 数组在内存中开辟连续的一块区域，如果一个数据要两个内存单元，一组5个数据10个单元就够了，无需标记其地址，因为数组定义时候标顶了第一个原许的地址，其他四个都知道了。 链表可可以是连续的，也可以是不连续的，但一般都是不连续的，尽管在内存中是连续的，我们也不把他当作是连续的，而是把他当作是不连续的，因为如果把他当作是连续的，不如当作是数组了，在某些情况下。一链5个数据，如果每个数据本身用2个内存单元，那么10个单元是不够的，因为每个数据都要表示出下个数据在哪里，所以一个数据本身用2个单元，再用1个单元表示此链下一个数据在什么地址。 4.3、写几个java.lang.Object类中的方法名称 equals()；toString()；getClass()；hashCode(；clone()；finalize()；notify()；wait()；notify() 4.4、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：1final StringBuffer a=new StringBuffer(\"immutable\"); 执行如下语句将报告编译期错误： 1a=new StringBuffer(\"\"); 但是，执行如下语句则可以通过编译： 1a.append(\" broken!\"); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： 1public void method(final StringBuffer param)&#123;...&#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： 1param.append(\"a\"); 4.5、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。 4.6、”==”和equals方法究竟有什么区别？ （单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚） ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码： 12String a=new String(\"foo\");String b=new String(\"foo\"); 两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下： 123boolean equals(Object o)&#123;return this==o;&#125; 这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 4.7、静态变量和实例变量的区别？ 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。 4.8、 静态变量、成员变量、局部变量的生命周期 静态变量:属于类,生命周期由类来决定 成员变量:随着类的实例(对象)的创建而创建,并初始化,随着对象的垃圾回收而消失。 4.9、是否可以从一个static方法内部发出对非static方法的调用？ 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 4.10、 请说出作用域public，private，protected，以及不写时的区别 作用域 当前类 同 包 子 类 其他包 public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 4.11、 Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?方法的重写Overriding和重载Overloading是Java多态性的不同表现。区别在于重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 4.12、为什么不能根据返回类型来区分重载？4.13、 继承时候类的执行顺序问题,一般都是选择题,问你将会打印出什么? 123456789// 父类package test;public class FatherClass&#123; public FatherClass() &#123; System.out.println(\"FatherClass Create\"); &#125;&#125; 123456789101112131415// 子类package test;import test.FatherClass;public class ChildClass extends FatherClass&#123; public ChildClass() &#123; System.out.println(\"ChildClass Create\"); &#125; public static void main(String[] args) &#123; FatherClass fc = new FatherClass(); ChildClass cc = new ChildClass(); &#125;&#125; 输出结果1234C:\\&gt;java test.ChildClassFatherClass CreateFatherClass CreateChildClass Create 4.14、构造器（constructor）是否可被重写（override） 构造器不能被继承，因此不能被重写，但可以被重载。 4.15、构造方法的概念 类的构造方法是一种比较特殊的方法,它不能被程序员显式的调用,只能在创建对象时,有系统自动调用。 4.16、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？ 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 4.17、写clone()方法时，通常都有一行代码，是什么？ clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，负责产生正确大小的空间，然后才是复制自己的成员。 4.18、面向对象的特征有哪些方面 面向对象的编程语言有封装、继承 、抽象、多态4个主要的特征。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 4.19、 java中实现多态的机制是什么？ 靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 从一个基类中派生，响应一个虚命令，产生不同的结果。 4.20、 abstract class和interface有什么区别? 答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法 接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口 下面比较一下两者的语法区别： 1）抽象类可以有构造方法，接口中不能有构造方法。 2）抽象类中可以有普通成员变量，接口中没有普通成员变量 3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 4）抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然Eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 5）抽象类中可以包含静态方法，接口中不能包含静态方法 6） 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 7） 一个类可以实现多个接口，但只能继承一个抽象类。 下面接着再说说两者在应用上的区别： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： 12345678910111213141516171819202122public abstract class BaseServlet extends HttpServlet&#123; public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException &#123; // 记录访问日志，进行权限判断 if(具有权限)&#123; try&#123; doService(request,response); &#125; catch(Excetpion e) &#123; //记录异常信息 &#125; &#125; &#125; protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException; //注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的 &#125; public class MyServlet1 extends BaseServlet&#123; protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException &#123; //本Servlet只处理的具体业务逻辑代码 &#125; &#125; 父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 4.21、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 4.22、 抽象类为什么不能实例化？ 抽象类就是类里面含有了抽象的方法。抽象的方法就是没有实现的方法 有抽象的方法当然不能实例化，如果它能实例 那么这个实例调用那个没有实现的抽象方法会有什么结果。所以抽象类不能实例化。 4.23、什么是内部类？Static Nested Class 和 Inner Class的不同。 内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化 在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类： 1Outer.Inner inner = new Outer.Inner(); 由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 4.24、内部类的实现方式? 示例代码如下：123456789101112131415161718package test;public class OuterClass &#123; public OuterClass() &#123; InterClass ic = new InterClass(); System.out.println(\"OuterClass Create\"); &#125; public static void main(String[] args) &#123; OuterClass oc = new OuterClass(); &#125; private class InterClass &#123; public InterClass() &#123; System.out.println(\"InterClass Create\"); &#125; &#125;&#125; 输出结果: 123C:\\&gt;java test/OuterClassInterClass CreateOuterClass Create 再一个例题： You need to insert an inner class declaration at line 3. Which two inner class declarations are valid?(Choose two.) 1234public class OuterClass &#123; private double d1 = 1.0; //insert code here&#125; 123456789101112131415A. class InnerOne&#123; public static double methoda() &#123;return d1;&#125; &#125;B. public class InnerOne&#123; static double methoda() &#123;return d1;&#125; &#125;C. private class InnerOne&#123; double methoda() &#123;return d1;&#125; &#125;D. static class InnerOne&#123; protected double methoda() &#123;return d1;&#125; &#125;E. abstract class InnerOne&#123; public abstract double methoda(); &#125; 说明如下： 一.静态内部类可以有静态成员，而非静态内部类则不能有静态成员。 故 A、B 错 二.静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量；return d1 出错。 故 D 错 三.非静态内部类的非静态成员可以访问外部类的非静态变量。 故 C 正确 四.答案为C、E 4.25、内部类可以引用它的包含类的成员吗？有没有什么限制？ 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 4.26、 Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 4.27、super.getClass()方法调用 下面程序的输出结果是多少？123456789import java.util.Date;public class Test extends Date&#123; public static void main(String[] args) &#123; new Test().test(); &#125; public void test() &#123; System.out.println(super.getClass().getName());&#125;&#125; 很奇怪，结果是Test 这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。 在test方法中，直接调用getClass().getName()方法，返回的是Test类名 由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。 如果想得到父类的名称，应该用如下代码： 1getClass().getSuperClass().getName(); 4.28、String是最基本的数据类型吗? 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 4.29、Integer与int的区别Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。1234567public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 4.30、String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world !”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做： public class Demo {private String s;//public Demo {s = “Initial Value”;}//} 而非s = new String(“Initial Value”); 后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。 至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。 4.31、是否可以继承String类? String类是final类故不可以继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 3.232、String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？ 两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。 4.33、String s =”xyz”创建对象了吗？ JVM在遇到双引号操作符时,自动创建一个String对象(对象池有则不创建),值为abc,返回一个该对象的引用。 4.34、String和StringBuilder、StringBuffer的区别？Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 4.35、什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？字符串拼接，因为可以在编译阶段进行？。 4.36、如何把一段逗号分割的字符串转换成一个数组?如果不查jdk api，我很难写出来！我可以说说我的思路：1） 用正则表达式，代码大概为：String [] result = orgStr.split(“,”);2） 用 StingTokenizer ,代码为 StringTokenizer tokener = StringTokenizer(orgStr,”,”); String [] result = new String[tokener .countTokens()]; Int i=0; while(tokener.hasNext(){ result[i++]=toker.nextToken(`); } 4.37、数组有没有length()这个方法? String有没有length()这个方法？ 数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 4.38、下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”; 答：对于如下代码： 12345String s1 = \"a\";String s2 = s1 + \"b\";String s3 = \"a\" + \"b\";System.out.println(s2 == \"ab\");System.out.println(s3 == \"ab\"); 第一条语句打印的结果为false（s2.equals(“ab”)–true），第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码 12String s = \"a\" + \"b\" + \"c\" + \"d\";System.out.println(s == \"abcd\"); 最终打印的结果应该为true。 4.39、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果： 1234567891011121314151617public class Test &#123; /** * @param args add by zxx ,Dec 9, 2008 */ public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(new Test().test()); &#125; static int test() &#123; int x = 1; try &#123; return x; &#125; finally &#123; ++x; &#125; &#125;&#125; ———执行结果 ——— 运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。 4.40、下面的程序代码输出的结果是多少？123456789101112131415161718192021public class smallT&#123; public static void main(String args[]) &#123; smallT t = new smallT(); int b = t.get(); System.out.println(b); &#125; public int get() &#123; try &#123; return 1 ; &#125; finally &#123; return 2 ; &#125; &#125;&#125; 返回的结果是2。 我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。 在讲解答案时可以用下面的程序来帮助分析：123456789101112131415161718192021222324252627282930313233public class Test &#123; /** * @param args add by zxx ,Dec 9, 2008 */ public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(new Test().test());; &#125; int test() &#123; try &#123; return func1(); &#125; finally &#123; return func2(); &#125; &#125; int func1() &#123; System.out.println(\"func1\"); return 1; &#125; int func2() &#123; System.out.println(\"func2\"); return 2; &#125;&#125; ———–执行结果—————– func1 func2 2 结论：finally中的代码比return 和break语句后执行 4.41、final, finally, finalize的区别。 final 用于修饰类：表示该类不能被继承；修饰方法：表示方法不能被重写；修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。 五、集合与泛型5.1、介绍Collection框架的结构随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。 5.2、 Collection框架中实现比较要实现什么接口 comparable / comparator 5.3、 ArrayList和Vector的区别 这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。 接着才说ArrayList与Vector的区别，这主要包括两个方面：. 1）同步性： Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 备注：对于Vector &amp; ArrayList、Hashtable &amp; HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。2）数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。 5.4、HashMap和Hashtable的区别 （条理上还需要整理，也是先说相同点，再说不同点） HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 就HashMap与HashTable主要从三方面来说。 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 三.值：只有HashMap可以让你将空值作为一个表的条目的key或value。 5.5、List 和 Map 区别? 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 5.6、List, Set, Map是否继承自Collection接口? List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 5.7. List、Map、Set三个接口，存取元素时，各有什么特点？ List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 5.8. 说出ArrayList,Vector, LinkedList的存储性能和特性 ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 5.9、去掉一个Vector集合中重复的元素1234567Vector newVector = new Vector();For (int i=0;i&lt;vector.size();i++)&#123;Object obj = vector.get(i); if(!newVector.contains(obj); newVector.add(obj);&#125; 还有一种简单的方式，HashSet set = new HashSet(vector); 5.10、Collection 和 Collections的区别。 Collection是集合类的上级接口，继承与他的接口主要有Set 和List. Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 5.11、 基本数据类型和引用数据类型 基本数据类型：byte,short,int,long,float,double,boolean,char一般储存是比较小的数据对象。 引用数据类型：保存的数据一般比较大,如果每次赋值传参时都把数据完全拷贝一遍会影响效率,因此java所有操作对象的数据类型定义为引用数据类型. ValueOf(int) 、intValue(Object) 1.“==”作用在引用数据类型间，判断内存地址是否相等，想判断内容实体用equals； 2、基本传值传参传的是副本，修改后原值不变；引用传值传参穿的是地址，修改后原值改变。 12. Boolean和boolean 的区别 1.boolean存在于栈,Boolean对象存在于堆 2.boolean是基本数据类型,Boolean是类 3.Boolean多一个bull值 5.13、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 5.14、你所知道的集合类都有哪些？主要方法？ 最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。 ArrayList/VectorList CollectionHashSet/TreeSetSet PropetiesHashTable MapTreemap/HashMap 我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove, contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。 5.15、 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对? 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。 Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 5.16、TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！ （应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的） 实验代码：123456789101112131415161718192021222324252627282930313233343536373839404142public class Parent implements Comparable &#123; private int age = 0; public Parent(int age)&#123; this.age = age; &#125; public int compareTo(Object o) &#123; // TODO Auto-generated method stub System.out.println(\"method of parent\"); Parent o1 = (Parent)o; return age&gt;o1.age?1:age&lt;o1.age?-1:0; &#125;&#125;public class Child extends Parent &#123; public Child()&#123; super(3); &#125; public int compareTo(Object o) &#123; // TODO Auto-generated method stub System.out.println(\"method of child\");// Child o1 = (Child)o; return 1; &#125;&#125;public class TreeSetTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub TreeSet set = new TreeSet(); set.add(new Parent(3)); set.add(new Child()); set.add(new Parent(4)); System.out.println(set.size()); &#125;&#125; 5.17、说出一些常用的类，包，接口，请各举5个 常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer 常用的包：java.lang java.awt java.io java.util java.sql 常用的接口：Remote List Map Document NodeList 5.18、打印昨天的当前时刻123456789import java.util.Calendar;class YesterdayCurrent &#123; public static void main(String[] args)&#123; Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE, -1); System.out.println(cal.getTime()); &#125;&#125; 六、IO、序列化、反射6.1、请简述什么是流流是指一连串流动的字符，是以先进先出的方式发送和接收数据的通道， 流分为输入流和输出流，输入输出流是相对于计算机内存来说的，如果数据输入到内存，则称为输入流，如果从内存中流出则称为输出流。 6.2、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。 6.3、字节流与字符流的区别 要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。 在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。 字符向字节转换时，要注意编码的问题，因为字符串转成字节数组， 其实是转成该字符的某种编码的字节形式，读取也是反之的道理。 讲解字节流与字符流关系的代码案例：12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.InputStreamReader;import java.io.PrintWriter;public class IOTest &#123; public static void main(String[] args) throws Exception &#123; String str = \"中国人\"; /*FileOutputStream fos = new FileOutputStream(\"1.txt\"); fos.write(str.getBytes(\"UTF-8\")); fos.close();*/ /*FileWriter fw = new FileWriter(\"1.txt\"); fw.write(str); fw.close();*/ PrintWriter pw = new PrintWriter(\"1.txt\",\"utf-8\"); pw.write(str); pw.close(); /*FileReader fr = new FileReader(\"1.txt\"); char[] buf = new char[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len); System.out.println(myStr);*/ /*FileInputStream fr = new FileInputStream(\"1.txt\"); byte[] buf = new byte[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len,\"UTF-8\"); System.out.println(myStr);*/ BufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream(\"1.txt\"),\"UTF-8\" ) ); String myStr = br.readLine(); br.close(); System.out.println(myStr); &#125;&#125; 6.4、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流 例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络 上传输对象，被传输的对象就必须实现Serializable接口。 6.5、编程实现文件拷贝（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public final class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; //public static void fileCopy(String source, String target) throws IOException &#123; // try (InputStream in = new FileInputStream(source)) &#123; // try (OutputStream out = new FileOutputStream(target)) &#123; // byte[] buffer = new byte[4096]; // int bytesToRead; // while((bytesToRead = in.read(buffer)) != -1) &#123; // out.write(buffer, 0, bytesToRead); // &#125; // &#125; // &#125; //&#125; //public static void fileCopyNIO(String source, String target) throws IOException &#123; // try (FileInputStream in = new FileInputStream(source)) &#123; // try (FileOutputStream out = new FileOutputStream(target)) &#123; // FileChannel inChannel = in.getChannel(); // FileChannel outChannel = out.getChannel(); // ByteBuffer buffer = ByteBuffer.allocate(4096); // while(inChannel.read(buffer) != -1) &#123; // buffer.flip(); // outChannel.write(buffer); // buffer.clear(); // &#125; // &#125; // &#125; //&#125;&#125; 注意：上面用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。 6.6、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。代码如下：123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.FileReader;public final class MyUtil &#123; // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) private MyUtil() &#123; throw new AssertionError(); &#125; /** * 统计给定文件中给定字符串的出现次数 * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ // public static int countWordInFile(String filename, String word) &#123; // int counter = 0; // try (FileReader fr = new FileReader(filename)) &#123; // try (BufferedReader br = new BufferedReader(fr)) &#123; // String line = null; // while ((line = br.readLine()) != null) &#123; // int index = -1; // while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; // counter++; // line = line.substring(index + word.length()); // &#125; // &#125; // &#125; // &#125; catch (Exception ex) &#123; // ex.printStackTrace(); // &#125; // return counter; // &#125;&#125; 6.7、 如何用Java代码列出一个目录下所有的文件？如果只要求列出当前文件夹下的文件，代码如下所示： 123456789101112import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; File f = new File(\"/Users/Hao/Downloads\"); for(File temp : f.listFiles()) &#123; if(temp.isFile()) &#123; System.out.println(temp.getName()); &#125; &#125; &#125;&#125; 如果需要对文件夹继续展开，代码如下所示：1234567891011121314151617181920212223242526import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; showDirectory(new File(\"/Users/Hao/Downloads\")); &#125; public static void showDirectory(File f) &#123; _walkDirectory(f, 0); &#125; private static void _walkDirectory(File f, int level) &#123; if(f.isDirectory()) &#123; for(File temp : f.listFiles()) &#123; _walkDirectory(temp, level + 1); &#125; &#125; else &#123; for(int i = 0; i &lt; level - 1; i++) &#123; System.out.print(\"\\t\"); &#125; System.out.println(f.getName()); &#125; &#125;&#125; 在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：123456789101112131415class ShowFileTest &#123; public static void main(String[] args) throws IOException &#123; Path initPath = Paths.get(\"/Users/Hao/Downloads\"); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;&#125; 6.8、用Java的套接字编程实现一个多线程的回显（echo）服务器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer &#123; private static final int ECHO_SERVER_PORT = 6789; public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123; System.out.println(\"服务器已经启动...\"); while(true) &#123; Socket client = server.accept(); new Thread(new ClientHandler(client)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123; String msg = br.readLine(); System.out.println(\"收到\" + client.getInetAddress() + \"发送的: \" + msg); pw.println(msg); pw.flush(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： 123456789101112131415161718192021import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient &#123; public static void main(String[] args) throws Exception &#123; Socket client = new Socket(\"localhost\", 6789); Scanner sc = new Scanner(System.in); System.out.print(\"请输入内容: \"); String msg = sc.nextLine(); sc.close(); PrintWriter pw = new PrintWriter(client.getOutputStream()); pw.println(msg); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(br.readLine()); client.close(); &#125;&#125; 如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class EchoServerNIO &#123; private static final int ECHO_SERVER_PORT = 6789; private static final int ECHO_SERVER_TIMEOUT = 5000; private static final int BUFFER_SIZE = 1024; private static ServerSocketChannel serverChannel = null; private static Selector selector = null; // 多路复用选择器 private static ByteBuffer buffer = null; // 缓冲区 public static void main(String[] args) &#123; init(); listen(); &#125; private static void init() &#123; try &#123; serverChannel = ServerSocketChannel.open(); buffer = ByteBuffer.allocate(BUFFER_SIZE); serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); serverChannel.configureBlocking(false); selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static void listen() &#123; while (true) &#123; try &#123; if (selector.select(ECHO_SERVER_TIMEOUT) != 0) &#123; Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); handleKey(key); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void handleKey(SelectionKey key) throws IOException &#123; SocketChannel channel = null; try &#123; if (key.isAcceptable()) &#123; ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); channel = serverChannel.accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; channel = (SocketChannel) key.channel(); buffer.clear(); if (channel.read(buffer) &gt; 0) &#123; buffer.flip(); CharBuffer charBuffer = CharsetHelper.decode(buffer); String msg = charBuffer.toString(); System.out.println(\"收到\" + channel.getRemoteAddress() + \"的消息：\" + msg); channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (channel != null) &#123; channel.close(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder;public final class CharsetHelper &#123; private static final String UTF_8 = \"UTF-8\"; private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); private CharsetHelper() &#123; &#125; public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123; return encoder.encode(in); &#125; public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123; return decoder.decode(in); &#125;&#125; 6.9、获得一个类的类对象有哪些方式？ 方法1：类型.class，例如：String.class 方法2：对象.getClass()，例如：”hello”.getClass() 方法3：Class.forName()，例如：Class.forName(“java.lang.String”) 6.10、JAVA反射机制 原理运行时类型识别(Run-time Type Identification, RTTI)主要有两种方式，一种是我们在编译时和运行时已经知道了所有的类型，另外一种是功能强大的“反射”机制。 要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是由“Class对象”完成的，它包含了与类有关的信息。类是程序的重要组成部分，每个类都有一个Class对象，每当编写并编译了一个新类就会产生一个Class对象，它被保存在一个同名的.class文件中。在运行时，当我们想生成这个类的对象时，运行这个程序的Java虚拟机(JVM)会确认这个类的Class对象是否已经加载，如果尚未加载，JVM就会根据类名查找.class文件，并将其载入，一旦这个类的Class对象被载入内存，它就被用来创建这个类的所有对象。一般的RTTI形式包括三种： 1）传统的类型转换。如“(Apple)Fruit”，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。2）通过Class对象来获取对象的类型。如 Class c = Class.forName(“Apple”); Object o = c.newInstance();3）通过关键字instanceof或Class.isInstance()方法来确定对象是否属于某个特定类型的实例，准确的说，应该是instanceof / Class.isInstance()可以用来确定对象是否属于某个特定类及其所有基类的实例，这和equals() / ==不一样，它们用来比较两个对象是否属于同一个类的实例，没有考虑继承关系。 反射如果不知道某个对象的类型，可以通过RTTI来获取，但前提是这个类型在编译时必须已知，这样才能使用RTTI来识别。即在编译时，编译器必须知道所有通过RTTI来处理的类。使用反射机制可以不受这个限制，它主要应用于两种情况，第一个是“基于构件的编程”，在这种编程方式中，将使用某种基于快速应用开发(RAD)的应用构建工具来构建项目。这是现在最常见的可视化编程方法，通过代表不同组件的图标拖动到图板上来创建程序，然后设置构件的属性值来配置它们。这种配置要求构件都是可实例化的，并且要暴露其部分信息，使得程序员可以读取和设置构件的值。当处理GUI时间的构件时还必须暴露相关方法的细细，以便RAD环境帮助程序员覆盖这些处理事件的方法。在这里，就要用到反射的机制来检查可用的方法并返回方法名。Java通过JavaBeans提供了基于构件的编程架构。第二种情况，在运行时获取类的信息的另外一个动机，就是希望能够提供在跨网络的远程平台上创建和运行对象的能力。这被成为远程调用(RMI)，它允许一个Java程序将对象分步在多台机器上，这种分步能力将帮助开发人员执行一些需要进行大量计算的任务，充分利用计算机资源，提高运行速度。 Class支持反射，java.lang.reflect中包含了Field/Method/Constructor类，每个类都实现了Member接口。这些类型的对象都是由JVM在运行时创建的，用来表示未知类里对应的成员。如可以用Constructor类创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。同时，还可以调用getFields()、getMethods()、getConstructors()等方法来返回表示字段、方法以及构造器的对象数组。这样，未知的对象的类信息在运行时就能被完全确定下来，而在编译时不需要知道任何信息。另外，RTTI有时能解决效率问题。当程序中使用多态给程序的运行带来负担的时候，可以使用RTTI编写一段代码来提高效率。 6.11、 如何通过反射创建对象？ 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 6.12、 如何通过反射调用对象的方法？ 答：请看下面的代码：12345678import java.lang.reflect.Method;class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = \"hello\"; Method m = str.getClass().getMethod(\"toUpperCase\"); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 七、 异常、注解、多线程、网络编程、XML7.1、 运行时异常与一般异常有何异同？ 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。 7.2、error和exception有什么区别? error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 7.3、throw和throws关键字有什么区别 throw是抛出一个具体的异常类，产生一个异常。throws则是在方法名后标出该方法会产生何种异常需要方法的使用者捕获并处理。 7.4、Java中的异常处理机制的简单原理和应用。 异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误； 7.5、请写出你最常见到的5个runtime exception。 这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！ 所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException。 7.6、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。 用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。 throw语句用来明确地抛出一个”异常”。 throws用来标明一个成员函数可能抛出的各种”异常”。 Finally为确保一段代码不管发生什么”异常”都被执行一段代码。 可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常”的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。 7.7、 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后 答：会执行，在return前执行 7.8、 java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 有两种实现方法，分别是继承Thread类与实现Runnable接口，或者用线程池技术 用synchronized关键字修饰同步方法 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 7.9、sleep() 和 wait() 有什么区别? sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。 sleep是Thread类的方法，是线程用来控制自身流程的，比如有一个要报时的线程，每一秒中打印出一个时间，那么我就需要在print方法前面加上一个sleep让自己每隔一秒执行一次。就像个闹钟一样。 wait是Object类的方法，用来线程间的通信，这个方法会使当前拥有该对象锁的进程等待知道其他线程调用notify方法时再醒来，不过你也可以给他指定一个时间，自动醒来。这个方法主要是用走不同线程之间的调度的。 7.10.、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 7.11、 进程和线程区别 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于： 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了 程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执 行了序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。 7.12、 线程有几种实现方法?同步有几种实现方法? 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 同步的实现方面有两种，分别是synchronized,wait与notify 7.13、 请说出与线程同步以及线程调度相关的方法。 wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 7.14.、 启动一个线程是用run()还是start()? . 启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。run()方法是线程启动后要进行回调（callback）的方法。 7.15、什么是线程池（thread pool）？ 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。 线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 7.16、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 分几种情况：1）其他方法前是否加了synchronized关键字，如果没加，则能。2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。 7.17、线程的基本概念、线程的基本状态以及状态之间的关系 一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。 调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇 到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。 7.18.、简述synchronized和java.util.concurrent.locks.Lock的异同 ？ Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能； 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。 7.19、 设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 12345678910111213141516171819202122232425262728293031323334353637public class ThreadTest1&#123;private int j;public static void main(String args[])&#123; ThreadTest1 tt=new ThreadTest1(); Inc inc=tt.new Inc(); Dec dec=tt.new Dec(); for(int i=0;i&lt;2;i++)&#123; Thread t=new Thread(inc); t.start(); t=new Thread(dec); t.start(); &#125; &#125;private synchronized void inc()&#123; j++; System.out.println(Thread.currentThread().getName()+\"-inc:\"+j); &#125;private synchronized void dec()&#123; j--; System.out.println(Thread.currentThread().getName()+\"-dec:\"+j); &#125;class Inc implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; inc(); &#125; &#125;&#125;class Dec implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; dec(); &#125; &#125;&#125;&#125; 随手再写的一个12345678910111213141516171819202122232425262728293031323334class A&#123;JManger j =new JManager();main()&#123; new A().call();&#125;void call&#123; for(int i=0;i&lt;2;i++) &#123; new Thread( new Runnable()&#123; public void run()&#123;while(true)&#123;j.accumulate()&#125;&#125;&#125; ).start(); new Thread(new Runnable()&#123; public void run()&#123;while(true)&#123;j.sub()&#125;&#125;&#125;).start(); &#125;&#125;&#125;class JManager&#123; private j = 0; public synchronized void subtract() &#123; j-- &#125; public synchronized void accumulate() &#123; j++; &#125;&#125; 7.20、子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ThreadTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub new ThreadTest().init(); &#125; public void init() &#123; final Business business = new Business(); new Thread( new Runnable() &#123; public void run() &#123; for(int i=0;i&lt;50;i++) &#123; business.SubThread(i); &#125; &#125; &#125; ).start(); for(int i=0;i&lt;50;i++) &#123; business.MainThread(i); &#125; &#125; private class Business &#123; boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯 public synchronized void MainThread(int i) &#123; if(bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; for(int j=0;j&lt;5;j++) &#123; System.out.println(Thread.currentThread().getName() + \":i=\" + i +\",j=\" + j); &#125; bShouldSub = true; this.notify(); &#125; public synchronized void SubThread(int i) &#123; if(!bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; for(int j=0;j&lt;10;j++) &#123; System.out.println(Thread.currentThread().getName() + \":i=\" + i +\",j=\" + j); &#125; bShouldSub = false; this.notify(); &#125; &#125;&#125; 备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.huawei.interview.lym;public class ThreadTest &#123; private static boolean bShouldMain = false; public static void main(String[] args) &#123; // TODO Auto-generated method stub /*new Thread()&#123; public void run() &#123; for(int i=0;i&lt;50;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println(\"i=\" + i + \",j=\" + j); &#125; &#125; &#125; &#125;.start();*/ //final String str = new String(\"\"); new Thread( new Runnable() &#123; public void run() &#123; for(int i=0;i&lt;50;i++) &#123; synchronized (ThreadTest.class) &#123; if(bShouldMain) &#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;10;j++) &#123; System.out.println( Thread.currentThread().getName() + \"i=\" + i + \",j=\" + j); &#125; bShouldMain = true; ThreadTest.class.notify(); &#125; &#125; &#125; &#125; ).start(); for(int i=0;i&lt;50;i++) &#123; synchronized (ThreadTest.class) &#123; if(!bShouldMain) &#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;5;j++) &#123; System.out.println( Thread.currentThread().getName() + \"i=\" + i + \",j=\" + j); &#125; bShouldMain = false; ThreadTest.class.notify(); &#125; &#125; &#125;&#125; 下面使用jdk5中的并发库来实现的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.Condition;public class ThreadTest&#123; private static Lock lock = new ReentrantLock(); private static Condition subThreadCondition = lock.newCondition(); private static boolean bBhouldSubThread = false; public static void main(String [] args) &#123; ExecutorService threadPool = Executors.newFixedThreadPool(3); threadPool.execute(new Runnable()&#123; public void run() &#123; for(int i=0;i&lt;50;i++) &#123; lock.lock(); try &#123; if(!bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++) &#123; System.out.println(Thread.currentThread().getName() + \",j=\" + j); &#125; bBhouldSubThread = false; subThreadCondition.signal(); &#125;catch(Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125;); threadPool.shutdown(); for(int i=0;i&lt;50;i++) &#123; lock.lock(); try &#123; if(bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++) &#123; System.out.println(Thread.currentThread().getName() + \",j=\" + j); &#125; bBhouldSubThread = true; subThreadCondition.signal(); &#125;catch(Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 7.21、 JAVA多线程编程。 用JAVA写一个多线程程序，如写四个线程，二个线程对J变量加1，二个线程对J变量减一，输出 注：因为这4个线程共享J，所以线程类要写到内部类中。 加线程：每次对j加一。 减线程：每次对j减一。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TestThreads&#123; private int j=1; //加线程 private class Inc implements Runnable &#123; public void run() &#123; for(int i = 0;i &lt; 10;i++) &#123; inc(); &#125; &#125; &#125; //减线程 private class Dec implements Runnable &#123; public void run() &#123; for(int i = 0;i &lt; 10;i++) &#123; dec(); &#125; &#125; &#125; //加1 private synchronized void inc() &#123; j++; System.out.println(Thread.currentThread().getName()+\"-inc:\"+j); &#125; //减1 private synchronized void dec() &#123; j--; System.out.println(Thread.currentThread().getName()+\"-dec:\"+j); &#125; //测试程序 public static void main(String[] args) &#123; TestThreads test = new TestThreads(); //创建两个线程类 Thread thread = null; Inc inc = test.new Inc(); Dec dec = test.new Dec(); //启动4个线程 for(int i = 0;i &lt; 2;i++) &#123; thread = new Thread(inc); thread.start(); thread = new Thread(dec); thread.start(); &#125; &#125;&#125; 7.22、xml有哪些解析技术?区别是什么? 答:有DOM,SAX,STAX等 DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 STAX:Streaming API for XML (StAX) 讲解这些区别是不需要特别去比较，就像说传智播客与其他培训机构的区别时，我们只需说清楚传智播客有什么特点和优点就行了，这就已经间接回答了彼此的区别。 7.23、 你在项目中用到了xml技术的哪些方面?如何实现的? XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。 XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScriptObjectNotation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。 7.24、用jdom解析xml文件时如何解决中文问题?如何解析?答:看如下代码,用编码方式加以解决 12345678910111213141516171819202122232425262728293031323334353637package test;import java.io.*;public class DOMTest&#123;private String inFile = &quot;c:\\\\people.xml&quot;private String outFile = &quot;c:\\\\people.xml&quot;public static void main(String args[])&#123;new DOMTest();&#125;public DOMTest()&#123;try&#123;javax.xml.parsers.DocumentBuilder builder =javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();org.w3c.dom.Document doc = builder.newDocument();org.w3c.dom.Element root = doc.createElement(&quot;老师&quot;);org.w3c.dom.Element wang = doc.createElement(&quot;王&quot;);org.w3c.dom.Element liu = doc.createElement(&quot;刘&quot;);wang.appendChild(doc.createTextNode(&quot;我是王老师&quot;));root.appendChild(wang);doc.appendChild(root);javax.xml.transform.Transformer transformer =javax.xml.transform.TransformerFactory.newInstance().newTransformer();transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, &quot;gb2312&quot;);transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, &quot;yes&quot;);transformer.transform(new javax.xml.transform.dom.DOMSource(doc),newjavax.xml.transform.stream.StreamResult(outFile));&#125;catch (Exception e)&#123;System.out.println (e.getMessage());&#125;&#125;&#125; 7.25、 编程用JAVA解析XML的方式. 答:用SAX方式解析XML，XML文件如下：1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;person&gt; &lt;name&gt;王小明&lt;/name&gt; &lt;college&gt;信息学院&lt;/college&gt; &lt;telephone&gt;6258113&lt;/telephone&gt; &lt;notes&gt;男,1955年生,博士，95年调入海南大学&lt;/notes&gt;&lt;/person&gt; 事件回调类SAXHandler.java 123456789101112131415161718192021222324252627282930313233import org.xml.sax.*;import java.io.*;import java.util.Hashtable;public class SAXHandler extends HandlerBase &#123; private Hashtable table = new Hashtable(); private String currentElement = null; private String currentValue = null; public void setTable(Hashtable table) &#123; this.table = table; &#125; public Hashtable getTable() &#123; return table; &#125; public void startElement(String tag, AttributeList attrs) throws SAXException &#123; currentElement = tag; &#125; public void characters(char[] ch, int start, int length) throws SAXException &#123; currentValue = new String(ch, start, length); &#125; public void endElement(String name) throws SAXException &#123; if (currentElement.equals(name)) &#123; table.put(currentElement, currentValue); &#125; &#125;&#125; JSP内容显示源码,SaxXml.jsp: 12345678910111213141516171819202122232425262728293031&lt;html&gt; &lt;head&gt; &lt;title&gt;剖析XML文件people.xml&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &amp;lt;%@ page errorPage=ErrPage.jsp contentType=text/html;charset=GB2312 %&amp;gt; &amp;lt;%@ page import=java.io.* %&amp;gt; &amp;lt;%@ page import=java.util.Hashtable %&amp;gt; &amp;lt;%@ page import=org.w3c.dom.* %&amp;gt; &amp;lt;%@ page import=org.xml.sax.* %&amp;gt; &amp;lt;%@ page import=javax.xml.parsers.SAXParserFactory %&amp;gt; &amp;lt;%@ page import=javax.xml.parsers.SAXParser %&amp;gt; &amp;lt;%@ page import=SAXHandler %&amp;gt; &amp;lt;% File file = new File(c:\\people.xml); FileReader reader = new FileReader(file); Parser parser; SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser sp = spf.newSAXParser(); SAXHandler handler = new SAXHandler(); sp.parse(new InputSource(reader), handler); Hashtable hashTable = handler.getTable(); out.println( &lt;table border=\"2\"&gt; &lt;caption&gt; 教师信息表 &lt;/caption&gt;); out.println( &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; + &lt;td&gt; + (String)hashTable.get(new String(name)) + &lt;/td&gt; &lt;/tr&gt;); out.println( &lt;tr&gt; &lt;td&gt;学院&lt;/td&gt; + &lt;td&gt; + (String)hashTable.get(new String(college))+&lt;/td&gt; &lt;/tr&gt;); out.println( &lt;tr&gt; &lt;td&gt;电话&lt;/td&gt; + &lt;td&gt; + (String)hashTable.get(new String(telephone)) + &lt;/td&gt; &lt;/tr&gt;); out.println( &lt;tr&gt; &lt;td&gt;备注&lt;/td&gt; + &lt;td&gt; + (String)hashTable.get(new String(notes)) + &lt;/td&gt; &lt;/tr&gt;); out.println( &lt;/tbody&gt; &lt;/table&gt;); %&amp;gt; &lt;/body&gt;&lt;/html&gt; 7.26、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ a: 两种形式 dtd schema， b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的) c:有DOM,SAX,STAX等 DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问 SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 STAX:Streaming API for XML (StAX) 7.27、Java 的通信编程，编程题(或问答)，用JAVA SOCKET编程，读服务器几个字符，再写入本地显示？Server端程序: 123456789101112131415161718192021222324252627282930313233343536373839404142 package test;import java.io.*;import java.net.*;public class Server &#123; private ServerSocket ss; private Socket socket; private BufferedReader in; private PrintWriter out; public Server() &#123; try &#123; ss = new ServerSocket(10000); while (true) &#123; socket = ss.accept(); String RemoteIP = socket.getInetAddress().getHostAddress(); String RemotePort = \":\" + socket.getLocalPort(); System.out.println(\"A client come in!IP:\" + RemoteIP + RemotePort); in = new BufferedReader(new InputStreamReader( socket.getInputStream())); String line = in.readLine(); System.out.println(\"Cleint send is :\" + line); out = new PrintWriter(socket.getOutputStream(), true); out.println(\"Your Message Received!\"); out.close(); in.close(); socket.close(); &#125; &#125; catch (IOException e) &#123; out.println(\"wrong\"); &#125; &#125; public static void main(String[] args) &#123; new Server(); &#125;&#125; Client端程序: 1234567891011121314151617181920212223242526272829303132333435 package test;import java.io.*;import java.net.*;public class Client &#123; Socket socket; BufferedReader in; PrintWriter out; public Client() &#123; try &#123; System.out.println(\"Try to Connect to 127.0.0.1:10000\"); socket = new Socket(\"127.0.0.1\", 10000); System.out.println(\"The Server Connected!\"); System.out.println(\"Please enter some Character:\"); BufferedReader line = new BufferedReader(new InputStreamReader( System.in)); out = new PrintWriter(socket.getOutputStream(), true); out.println(line.readLine()); in = new BufferedReader(new InputStreamReader( socket.getInputStream())); System.out.println(in.readLine()); out.close(); in.close(); socket.close(); &#125; catch (IOException e) &#123; out.println(\"Wrong\"); &#125; &#125; public static void main(String[] args) &#123; new Client(); &#125;&#125; 7.28.、TCP/IP的7层协议 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 TCP：Transmission Control Protocol传输控制协议 UDP：User Datagram Protocol用户数据报协议 7.29、 简述正则表达式及其用途。 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 7.30、Java中是如何支持正则表达式操作的？ 答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。 7.31、如果要从字符串中截取第一个英文左括号之前的字符串1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = \"北京市(朝阳区)(西城区)(海淀区)\"; Pattern p = Pattern.compile(\".*?(?=\\\\()\"); Matcher m = p.matcher(str); if (m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。 八、JUnit 、SVN 、UML 、Linux##8.1、 什么时候用assertion (断言)。assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。123456789101112131415package com.huawei.interview;public class AssertTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int i = 0; for (i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; //假设程序不小心多了一句--i; --i; assert i == 5; &#125;&#125; ##8.2、 LINUX下线程，GDI类的解释答：LINUX实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。GDI类为图像设备编程接口类库。 ##8.3、 UML方面标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图, 九、虚拟机9.1、 描述一下JVM加载class文件的原理机制?答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 9.2、++在运行和编译上的去区别 源文件–&gt;汇编–&gt;运行 源文件–&gt;编译class(字节码文件)–&gt;汇编–&gt;运行 9.3、 动态指定classpath -cp / -classpath 路径 文件名 9.4、 创建jar包 jar cf hello.jar helloworld.class 9.5、 解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。String str = new String(“hello”);上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。 9.6、 heap和stack有什么区别 栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。 9.7.、GC是什么? 为什么要有GC? 答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的JVM参数： 12345678910-Xms / -Xmx — 堆的初始大小 / 堆的最大大小-Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让System.gc()不产生任何作用-XX:+PrintGCDetails — 打印GC的细节-XX:+PrintGCDateStamps — 打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小-XX:NewRatio — 可以设置老生代和新生代的比例-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 9.8.、垃圾回收器的基本原理和优点？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行。需要指出的是调用System.gc()方法不能保证JVM 立即进行垃圾收集，而只能是建议,因为垃圾收集线程的优先级很低（通常是最低的）。 由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，如果一个对象赋值为null或者重新定向了该对象的引用者，则该对象被认定为变得适用于垃圾收集。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 123456789101112131415161718192021222324252627282930 import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&gt; &#123; private static final int INIT_CAPACITY = 16; private T[] elements; private int size = 0; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if (size == 0) &#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity() &#123; if (elements.length == size) &#123; elements = Arrays.copyOf(elements, (2 * size) + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 9.9、 java中会存在内存泄漏吗，请简单描述。 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。 9.10、 能不能自己写个类，也叫java.lang.String？ 可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。 虽然java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。 （下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题目泄露了）例如，运行下面的程序：1234567package java.lang;public class String &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"string\"); &#125;&#125; 报告的错误如下： 12java.lang.NoSuchMethodError: mainException in thread &quot;main&quot; 这是因为加载了jre自带的java.lang.String，而该类中没有main方法。 十、参考资料 异常处理_百度百科 十一、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/3 - Java web部分","date":"2019-03-12T06:57:57.136Z","updated":"2018-11-29T03:10:55.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/3 - Java web部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/3 - Java web部分/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/2 - Html&JavaScript&ajax部分","date":"2019-03-12T06:57:57.136Z","updated":"2018-11-29T03:09:53.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/2 - Html&JavaScript&ajax部分/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC99 面试 & 笔试/Java面试宝典/2 - Html&JavaScript&ajax部分/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC10 移动端开发/Android/AndroidStudio","date":"2019-03-12T06:57:57.116Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC10 移动端开发/Android/AndroidStudio/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC10 移动端开发/Android/AndroidStudio/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC10 移动端开发/Android/IntelliJ IDEA配置Android开发环境","date":"2019-03-12T06:57:57.116Z","updated":"2018-12-11T05:02:13.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC10 移动端开发/Android/IntelliJ IDEA配置Android开发环境/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC10 移动端开发/Android/IntelliJ IDEA配置Android开发环境/","excerpt":"","text":"[TOC] 一、前言Eclipse需要ADT插件以支持Android开发。而IDEA对Android开发的支持是内置的，不再需要其他插件。当然，Android SDK和JDK还是不可缺少的。 测试环境：Deepin 15.5，IntelliJ IDEA 2014.2.4，Android SDK Tools 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.19 1.0 ZZ 初稿 三、配置过程3.1、前期准备 IntelliJ IDEA 安装完成 JDK 安装配置完成 Gradle 项目构建插件 Android Support 插件安装完成 3.2、下载安装SDK-Tool及SDK 首先第一次创建Android项目是没有SDK的，需要手动配置SDK-Tool和SDK。 选择SDK的安装路径和版本，Show Package Detail 可以查看详细包含插件。 开始下载安装SDK。 安装完成，Finish退出。 3.3、新建 Android 项目 新建项目，选择项目名称和路径 选择构建的应用种类和SDK版本 选择Activity组件模板 命名Activity组件，创建项目（默认Gradle构建） 3.4、配置AVD模拟器 IDEA工具栏选择 Tools - Android - AVD Manager，进入AVD配置，创建新AVD 选择AVD模拟器尺寸、分辨率等参数 选择SDK版本 命名AVD，修改相关参数 Finish完成 3.5、配置运行器，Run - Edit Configuration 该运行器类似于Tomcat作用，支持模拟器和USB真机调试模式 四、注意事项 Module SDK 与 AVD SDK 版本一致。 五、参考资料 [x] Android WiFi ADB - IntelliJ/Android Studio Plugin [x] 手机远程真机调试平台汇总 六、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC10 移动端开发/混合开发模式","date":"2019-03-12T06:57:57.104Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC10 移动端开发/混合开发模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC10 移动端开发/混合开发模式/","excerpt":"","text":"[x] 最火跨平台React Native+weex+Flutter [x] React Native中文网","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC10 移动端开发/Ionic","date":"2019-03-12T06:57:57.104Z","updated":"2019-01-22T03:45:13.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC10 移动端开发/Ionic/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC10 移动端开发/Ionic/","excerpt":"","text":"安装Node.js和NPM12sudo apt-get install nodejssudo apt-get install npm -配置npm国内镜像1npm config set registry http://registry.taobao.org/ 安装最新版本的 cordova 和 ionic 。1npm install -g cordova ionic@3.12.0 更新:1npm update -g cordova ionic 启动Ionic1ionic serve 1ionic info","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/Lapland 个人网站/Lapland开发实录","date":"2019-03-12T06:57:57.092Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/Lapland 个人网站/Lapland开发实录/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/Lapland 个人网站/Lapland开发实录/","excerpt":"","text":"[TOC] 一、前言本文用于记录本个网站的发展历程。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.03.26 1.0 ZZ 初稿 三、本站架构 域名：万网域名 图床：七牛云存储 云服务器：阿里云 代码托管：码云Git CDN加速：阿里云 域名解析：阿里云DNS 四、建站日志4.1、时间轴 2017-03-26:申请 www.lapland.top 万网域名，有效期一年； 2017-03-26:购买腾讯云主机，有效期一个月； 2017-03-26:通过FTP上传第一个简单主页； 2018-01-05:开通七牛云存储，永久免费空间10G； 2018-02-27:购买阿里云主机，有效期一年； 2018-03-26:续费 www.lapland.top 万网域名，有效期九年； 五、网站架构分析六、需求分析6.1、开发模型七、结语 本站摸索建设，需求不明确，采取增量开发模型，先开发出核心模块，后续模块相继完善。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/搭建个人技术博客","date":"2019-03-12T06:57:57.088Z","updated":"2019-03-11T07:34:44.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/搭建个人技术博客/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC09 项目实战 & 日常瞎折腾系列/搭建个人技术博客/","excerpt":"","text":"搜索关键字 django搭建个人博客github搭建个人博客hexo搭建个人博客 Hexo - 官网","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/人脸识别API/人脸识别SDK 汇总","date":"2019-03-12T06:57:57.068Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/人脸识别API/人脸识别SDK 汇总/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/人脸识别API/人脸识别SDK 汇总/","excerpt":"","text":"人脸识别API/SDK 汇总","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/XPath 选择器简易教程","date":"2019-03-12T06:57:57.064Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/XPath 选择器简易教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/XPath 选择器简易教程/","excerpt":"","text":"[TOC] 一、前言为了写爬虫，接触到 XPath 选择器，语法比较简单，谨以此文记录语法规则，便于查询。 XPath 是一门在XML文档中查找信息的语言。 XPath 使用路径表达式在XML文档中进行导航； XPath 包含一个标准函数库； XPath 是XSLT中的主要元素； XPath 是一个 W3C 标准。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.01.31 1.0 ZZ 初稿 三、相关术语3.1、XPath 节点在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。 基本值（Atomic value） 基本值是无父或无子的节点。 父（Parent） 每个元素以及属性都有一个父。 子（Children） 元素节点可有零个、一个或多个子。 同胞（Sibling） 拥有相同的父的节点。 先辈（Ancestor） 某节点的父、父的父，等等。 后代（Descendant） 某个节点的子，子的子，等等。 3.2、XPath 语法XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。 3.21、路径 路径表达式 描述 nodename 相对路径，选取此节点的所有子节点 /bookstore 绝对路径，从根节点选取bookstore //book 选取属于 bookstore 的子元素的所有 book 元素 @lang 选取名为 lang 的所有属性 . 表示当前节点 .. 表示当前节点的父节点 3.21、选取若干路径通过在路径表达式中使用”|”运算符，选取若干个路径。 路径表达式 描述 //title //price 选取文档中的所有 title 和 price 元素。 3.22、谓语谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。 路径表达式 描述 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 3.23、通配符XPath 通配符可用来选取未知的 XML 元素。 路径表达式 描述 /bookstore/* 选取bookstore元素的所有子元素 //* 选取文档中的所有元素 //title[@*] 选取所有带有属性的title元素 3.24、XPath 运算符 路径表达式 描述 计算两个节点集 + 加法 - 减法 * 乘法 div 除法 = 等于 != 不等于 &lt; 小于 &lt;= 小于或等于 &gt; 大于 &gt;= 大于或等于 or 或 and 与 mod 计算除法的余数 四、XML实例 books.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;bookstore&gt; &lt;book category=\"COOKING\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=\"CHILDREN\"&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=\"WEB\"&gt; &lt;title lang=\"en\"&gt;XQuery Kick Start&lt;/title&gt; &lt;author&gt;James McGovern&lt;/author&gt; &lt;author&gt;Per Bothner&lt;/author&gt; &lt;author&gt;Kurt Cagle&lt;/author&gt; &lt;author&gt;James Linn&lt;/author&gt; &lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;49.99&lt;/price&gt; &lt;/book&gt; &lt;book category=\"WEB\"&gt; &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 加载XML文档 所有现代浏览器都支持使用 XMLHttpRequest 来加载 XML 文档的方法。 1var xmlhttp=new XMLHttpRequest() 选取节点 1xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE,null); 选取所有 title 1/bookstore/book/title 选取所有价格 1/bookstore/book/price/text() 七、拓展阅读 CSS选择器简易教程 正则表达式器简易教程 jQuery选择器简易教程 八、参考资料 XPath 教程 Xpath 与Css 定位方式的比较 九、结语毕竟不常用，不必花费太多时间研究，仅供个人参考。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/正则表达式器简易教程","date":"2019-03-12T06:57:57.064Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/正则表达式器简易教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/正则表达式器简易教程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架Crawler4j简介","date":"2019-03-12T06:57:57.064Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架Crawler4j简介/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架Crawler4j简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架WebMagic简介","date":"2019-03-12T06:57:57.064Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架WebMagic简介/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/网络爬虫/Java爬虫框架WebMagic简介/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.01.31 1.0 ZZ 初稿 三、概念解析3.1、占位异常是程序在运行时出现的不正常情况。 四、正文五、正文六、相关术语七、拓展阅读八、参考资料 WebMagic中文文档 九、结语 文章预览请点http://lapland.top/docs/，页面基于[gitbook](https://github.com/GitbookIO/gitbook/)进行构建。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/大数据基础/浅谈ETL","date":"2019-03-12T06:57:57.060Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/大数据基础/浅谈ETL/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/大数据基础/浅谈ETL/","excerpt":"","text":"[TOC] 一、前言ETL是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.16 1.0 ZZ 初稿 三、概念解析3.1、占位八、参考资料 ETL讲解（很详细！！！） 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析","date":"2019-03-12T06:57:57.056Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析/","excerpt":"","text":"[TOC] 一、前言用数据讲故事 关键字：智慧城市，大屏 ，BigScreen ，可视化，指挥调度平台 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.06 1.0 ZZ 初稿 三、应用场景 智慧城市 智能停车场 智慧交通 行业应用 电力行业 交通行业 机房运维可视化 / 建筑 3D仿真 3D设计图纸：更准确描绘设计思路，直观审视设计成果 电子沙盘：3D立体化互动式电子沙盘，创新的园区和建筑展示介绍 互动式导航：动态线路指引，用于园区、大型建筑的3D地图式导航 工业组态软件 电信网络拓扑和设备管理 电力、燃气等工业自动化(HMI/SCADA)领域 四、数据可视化技术栈 五、可视化解决方案厂商分析 [x] 数字冰雹 大屏可视化及BI商业智能领域。3D建模及渲染能力较强，支持数据分析。使用技术3ds max、C# 、WPF。官网有较多解决方案，相关硬件及性能参数，有新浪/CSND博客。完全定制，不支持组件及模板开发。 [x] 威创 显示设备硬件服务商，专注大屏可视化。前端使用WPF框架，服务端使用C#。官网有较多解决方案，相关硬件及性能参数，没有技术方面资料。完全定制，不支持组件及模板开发。 [x] 铂亚信息技术有限公司 官网有较多解决方案。 [x] 双旗科技 显示设备硬件服务商，专注大屏可视化。官网案例和信息较少 [x] 博康智能 官网有很多较详细的解决方案 [x] 海云数据 侧重与数据分析。官网界面写的不错。 [x] 奥威 侧重与数据分析和BI商业智能领域。有大屏可视化应用支持组件化/模板化开发，布局自适应。官网有较多在线Demo，但比较粗糙。 [x] FindBI 侧重与数据分析和BI商业智能领域。支持组件化/模板化开发，布局自适应。官网有较多在线Demo。 [x] 海致BDP 侧重与数据分析和BI商业智能领域。支持组件化/模板化开发，布局自适应。个人免费使用在线版。官网功能产品介绍 - 特点部分可作为参考。 [x] 睿思BI 开源商业智能系统。 [x] 帆软 大屏可视化及BI商业智能领域。支持组件化/模板化开发。官网有较多案例、并有帆软开发论坛。 [x] 阿里云 - DataV 技术比较全面，数据分析，人工智能，云服务（IAAS / PAAS / SAAS）均支持。支持组件化/模板化开发。官网有相关教程、API文档。 [x] 百度云 - Habo 技术比较全面，数据分析，人工智能，云服务（IAAS / PAAS / SAAS）均支持。支持组件化/模板化开发。开放资源比较少。 [x] 腾讯云 - RayData 支持组件化/模板化开发。开放资源比较少。 [x] 万博思图 侧重BI商业智能。支持组件化开发。 [x] 优诺科技 3D仿真/机房运维可视化应用场景能力比较强。有可视化三维模型创建功能，支持CAD底图导入，及模型导出。使用的WebGL框架为three.js 及 Unity3D 引擎技术。官网有相关Demo及教程。 [x] 赛瓦软件TWaver 3D仿真/机房运维可视化领域应用场景能力比较强。使用的 Canvas, WebGL技术。官网有相关Demo、教程、API文档、论坛。 [x] Hightopo 图扑软件 3D仿真/机房运维可视化/工业组态应用场景能力比较强。使用技术不详。官网有相关Demo、教程、API文档、技术博客。 六、大数据交易市场 国云数据 - 魔镜 东湖大数据交易中心 七、大数据采集 军犬采集 八、交互技术案例 途拓 炫影-交互显示平台–让大屏幕动起来! 清投T-Show超高清信息可视化交互系统 更多厂商查看天眼查竞品信息。 九、参考资料 智能停车领域的应用场景及行业痛点 十、后记 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析","date":"2019-03-12T06:57:57.056Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/数据可视化行业分析/","excerpt":"","text":"数据可视化行业分析 /** * prism.js Github theme based on GitHub's theme. * @author Sam Clarke */ code[class*=\"language-\"], pre[class*=\"language-\"] { color: #333; background: none; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; word-wrap: normal; line-height: 1.4; -moz-tab-size: 8; -o-tab-size: 8; tab-size: 8; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } /* Code blocks */ pre[class*=\"language-\"] { padding: .8em; overflow: auto; /* border: 1px solid #ddd; */ border-radius: 3px; /* background: #fff; */ background: #f5f5f5; } /* Inline code */ :not(pre) > code[class*=\"language-\"] { padding: .1em; border-radius: .3em; white-space: normal; background: #f5f5f5; } .token.comment, .token.blockquote { color: #969896; } .token.cdata { color: #183691; } .token.doctype, .token.punctuation, .token.variable, .token.macro.property { color: #333; } .token.operator, .token.important, .token.keyword, .token.rule, .token.builtin { color: #a71d5d; } .token.string, .token.url, .token.regex, .token.attr-value { color: #183691; } .token.property, .token.number, .token.boolean, .token.entity, .token.atrule, .token.constant, .token.symbol, .token.command, .token.code { color: #0086b3; } .token.tag, .token.selector, .token.prolog { color: #63a35c; } .token.function, .token.namespace, .token.pseudo-element, .token.class, .token.class-name, .token.pseudo-class, .token.id, .token.url-reference .token.variable, .token.attr-name { color: #795da3; } .token.entity { cursor: help; } .token.title, .token.title .token.punctuation { font-weight: bold; color: #1d3e81; } .token.list { color: #ed6a43; } .token.inserted { background-color: #eaffea; color: #55a532; } .token.deleted { background-color: #ffecec; color: #bd2c00; } .token.bold { font-weight: bold; } .token.italic { font-style: italic; } /* JSON */ .language-json .token.property { color: #183691; } .language-markup .token.tag .token.punctuation { color: #333; } /* CSS */ code.language-css, .language-css .token.function { color: #0086b3; } /* YAML */ .language-yaml .token.atrule { color: #63a35c; } code.language-yaml { color: #183691; } /* Ruby */ .language-ruby .token.function { color: #333; } /* Markdown */ .language-markdown .token.url { color: #795da3; } /* Makefile */ .language-makefile .token.symbol { color: #795da3; } .language-makefile .token.variable { color: #183691; } .language-makefile .token.builtin { color: #0086b3; } /* Bash */ .language-bash .token.keyword { color: #0086b3; }html body{font-family:\"Helvetica Neue\",Helvetica,\"Segoe UI\",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:\"\\00a0\"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for=\"preview\"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for=\"preview\"]) .code-chunk .status{display:none}.markdown-preview:not([for=\"preview\"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for=\"html-export\"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for=\"html-export\"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=\"html-export\"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=\"html-export\"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=\"html-export\"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none} /* Please visit the URL below for more information: */ /* https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */ 一、前言 二、版本 三、应用场景 四、数据可视化技术栈 五、可视化解决方案厂商分析 六、大数据交易市场 七、大数据采集 八、交互技术案例 九、参考资料 十、后记 一、前言 用数据讲故事 关键字：智慧城市，大屏 ，BigScreen ，可视化，指挥调度平台 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.06 1.0 ZZ 初稿 三、应用场景 智慧城市 智能停车场 智慧交通 行业应用 电力行业 交通行业 机房运维可视化 / 建筑 3D仿真 3D设计图纸：更准确描绘设计思路，直观审视设计成果 电子沙盘：3D立体化互动式电子沙盘，创新的园区和建筑展示介绍 互动式导航：动态线路指引，用于园区、大型建筑的3D地图式导航 工业组态软件 电信网络拓扑和设备管理 电力、燃气等工业自动化(HMI/SCADA)领域 四、数据可视化技术栈 五、可视化解决方案厂商分析 数字冰雹 大屏可视化及BI商业智能领域。3D建模及渲染能力较强，支持数据分析。 使用技术3ds max、C# 、WPF。 官网有较多解决方案，相关硬件及性能参数，有新浪/CSND博客。 完全定制，不支持组件及模板开发。 威创 显示设备硬件服务商，专注大屏可视化。 前端使用WPF框架，服务端使用C#。 官网有较多解决方案，相关硬件及性能参数，没有技术方面资料。 完全定制，不支持组件及模板开发。 铂亚信息技术有限公司 官网有较多解决方案。 双旗科技 显示设备硬件服务商，专注大屏可视化。 官网案例和信息较少 博康智能 官网有很多较详细的解决方案 海云数据 侧重与数据分析。 官网界面写的不错。 奥威 侧重与数据分析和BI商业智能领域。有大屏可视化应用 支持组件化/模板化开发，布局自适应。 官网有较多在线Demo，但比较粗糙。 FindBI 侧重与数据分析和BI商业智能领域。 支持组件化/模板化开发，布局自适应。 官网有较多在线Demo。 海致BDP 侧重与数据分析和BI商业智能领域。 支持组件化/模板化开发，布局自适应。 个人免费使用在线版。官网功能产品介绍 - 特点部分可作为参考。 睿思BI 开源商业智能系统。 帆软 大屏可视化及BI商业智能领域。 支持组件化/模板化开发。 官网有较多案例、并有帆软开发论坛。 阿里云 - DataV 技术比较全面，数据分析，人工智能，云服务（IAAS / PAAS / SAAS）均支持。 支持组件化/模板化开发。 官网有相关教程、API文档。 百度云 - Habo 技术比较全面，数据分析，人工智能，云服务（IAAS / PAAS / SAAS）均支持。 支持组件化/模板化开发。 开放资源比较少。 腾讯云 - RayData 支持组件化/模板化开发。 开放资源比较少。 万博思图 侧重BI商业智能。 支持组件化开发。 优诺科技 3D仿真/机房运维可视化应用场景能力比较强。 有可视化三维模型创建功能，支持CAD底图导入，及模型导出。 使用的WebGL框架为three.js 及 Unity3D 引擎技术。 官网有相关Demo及教程。 赛瓦软件TWaver 3D仿真/机房运维可视化领域应用场景能力比较强。 使用的 Canvas, WebGL技术。 官网有相关Demo、教程、API文档、论坛。 Hightopo 图扑软件 3D仿真/机房运维可视化/工业组态应用场景能力比较强。 使用技术不详。 官网有相关Demo、教程、API文档、技术博客。 六、大数据交易市场 国云数据 - 魔镜 东湖大数据交易中心 七、大数据采集 军犬采集 八、交互技术案例 途拓 炫影-交互显示平台--让大屏幕动起来! 清投T-Show超高清信息可视化交互系统 更多厂商查看天眼查竞品信息。 九、参考资料 智能停车领域的应用场景及行业痛点 十、后记 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/电力项目中大数据技术的典型应用","date":"2019-03-12T06:57:57.040Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/电力项目中大数据技术的典型应用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/应用场景/电力项目中大数据技术的典型应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Three.js初探","date":"2019-03-12T06:57:57.036Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Three.js初探/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Three.js初探/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/地理信息/地理信息GIS","date":"2019-03-12T06:57:57.036Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/地理信息/地理信息GIS/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/地理信息/地理信息GIS/","excerpt":"","text":"百度离线地图API V2.1 内含示例Demo，亲测可用 基于JavaScript的三维地图程序（仿e都市gis）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Web HTML5 3D机房尝试","date":"2019-03-12T06:57:57.032Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Web HTML5 3D机房尝试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/Web HTML5 3D机房尝试/","excerpt":"","text":"[x] html5 3d机房开源 [x] Three.js呈现3D效果机房–初步方案 [x] 无插件纯Web HTML5 3D机房 终结篇（新增资产管理、动环监控等内容） 从3dMax导出供threeJS使用的带动作模型与加载（认真修改详尽版） SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？ SVG 教程 SVG to Canvas Converter SVG在线编辑器","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/几种Web3D技术比较(HTML5 canvas(Echart)、SVG、webGL)","date":"2019-03-12T06:57:57.032Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/几种Web3D技术比较(HTML5 canvas(Echart)、SVG、webGL)/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/WebGL编程/几种Web3D技术比较(HTML5 canvas(Echart)、SVG、webGL)/","excerpt":"","text":"Canvas HT for Web 百度百科 - WebGL Three.js 中文教程 Echarts &amp; HighChart.js &amp; Three.js &amp; D3.js 测试浏览器是否只支持WebGL","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/海康威视网络摄像机 SDK二次开发（JavaWeb）","date":"2019-03-12T06:57:57.032Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/海康威视网络摄像机 SDK二次开发（JavaWeb）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/海康威视网络摄像机 SDK二次开发（JavaWeb）/","excerpt":"","text":"[TOC] 一、前言最近公司的项目需要集成多路监控摄像头，要求我们在web端实现一些功能： 不小于四路实时监控 高清影像保存不小于一个月 支持视频回放 灵活调用 现利用海康SDK+OpenCV，不通过NVR（网络硬盘录像机）/DVR（数字视频录像机）管理。介绍其开发过程。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.10 1.0 ZZ 初稿 八、参考资料 [x] java调用dll动态库文件的一般总结 [x] 码云-海康威视SDK GitHub-海康威视SDK九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控系统 & 视频直播系统开发基础","date":"2019-03-12T06:57:57.028Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控系统 & 视频直播系统开发基础/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控系统 & 视频直播系统开发基础/","excerpt":"","text":"二、相关概念NVR（网络视频录像机）是模拟录像机和硬盘录像机的理想升级换代产品，是在原来DVR基础上实现的免除视窗操作系统和电脑配合的单机独立操作设备。 DVR（数字硬盘录像机）是近几年继模拟录像系统之后迅速发展的第二代监控系统。采用微机和Windows平台，在计算机中安装视频压缩卡和相应的DVR软件，不同型号视频卡可连接1/2/4路视频，支持实时视频和音频，是第一代模拟监控系统升级实现数字化的可选方案。 流媒体指以流方式在网络中传送音频、视频和多媒体文件的媒体形式。流媒体服务器的主要功能是以流式协议（RTP/RTSP、MMS、RTMP等）将视频文件传输到客户端，供用户在线观看；也可从视频采集、压缩软件接收实时视频流，再以流式协议直播给客户端。 三、设计方案概要3.1、获取直播显示视频的几种方式一般情况下，显示视频是通过电脑或是解码来来完成。 如果访问的地址是IPC的地址，就是直接从IPC取的数据流。如果访问的地址是流媒体服务器，就是直接通过流媒体来转发的。如果通过SDK访问的地址是NVR，就是直接通过NVR转发的。 3.2、存储方案IPC本地可以存（插存储卡），如萤石云。小规模方案（100路以下）前端嵌入式NVR内置硬盘可以存；大规模方案（100路以上）后端CVR存储平台本地硬盘或者存储管理服务器本地硬盘可以存；大规模方案后端存储服务器可以挂载IPSAN、NAS、FCSAN、私有云存储； 九、参考资料-[x]流媒体、直写、全交换三种架构方案比较-[x]使用海康摄像头实现实时监控-[x]海康sdk集成javaweb项目 解码器的原理和作用 监控视频编码器和解码器接在什么位置? 解码器在视频监控中是必须的吗 DAS\\NAS\\IP SAN\\FC SAN之区别 实时监控、直播流、流媒体、视频网站开发方案设计简要","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控录像容量计算","date":"2019-03-12T06:57:57.028Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控录像容量计算/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/监控录像容量计算/","excerpt":"","text":"[TOC] 一、前言公司项目需求，需要保存4路高清监控素材1个月，这里就要计算需要多大容量的硬盘。计算方法如下所示。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.09 1.0 ZZ 初稿 三、相关概念720P = 1280×720（高清，921600像素，百万像素分辨率，码流为4M，码率为4*1024=4096Kbps）1080p = 1920×1080（全高清，2073600像素，200万像素分辨率，码流为8M）4K = 3840×2160（码流为10M)8K = 7680x4320 八、计算方法监控产生的录像容量，和如下几个参数有关系： 1、摄像头清晰度。 2、摄像头数目。 3、录像配置码率。 4、其他。 公式： 录像容量（天）（G） = 码率（Kbps）×3600×24÷8÷1024÷1024 根据公式计算得出 A = 4096 0.0103 30（天） 4（路）= 42G 30 *4= 5040G 八、参考资料 [x] 监控录像能保存多久计算方法 [x] 网络监控安装 一个交换机能带几台摄像头？ 九、结语 计算的出，4路监控要存储720P的高清素材需要硬盘容量大于5T。实际上现在的监控摄像头都带有动态捕捉功能，只有动态的画面才会别储存。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/搭建流媒体服务器","date":"2019-03-12T06:57:57.028Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/搭建流媒体服务器/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/搭建流媒体服务器/","excerpt":"","text":"绝对独创—关于直播(推流-拉流-服务器搭建)","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/Web页面视频最大开窗数测试","date":"2019-03-12T06:57:57.024Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/Web页面视频最大开窗数测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/视频直播技术/Web页面视频最大开窗数测试/","excerpt":"","text":"[TOC] 一、前言数据可视化项目经常会有视频开窗的需求。下面就Html视频开窗各种情况进行测试，得出最大开窗数。测试环境：Deepin 15.5 发行版。处理器 i7-7500U,内存8G。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.02 1.0 ZZ 初稿 三、测试源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0\" /&gt; &lt;/head&gt; &lt;body style=\"width:100%\"&gt; &lt;!-- autoplay loop--&gt; &lt;!--打开本地摄像头测试--&gt; &lt;div style=\"width: 100%;float: left;\"&gt; &lt;h3&gt;本地摄像头测试&lt;/h3&gt; &lt;div style=\"width: 300px;height:200px;float: left;\"&gt; &lt;input type=\"button\" title=\"开启摄像头\" value=\"开启摄像头\" onclick=\"getMedia();\" style=\"display: block;\" /&gt; &lt;video height=\"120px\" autoplay=\"autoplay\" style=\"display: block;\"&gt;&lt;/video&gt; &lt;/div&gt; &lt;div style=\"width: 300px;height:200px;float: left;\"&gt; &lt;input type=\"button\" title=\"拍照\" value=\"拍照\" onclick=\"getPhoto();\" style=\"display: block;\"/&gt; &lt;canvas id=\"canvas1\" height=\"120px\" style=\"display: block;\" &gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div style=\"width: 300px;height:200px;float: left;\"&gt; &lt;input type=\"button\" title=\"视频\" value=\"视频\" onclick=\"getVedio();\" style=\"display: block;\"/&gt; &lt;canvas id=\"canvas2\" height=\"120px\" style=\"display: block;\" &gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;hr/&gt; &lt;!--打开本地视频测试--&gt; &lt;div style=\"width:100%;float: left;\"&gt; &lt;h3&gt;本地视频 1-5&lt;/h3&gt; &lt;ul style=\"width:1100px;height:100px\"&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;本地视频 6-10&lt;/h3&gt; &lt;ul style=\"width:1100px;height:100px\"&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt;&lt;video width=\"200px\" height=\"100px\" controls&gt;&lt;source src=\"static/test.mp4\"&gt;&lt;/video&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--远程摄像头测试--&gt; &lt;div style=\"width:100%;float: left;\"&gt; &lt;h3&gt;七牛云远程视频&lt;/h3&gt; &lt;ul style=\"width:1100px;height:100px\"&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video width=\"200px\" height=\"100px\" controls&gt; &lt;source src=\"http://p22kg92am.bkt.clouddn.com/test.mp4\"&gt; &lt;/video&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;萤石云摄像头&lt;/h3&gt; &lt;ul style=\"width:1100px;height:100px\"&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video id=\"player1\" poster=\"\" width=\"200px\" height=\"100px\" autoplay&gt; &lt;source src=\"rtmp://rtmp.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963\" type=\"rtmp/flv\"/&gt; &lt;source src=\"http://hls.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963.hd.m3u8\" type=\"application/x-mpegURL\"/&gt; &lt;/video&gt; &lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video id=\"player2\" poster=\"\" width=\"200px\" height=\"100px\" autoplay&gt; &lt;source src=\"rtmp://rtmp.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963\" type=\"rtmp/flv\"/&gt; &lt;source src=\"http://hls.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963.hd.m3u8\" type=\"application/x-mpegURL\"/&gt; &lt;/video&gt; &lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video id=\"player3\" poster=\"\" width=\"200px\" height=\"100px\" autoplay&gt; &lt;source src=\"rtmp://rtmp.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963\" type=\"rtmp/flv\"/&gt; &lt;source src=\"http://hls.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963.hd.m3u8\" type=\"application/x-mpegURL\"/&gt; &lt;/video&gt; &lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video id=\"player4\" poster=\"\" width=\"200px\" height=\"100px\" autoplay&gt; &lt;source src=\"rtmp://rtmp.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963\" type=\"rtmp/flv\"/&gt; &lt;source src=\"http://hls.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963.hd.m3u8\" type=\"application/x-mpegURL\"/&gt; &lt;/video&gt; &lt;/li&gt; &lt;li style=\"display:block;float:left;margin-right:10px\"&gt; &lt;video id=\"player5\" poster=\"\" width=\"200px\" height=\"100px\" autoplay&gt; &lt;source src=\"rtmp://rtmp.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963\" type=\"rtmp/flv\"/&gt; &lt;source src=\"http://hls.open.ys7.com/openlive/f645152d3d5448caa1c5515d2ff05963.hd.m3u8\" type=\"application/x-mpegURL\"/&gt; &lt;/video&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;hr/&gt; &lt;/body&gt; &lt;script src=\"static/ipcamera.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"https://open.ys7.com/sdk/js/1.3/ezuikit.js\"&gt;&lt;/script&gt; &lt;script&gt; var player1 = new EZUIPlayer('player1'); var player2 = new EZUIPlayer('player2'); var player3 = new EZUIPlayer('player3'); var player4 = new EZUIPlayer('player4'); var player5 = new EZUIPlayer('player5'); &lt;/script&gt;&lt;/html&gt; 远程监控部分直接用萤石云推送服务，未自己搭流媒体服务器。根据萤石云API介绍,页面需要放在Web服务器下打开，免费版本可开三个终端窗口。本地/远程视频可同时开11路，CPU跑满，内存60%左右。 三、参考资料 [x] 百度百科 - 流媒体服务器 [x] web无插件播放RTSP摄像机方案，拒绝插件，拥抱H5！ [x] 采集rtsp流摄像头到浏览器实时播放方案 [x] 萤石云API文档 七牛直播云 - API 四、结语如有需求，可以用nginx做流媒体服务器，用ffmpeg上传视频，再用vlc/html做客户端播放，再来补充完善自己搭建流媒体服务器部分。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/数据可视化的设计原则","date":"2019-03-12T06:57:57.004Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/数据可视化的设计原则/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC08 人工智能 & 数据挖掘与分析 & loT/数据可视化/数据可视化的设计原则/","excerpt":"","text":"[x] 遇见大数据可视化：可视化系统搭建 [x] 最新最全移动端界面设计UI尺寸规范-2018年初版 [x] 关于优秀UI设计的7条准则 [x] 大屏ui设计系列之五——大屏设计语言分析 大屏数据可视化设计方法论 [x] 4步教你玩转可视化大屏设计｜内附实际操作 [x] 大屏做成这样，领导不重视你都难！ [x] 3个技巧搞定可视化信息图的色彩搭配 [x] 大数据数据可视化的设计原则 [x] 数据信息可视化界面设计总结","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/破解/利用rarcrack破解压缩包","date":"2019-03-12T06:57:57.000Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/破解/利用rarcrack破解压缩包/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/破解/利用rarcrack破解压缩包/","excerpt":"","text":"[TOC] 一、前言 rarcrack是linux系统端的一款破解加密压缩包的工具，rarcrack使用的穷举法进行破解已经加密的rar、zip和7z压缩包，支持设置多线程，和文件类型进行破解。该软件开源免费，以GPL-2发布。 本文介绍rarcrack的安装使用，并部署在云服务器上在线破解。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.11 1.0 ZZ 初稿 三、安装和使用官网下载页面：http://rarcrack.sourceforge.net/ 3.1、安装123# tar -xjf rarcrack-0.2.tar.bz2# cd rarcrack-0.2# make &amp;&amp; make install 3.2、使用12// rarcrack 包名（含后缀） --threads 线程数 --type 类型# rarcrack test.rar --threads 10 --type rar 3.31、记录 执行命令rarcrack后，工具会自动在当前目录中生成一个xml文件，如test.rar.xml，里面记录着当前进度，破解成功会显示密码，方便进行查看。 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;rarcrack&gt; &lt;abc&gt;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/abc&gt; &lt;current&gt;abc&lt;/current&gt; &lt;good_password/&gt;&lt;/rarcrack&gt; 3.3、云端运行 当我们在终端中执行了这个工具时，如果关闭终端工具也会同时跟着关闭，如果想让它在后台自动运行呢？ linux命令后台运行的两种方式： command &amp; ：后台运行，关闭终端会停止运行 nohup command &amp; ：后台运行，关闭终端也会继续运行 jobs：执行后台运行后进行查看命令： 12// 示例# nohup rarcrack test.rar --threads 10 --type rar &amp; 四、安装过程遇到的问题 致命错误： libxml/xmlmemory.h：没有那个文件或目录，解决方案：123# yum install libxml2-devel libxslt-devel //centos系或# sudo apt-get install libxml2-dev libxslt-dev //debian系 五、参考资料 linux rarcrack破解rar、zip和7z压缩包简单密码的工具 六、结语 本文记录了在云端跑暴力破解过程，纯粹作为备忘。参考诸多资料，且并不打算拓展，故不声明版权。仅因为思路清奇，故记录下来。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/破解/编程常用工具破解方案汇总","date":"2019-03-12T06:57:57.000Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/破解/编程常用工具破解方案汇总/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/破解/编程常用工具破解方案汇总/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.08 1.0 ZZ 初稿 三、InterliJ IDEA IDEA 2017 注册激活可用license server 3.1、IDEA插件3.11、Markdown NavigatorMarkdown 编辑器 GitHub 3.12、Jrebel热部署插件 link 四、Sublime text 3 link 五、GitKrakenGit图形化工具，Deepin下免费。 link 六、亿图图示6.1、EdrawSoft Edraw Max v7.4 For Windows 激活 : 输入用户名 , 激活码 12345678[UserInfo]GID=EncLicenseName=www.dayanzai.meProductKey=0801-6680-9224-2000-5520Key=C811ED07DD7B9ADF6CB1788E5E20C32AE5D197F25665872BD1D0C89EBC81B8E3451178DABAD2D8A5C7262BE32DE706CBDA771C0757EEC5FC8D326C07259371134B01Pass=5557-1230-ABCBLicenseCount=1State=VC600036 6.2、EdrawSoft Edraw Max v8.7 For Linux 断网 打开Edraw –&gt; 免费Edraw Viewer –&gt; 帮助 –&gt; 激活 : 输入用户名 , 激活码 (点击激活–&gt;提示失败–&gt;提示手动激活–&gt;输入激活码), 手动激活 激活后可用完整版 123Lincense Name : Shadow MaskLincense Code : EFPHSN05QZYHK6CSV6G7Activation Code : 38F4827087C5E7F04C14EB092FECDFD753122CDECBD283F750EA526C2BA74425C5C787E621E7271B179D6BA21795CCFED99365BCCD4931A31945451E74F8D05B3D3E517D7FCDE8F6EB6498BC879CCF230B1710A7955726950A409F18239FAF377701BAAB04929EE30B5986F987FB0C36997A120BAA83402D55DCDCB34D455C50 五、AutoCAD 2010七、拓展阅读八、参考资料 百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/静态路由","date":"2019-03-12T06:57:56.996Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/静态路由/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/静态路由/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/内网穿透的方法论","date":"2019-03-12T06:57:56.996Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/内网穿透的方法论/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/内网穿透的方法论/","excerpt":"","text":"一、花生壳内网穿透1.1、部署步骤： 0、注册域名 www.yshow.top； 1、花生壳注册内网穿透服务； 2、花生壳解析域名，绑定内网IP：192.168.2.251/ 端口：8888（内网开放8888端口）； 3、内网服务器安装花生壳内网穿透版服务端，设置服务自启动； 4、内网服务器复制两份Tomcat，分别是[apache-tomcat-7.0.70-测试]和[apache-tomcat-7.0.70-发布]，发布版修改端口号8888，8006，8010，并设置开机自启动； 5、OVER。 二、FRP内网穿透 FRP内网穿透工具 [x] frp内网穿透搭建,超级简单实用 [x] 搭建frp实现树莓派内网穿透 三、ngrok内网穿透 重点推荐 一分钟实现内网穿透（ngrok服务器搭建） 四、lanproxy内网穿透业余草推荐一款局域网（内网）穿透工具lanproxy 五、路由器内网穿透 [x] P2P内网穿透原理 [x] 网络空间安全若干重大问题辨析（下）：深网、暗网系统等","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/Cisco Packet Tracer模拟器使用教程","date":"2019-03-12T06:57:56.996Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/Cisco Packet Tracer模拟器使用教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/Cisco Packet Tracer模拟器使用教程/","excerpt":"","text":"Deepin - GNS3","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/HTTP协议","date":"2019-03-12T06:57:56.992Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/HTTP协议/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/HTTP协议/","excerpt":"","text":"HTTP 教程","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/[未发布]网络基础","date":"2019-03-12T06:57:56.984Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/[未发布]网络基础/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/[未发布]网络基础/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 三、概念解析3.1、网络协议3.11 TCP/IP协议 TCP/IP是以IP和TCP协议为核心的一整套网络协议的总称，也称为TCP/IP协议簇。TCP/IP支撑着整个互联网，因为它就是互联网采用的网络协议。TCP/IP协议簇划分为4个层次（应用层、传输层、网络层和链路层），构成整个协议簇的各个子协议处于相应层次中。 3.111、HTTP协议 HTTP（Hypertext Transfer Protocol），全称为“超文本转移协议”，是TCP/IP协议簇的一部分。这是一个位于应用层的网络协议，在它之下的就是TCP协议。由于TCP协议是一个“可靠”的协议，HTTP自然也能提供可靠数据传输功能。 OSI参考模型和TCP/IP网络模型 3.1112、HTTP报文3.11 通信流程 IP协议利用IP地址来定位数据报发送的目的地，而利用域名系统（DNS）可以实现域名与IP地址之间的转换。TCP协议利用端口号标识应用程序，所以某个应用程序在使用TCP协议进行通信的时候必须指定目标应用的IP地址（或者域名）和端口号。HTTP默认采用的端口号为80，而HTTPS（利用TLS/SSL为HTTP提供传输安全保障）的默认端口号则为443，当然在网络可达的前提下，我们可以指定任意的端口。 3.12、URI、URL和URN URI的全称为“统一资源标志符（Uniform Resource Identifier）”。URI是Web资源的标志符，所以只要求它具有标识性即可； URL的全称为“统一资源定位符（Uniform Resource Locator）”，所以除了标识性之外，它还具有定位的功能，用于描述Web资源所在的位置。URL不仅仅用于定位目标资源所在的位置，还指名了获取资源所采用的协议，一个完整的URL包含协议名称、主机名称（IP地址或者域名）、端口号、路径和查询字符串5个部分； 一个URL肯定是一个URI，但是一个URI并不一定是一个URL，URL仅仅是URI的一种表现形式而已。除了URL，URN也是URI的一种表现形式。 URN的全称“统一资源名称（Uniform Resource Name）”。URN与资源所在的位置无关。 3.13、带宽的计算方法带宽包括上行速率（upload）和下行速率（download），上行指客户发送信息，下行指客户接收信息。速率常用统计单位是比特/秒（bps），1Mbps=1024kbps，1kbps=1024bps。1Byte=8bits（1字节为8比特） 视频直播网站所需带宽计算？ 网络带宽计算公式 3.2、占位七、拓展阅读八、参考资料 HTTP_百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/抓包","date":"2019-03-12T06:57:56.980Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/抓包/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/抓包/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/TCP-IP协议","date":"2019-03-12T06:57:56.980Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/TCP-IP协议/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/TCP-IP协议/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/web端口说明","date":"2019-03-12T06:57:56.976Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/web端口说明/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/web端口说明/","excerpt":"","text":"端口：21 服务：FTP 说明：FTP服务器所开放的端口，用于上传、下载。 端口：22 服务：SSH 说明：22端口就是ssh端口，用于通过命令行模式远程连接Linux系统服务器。 端口：25 服务：SMTP 说明：SMTP服务器所开放的端口，用于发送邮件。 端口：80 服务：HTTP 说明：用于网站服务例如IIS、Apache、Nginx等提供对外访问。 端口：110 服务：POP3 说明：110端口是为POP3（邮件协议3）服务开放的。 端口：137、138、139 服务：NETBIOS协议 说明：其中137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口：通过这个端口进入的连接试图获得NetBIOS/SMB服务。这个协议被用于windows文件和打印机共享和SAMBA。 端口：143 服务：IMAP 说明：143端口主要是用于“Internet Message AccessProtocol”v2（Internet消息访问协议，简称IMAP），和POP3一样，是用于电子邮件的接收的协议。 端口：443 服务：Https 说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 端口：1433 服务：SQL Server 说明：1433端口，是SQL Server默认的端口，SQL Server服务使用两个端口：TCP-1433、UDP-1434。其中1433用于供SQL Server对外提供服务，1434用于向请求者返回SQL Server使用了哪个TCP/IP端口。 端口：3306 服务：Mysql 说明：3306端口，是Mysql数据库的默认端口，用于Mysql对外提供服务。 端口：3389 服务：Windows Server Remote Desktop Services（远程桌面服务） 说明：3389端口是Windows 2000(2003) Server远程桌面的服务端口，可以通过这个端口，用”远程桌面”等连接工具来连接到远程的服务器 端口：8080 服务：代理端口 说明：8080端口同80端口，是被用于WWW代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器的时候，会加上“:8080”端口号。另外Apache Tomcat web server安装后，默认的服务端口就是8080。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/正向代理和反向代理","date":"2019-03-12T06:57:56.972Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/正向代理和反向代理/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/网络基础/正向代理和反向代理/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 三、概念解析3.1、网络协议nginx缓存和此cdn原理一样 3.2、占位异常是程序在运行时出现的不正常情况。 Java异常类层次结构图 Java异常类层次结构图 Java异常类层次结构图 Java异常类层次结构图 Java异常类层次结构图 七、拓展阅读八、参考资料 反向代理为何叫反向代理？ 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/使用Maltego进行互联网情报收集","date":"2019-03-12T06:57:56.972Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/使用Maltego进行互联网情报收集/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/使用Maltego进行互联网情报收集/","excerpt":"","text":"[TOC] 一、前言Maltego是一款十分适合渗透测试人员和取证分析人员的优秀工具，其主要功能是开源情报收集和取证。 Maltego使用导图","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/记一次渗透测试","date":"2019-03-12T06:57:56.968Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/记一次渗透测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/记一次渗透测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Shodan & zoomeye 搜索引擎","date":"2019-03-12T06:57:56.968Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Shodan & zoomeye 搜索引擎/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Shodan & zoomeye 搜索引擎/","excerpt":"","text":"基于物联网的搜索引擎。 Shodan官网 Zoome官网 百度百科 - Shodan 百度百科 - Zoome","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/Web安全/web开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）","date":"2019-03-12T06:57:56.964Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/Web安全/web开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/Web安全/web开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.11.27 1.0 ZZ 初稿 三、概念解析3.1、占位六、相关术语七、拓展阅读八、参考资料 web开发常见安全问题（SQL注入、XSS攻击、CSRF攻击） 九、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali Linux渗透测试","date":"2019-03-12T06:57:56.964Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali Linux渗透测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali Linux渗透测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali密码攻击工具","date":"2019-03-12T06:57:56.964Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali密码攻击工具/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/渗透测试/Kali密码攻击工具/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC07 网络技术 & Web安全/常用网络命令","date":"2019-03-12T06:57:56.956Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/常用网络命令/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC07 网络技术 & Web安全/常用网络命令/","excerpt":"","text":"mstsc 131.1.3.100 Windowns 远程命令 telnet 131.1.3.100 8888 测试端口是否可用 curl 1.1.1.2:8880 Http请求 wget Linux下载 ps -ef | grep mysql 查看mysql进程 rpm -qa | grep mysql 查看mysql进程","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Intellij IDEA集成JProfiler性能分析神器","date":"2019-03-12T06:57:56.940Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Intellij IDEA集成JProfiler性能分析神器/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Intellij IDEA集成JProfiler性能分析神器/","excerpt":"","text":"Intellij IDEA集成JProfiler性能分析神器","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/浅谈Web缓存技术","date":"2019-03-12T06:57:56.936Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/浅谈Web缓存技术/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/浅谈Web缓存技术/","excerpt":"","text":"[TOC] 一、前言广义来说，凡是位于速度相差较大的两种硬件/服务之间的，用于协调两者数据传输速度差异的结构或者服务，均可称之为 缓存Cache。缓存复制了频繁使用的数据以利于快速访问，属于典型的用空间换时间的方法。 一个优秀的缓存策略可以缩短网页请求资源的路径，减少延迟。并且由于缓存文件可以重复利用，还可以减少带宽消耗，降低服务器压力。 Web缓存分为浏览器缓存、CDN、Web（反向代理）服务器缓存、数据库缓存等。 关键字：CDN，静态资源缓存控制。后端缓存技术（Redis,Memcache，EhCache） 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.05.21 1.0 ZZ 初稿 三、缓存的类型3.1、浏览器(私有)缓存对于css/js/image等静态资源文件。更新的频率都比较低，而这些文件又几乎每次HTTP请求都需要，如果将这些文件缓存在浏览器中，可以很好的改善网站的性能。 通过设置HTTP头中meta标签设置Cache-Control和Expire的属性，可设定浏览器缓存，缓存的时间可以是数天，甚至是几个月。但是使用meta标签优先级低于http请求中声明的。要控制浏览器的行为，应该在服务端的cache-control里配置，不能脱离服务端的cache-control讨论浏览器的缓存机制。 123&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\" /&gt; &lt;!-- HTTP1.1 在1.1中优先于expires--&gt;&lt;meta http-equiv=\"pragma\" content=\"no-cache\" /&gt; &lt;!-- HTTP1.0 --&gt;&lt;meta http-equiv=\"Expires\" content=\"0\" /&gt; &lt;!-- 示意到期时间 HTTP1.0 &amp; 1.1 --&gt; 上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是 HTTP头信息 来控制缓存。 3.11、HTTP缓存机制 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器； 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源； 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。 3.111、本地缓存阶段3.1111、Cache-ControlCache-Control 标头是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的标头例如 Expires。所有现代浏览器都支持 Cache-Control。 max-age 指从请求的时间开始，允许缓存有效的最长时间(单位是s)。 public 可被任何对象缓存。它不是必须的，因为明确的缓存信息已表示响应是可以缓存的。 private 通常只为单个用户缓存，不允许任何中间缓存对其进行缓存。 no-cache 表示必须先与服务器确认返回的响应是否发生了变化。 no-store 禁止浏览器以及所有中间缓存存储任何版本的返回响应，每次请求必须重新下载。 3.1112、Expires它代表一个缓存过期的绝对时间，在HTTP/1.0中实现，在HTTP/1.1中优先级低于Cache-Control。 3.112、协商缓存阶段3.1121、Last-Modified / If-Modified-Since Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。 Last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。 If-Modified-Since：当资源过期时，发现资源具有Last-Modified声明，则向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。 3.1122、Etag / If-None-Match ETag与If-None-Match是一对报文，属于http 1.1。 ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。只要这个文件发生了改变，这个标志就会发生变化。 同时使用这两个报文头，在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，如都与服务器的相符，服务器返回304，否则，发送最新内容给浏览器。 3.12、浏览器缓存行为还有用户的行为有关 用户操作 Expires/Cache-Control Last-Modified/Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新开窗口 有效 有效 前进 后退 有效 有效 F5刷新 无效 有效 Ctrl+F5刷新 无效 无效 浏览器第一次请求流程图 浏览器再次请求时流程图 3.2、Web（反向代理）服务器缓存页面缓存是将动态页面直接生成静态的页面放在服务器端，用户调取相同页面时，静态页面将直接下载到客户端，不再需要通过程序的运行和数据库的访问，大大节约了服务器的负载。每次访问页面时，会检测相应的缓存页面是否存在，若不存在，则连接数据库得到数据渲染页面并生成缓存页面文件，这样下次访问的页面文件就发挥作用了。 Nginx的页面缓存以及gzip压缩。（当Nginx充当反向代理服务器或Web服务器设置页面缓存可有效缩短请求流程）。 Nginx的一大功能就是完成静态资源的分离部署，减轻后端服务器的压力，如果给这些静态资源再加一级nginx的缓存，可以进一步提升访问效率。 第一步：添加nginx.conf的http级别的缓存配置 12345678910111213141516171819##cache## proxy_connect_timeout 500; #跟后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_read_timeout 600; #连接成功后_等候后端服务器响应的时间_其实已经进入后端的排队之中等候处理 proxy_send_timeout 500; #后端服务器数据回传时间_就是在规定时间内后端服务器必须传完所有数据 proxy_buffer_size 128k; #代理请求缓存区_这个缓存区间会保存用户的头信息以供Nginx进行规则处理_一般只要能保存下头信息即可 proxy_buffers 4 128k; #同上 告诉Nginx保存单个用的几个Buffer最大用多大空间 proxy_busy_buffers_size 256k; #如果系统很忙的时候可以申请更大的proxy_buffers 官方推荐*2 proxy_temp_file_write_size 128k; #proxy缓存临时文件的大小 proxy_temp_path /usr/local/nginx/temp; #用于指定本地目录来缓冲较大的代理请求 proxy_cache_path /usr/local/nginx/cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g; #设置web缓存区名为cache_one,内存缓存空间大小为12000M，自动清除超过15天没有被访问过的缓存数据，硬盘缓存空间大小200g 第二步：在访问静态文件的location上添加缓存 12345678910111213141516#静态数据保存时效location ~ \\.html$ &#123; proxy_pass http://source.qingk.cn; proxy_redirect off; proxy_cache cache_one; #此处的cache_one必须于上一步配置的缓存区域名称相同 proxy_cache_valid 200 304 12h; proxy_cache_valid 301 302 1d; proxy_cache_valid any 1m; #不同的请求设置不同的缓存时效 proxy_cache_key $uri$is_args$args; #生产缓存文件的key，通过4个string变量结合生成 expires 30d; #其余类型的缓存时效为30天 proxy_set_header X-Forwarded-Proto $scheme;&#125; 第三步：在proxy_pass跳转的location中配置静态文件的路径 1234location ~ .*\\.(html)$ &#123; default_type 'text/html'; root \"/usr/local/openresty/nginx/html\";&#125; 第四步：清除缓存 12345678location ~ /purge(/.*) &#123; #删除指定缓存区域cache_one的特定缓存文件$1$is_args$args proxy_cache_purge cache_one $1$is_args$args; #运行本机和10.0.217.0网段的机器访问，拒绝其它所有 allow 127.0.0.1; allow 10.0.217.0/24; deny all;&#125; 页面缓存流程图 3.3、CDNCDN的全称是内容分发网络(content delivery network)， 作用是把内容从你的服务器搬运到里用户最近的服务器， 当你访问内容的时候，CDN会自动的把请求发送到离你最近的缓存服务器。数据负载均衡和反向代理的应用。 3.4、应用服务器缓存 缓存Ajax请求数据。 基于内存的后端数据缓存，缓存介质可以是Nosql 等。 3.5、数据库缓存数据库的缓存一般由数据库提供，可以对表建立高速缓存。 除了运维修改数据库设置能够影响数据库缓存的话，用户代码基本上不会碰到这部分，不过我们在实际应用的时候还是需要考虑到的数据库缓存对访问速度的影响。比如MySQL对缓存的敏感度就很高, 缓存越大, 跑得越快。 详见：MySQL数据库性能优化之缓存参数设置 四、缓存的设计与策略4.1、缓存对象缓存主要用来存放那些读写比很高，很少变化的数据。 4.2、缓存更新策略主要有两种方式：被动失效和主动更新。 九、首屏时间九、使用工具YSlow 百度站长工具-页面优化建议 ehcache、redis应用场景比较 java web开发缓存方案，ehcache和redis哪个更好? 缓存穿透，缓存击穿，缓存雪崩解决方案分析 系统吞吐量（TPS）、用户并发量、性能测试概念和公式 八、参考资料 java缓存技术的介绍 Cache 和 Buffer 都是缓存，主要区别是什么？ [x] 几个著名Java开源缓存框架介绍 [x] 浅谈Web系统设计之缓存 大型web系统数据缓存设计 变态的静态资源缓存与更新（超详细好文） web性能优化:详说浏览器缓存 [x] nginx的web缓存服务环境部署记录 [x] nginx,控浏览器缓存,前端优化方案 浏览器的默认缓存行为 关于浏览器缓存和本地静态资源的问题 Nginx与浏览器缓存的处理方法 九、结语 ecache做一级缓存，redis做二级缓存","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/网站性能测试工具Yslow使用教程","date":"2019-03-12T06:57:56.936Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/网站性能测试工具Yslow使用教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/网站性能测试工具Yslow使用教程/","excerpt":"","text":"百度百科 - yslow gtmetrix [x] 7 天打造前端性能监控系统 [x] 前端性能——监控起步","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Tomcat并发连接数优化","date":"2019-03-12T06:57:56.936Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Tomcat并发连接数优化/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Tomcat并发连接数优化/","excerpt":"","text":"设计需求系统最大并发数为1100左右。此系统在一台服务器上可支持150万左右的用户数。 Tomcat 7最大并发连接数的正确修改方法 [x] 1000个并发到底最大能承载多少用户？ [x] 各种技术的并发量与服务器个数 [x] 各种技术的并发量与服务器个数 [x] 系统吞吐量（TPS）、用户并发量、性能测试概念和公式 [x] Web开发中，什么级别才算是高并发","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Web项目系统瓶颈测试","date":"2019-03-12T06:57:56.932Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Web项目系统瓶颈测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/性能优化/Web项目系统瓶颈测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/ Spring &SprinBoot单元测试","date":"2019-03-12T06:57:56.932Z","updated":"2018-12-12T08:57:46.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/ Spring &SprinBoot单元测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/ Spring &SprinBoot单元测试/","excerpt":"","text":"[x] SpringBoot 中借助 TestNG/SpringBootTest 实现测试 [x] SpringBoot项目单元测试 Springboot 测试用例 –Test Junit","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/Junit参数化测试","date":"2019-03-12T06:57:56.920Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/Junit参数化测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/单元测试/Junit参数化测试/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.06 1.0 ZZ 初稿 三、概念解析3.1、快捷键 F5：跳入方法 F6：向下逐行调试 F7：跳出方法 F8：直接跳转到下一个断点 异常是程序在运行时出现的不正常情况。 四、正文五、正文六、相关术语七、拓展阅读八、参考资料 JUnit 入门教程 什么时候用异常，什么时候用断言？ 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/jmeter性能测试和接口测试","date":"2019-03-12T06:57:56.916Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/jmeter性能测试和接口测试/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/jmeter性能测试和接口测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/代码评审","date":"2019-03-12T06:57:56.916Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/代码评审/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/代码评审/","excerpt":"","text":"CI持续集成系统环境—部署gerrit环境完整记录 code review 质量缺陷类型空指针引用，资源泄漏，死锁，内存崩溃，安全缺陷/缓冲区溢出，API使用错误，未初始化变量，类层次结构不一致，性能效率低下，安全最佳实践违反，代码维护问题 ，程序挂起，错误处理问题，并行数据访问违规，竞态条件，错误表达，控制数据流问题，内存非法访问，不安全数据处理。 Git之CodeReview流程 我们是怎么做Code Review的","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/[未发布]Web性能优化实践","date":"2019-03-12T06:57:56.916Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/[未发布]Web性能优化实践/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC06 软件测试 & 性能优化/软件测试/[未发布]Web性能优化实践/","excerpt":"","text":"缓存 最高效的网络请求是那些不使用网络的请求。换句话说，重用已缓存的响应结果的能力能够显著地改善应用的性能。 异步","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/SVN使用教程","date":"2019-03-12T06:57:56.912Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/SVN使用教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/SVN使用教程/","excerpt":"","text":"4.1、SVN 标准分支命名规则1234|- svn://localhost/Xxx |- trunk 主分支 |- branches 开发分支 |- tags 发布分支（不允许修改） 二、软件版本命名规范: 1.1.1.2010.08.05_beta 主版本号.次版本号.修订版本号.日期.版本阶段号 Base: 初始设计版本 Alpha: 内部测试版本 Beta: 外部测试版本 RC: 预发布版本 Release: 最终版本 v1.1.1：第一位大版本号，大功能发布时增加，技术负责人审核；第二位小版本号，增加小特性时增加，主开发审核；第三位BUG修复号，修复BUG用，修复人员负责。 三、项目示例3.1、AnjiOnline项目目录结构说明:123456|- svn://localhost/AnjiOnline |- trunk 主开发分支 |- branches 前端页面开发分支 |- tags AnjiOnline_1.1.1.2017.08.08_beta 测试版 |- tags AnjiOnline_2.1.1.2017.09.13_beta 初始正式版 |- tags AnjiOnline_3.1.1.2017.09.29_beta 交付版_目录已调整 3.2、Test项目分支结构说明:123456|- svn://localhost/AnjiOnline |- trunk 主开发分支 |- branches 前端页面开发分支 |- tags AnjiOnline_1.1.1.2017.08.08_beta 测试版 |- tags AnjiOnline_2.1.1.2017.09.13_beta 初始正式版 |- tags","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/Git使用教程","date":"2019-03-12T06:57:56.912Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/Git使用教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/Git使用教程/","excerpt":"","text":"[TOC] 一、前言Git是一种分布式的版本控制工具。与传统的集中式（中心化）管理相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，即使没有网络你也可以提交变动到版本库（因为本地就有一个完整的版本库），Git的中心仓库（习惯命名为 origin）和SVN等传统版本控制系统不同，它不是一切的中心，也仅仅是一个副本，它的存在只是为了方便协作开发，大家方便提交变动和同步变动。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.06 1.0 ZZ 初稿 2 2018.03.11 1.1 ZZ 补充完善 三、Git安装及初始化Git是一种的分布式版本控制系统，本段介绍Git和Git服务端的安装。 Git的数据交换跟交互是基于SSH的，需要给系统配置SSH服务，通过 ps -ef|grep sshd看看系统是否已经有SSH服务。 3.1、安装Git服务端1# yum install git 3.2、创建Git管理用户并设置密码12# sudo useradd git# sudo passwd 12345678 3.21、禁止git用户登录shell出于安全考虑，创建的git用户不允许登录shell。 1# vim /etc/passwd 修改如下： 123git:x:1001:1001:,,,:/home/git:/bin/bash改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 3.3、创建Git仓库存储目录和权限12345# mkdir /home/git/repositories// Change own，更改文件的所有者或组# chown git:git /home/git/repositories// 改变文件权限# chmod 755 /home/git/repositories 3.4、切换到git用户并建立项目123456789// # su git# cd /home/git/repositories# 初始化一个仓库名称为demo# git init --bare demo.git# 修改项目权限# chown -R git:git demo.git 四、Git 客户端操作1234567服务器：CentOS 7 (192.168.1.251)用 户：git (git-shell)仓 库：demo.git地 址：git@192.168.1.251:/home/git/demo.git客户端：deepin deepin.pub（deepin git公钥） win10 win10.pub（win10 git公钥） 4.1、用户登录4.11、密码登录（基于口令的安全验证）给每个人建立一个账户，直截了当但略过繁琐。 服务端添加12# useradd zz# passwd 123 4.12、公钥登录（基于密匙的安全验证）创建客户端登陆证书，收集所有需要登录的客户端公钥，就是他们自己生成的 id_rsa.pub 文件，把所有公钥复制到 /home/git/.ssh/authorized_keys文件里，一行一个。 客户端生成id_rsa.pub 1# ssh-keygen -t rsa 服务端添加公钥 1# cat .ssh/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 4.2、Git基本操作Git 基本操作流程图 流程图补充说明 [x] Git commit与pull的先后顺序 Git关于pull,commit,push的总结 4.21、命令行操作 常用操作 12345678910111213141516171819202122232425262728usage: git [--version] [--help] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|--no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]最常用的 git 命令有： add 添加文件内容至索引 bisect 通过二分查找定位引入 bug 的变更 branch 列出、创建或删除分支 checkout 检出一个分支或路径到工作区 clone 克隆一个版本库到一个新目录 commit 记录变更到版本库 diff 显示提交之间、提交和工作区之间等的差异 fetch 从另外一个版本库下载对象和引用 grep 输出和模式匹配的行 init 创建一个空的 Git 版本库或重新初始化一个已存在的版本库 log 显示提交日志 merge 合并两个或更多开发历史 mv 移动或重命名一个文件、目录或符号链接 pull 获取并合并另外的版本库或一个本地分支 push 更新远程引用和相关的对象 rebase 本地提交转移至更新后的上游分支中 reset 重置当前HEAD到指定状态 rm 从工作区和索引中删除文件 show 显示各种类型的对象 status 显示工作区状态 tag 创建、列出、删除或校验一个GPG签名的 tag 对象 Git 命令速查表 4.211、新建代码库 命令 简要说明 git init 在当前目录新建一个Git代码库 git init [project-name] 在当前目录新建一个Git代码库 git clone [url] clone代码到本地 4.212、Git配置 命令 简要说明 git config –list 显示当前的Git配置 git config [–global] user.name “[name]” git config [–global] user.email “[email address]” 设置提交代码时的用户信息 4.213、增加/删除文件 命令 简要说明 git add [file1] [file2] 添加指定文件到暂存区 git add [dir] 添加指定目录到暂存区，包括子目录 git add . 添加当前目录的所有文件到暂存区 git add -p 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] … 删除工作区文件，并且将这次删除放入暂存区 git rm –cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 4.214、代码提交 命令 简要说明 git commit -m [message] 提交暂存区到仓库区 git commit [file1] [file2] … -m [message] 提交暂存区的指定文件到仓库区 git commit -a 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v 提交时显示所有diff信息 git commit –amend -m [message] 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit –amend [file1] [file2] … 重做上一次commit，并包括指定文件的新变化 4.215、分支 命令 简要说明 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch [branch-name] 新建一个分支，但依然停留在当前分支 git checkout -b [branch] 新建一个分支，并切换到该分支 git branch [branch] [commit] 新建一个分支，指向指定commit git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] 切换到指定分支，并更新工作区 git checkout - 切换到上一个分支 git branch –set-upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间 git merge [branch] 合并指定分支到当前分支 git cherry-pick [commit] 选择一个commit，合并进当前分支 git branch -d [branch-name] 删除分支 git push origin –delete [branch-name]git branch -dr [remote/branch] 删除远程分支 4.216、标签 命令 简要说明 git tag 列出所有tag git tag [tag] 新建一个tag在当前commit git tag [tag] [commit] 新建一个tag在指定commit git tag -d [tag] 删除本地tag git push origin :refs/tags/[tagName] 删除远程tag git show [tag] 查看tag信息 git push [remote] [tag] 提交指定tag git push [remote] –tags 提交所有tag git checkout -b [branch] [tag] 新建一个分支，指向某个tag 4.217、查看信息 命令 简要说明 git status 显示有变更的文件 git log 显示当前分支的版本历史 git log –stat 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] 搜索提交历史，根据关键词 git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD –grep feature 显示某个commit之后所有变动，其”提交说明”必须符合搜索条件 git log –follow [file]git whatchanged [file] 显示某个文件的版本历史，包括文件改名 git log -p [file] 显示指定文件相关的每一次diff git log -5 –pretty –oneline 显示过去5次提交 git shortlog -sn 显示所有提交过的用户，按提交次数排序 git blame [file] 显示指定文件是什么人在什么时间修改过 git diff 显示暂存区和工作区的差异 git diff –cached [file] 显示暂存区和上一个commit的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git diff [first-branch]…[second-branch] 显示两次提交之间的差异 git diff –shortstat “@{0 day ago}” 显示今天你写了多少行代码 git show [commit] 显示某次提交的元数据和内容变化 git show –name-only [commit] 显示某次提交发生变化的文件 git show [commit]:[filename] 显示某次提交时，某个文件的内容 git reflog 显示当前分支的最近几次提交 4.218、远程同步 命令 简要说明 git fetch [remote] 下载远程仓库的所有变动 git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库的信息 git remote add [shortname] [url] 增加一个新的远程仓库，并命名 git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] 上传本地指定分支到远程仓库 git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突 git push [remote] –all 推送所有分支到远程仓库 4.219、撤销 命令 简要说明 git checkout [file] 恢复暂存区的指定文件到工作区 git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区 git checkout . 恢复暂存区的所有文件到工作区 git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset –hard 重置暂存区与工作区，与上一次commit保持一致 git reset –hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset –keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git revert [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 git stashgit stash pop 暂时将未提交的变化移除，稍后再移入 4.2110、其他 命令 简要说明 git archive 生成一个可供发布的压缩包 4.3、图像化工具操作1&gt; ssh://git@101.132.148.105/home/git/repositories/demo.git 4.31、IntelliJ-IDEA绑定Git4.311、版本控制的常用设置4.3111、配置git安装路径（windows为git.exe） 确保电脑上已经安装了Git，然后如下图配置路径。 4.3112、配置Github账号（按需） 4.3113、其他配置 Version Control面板 Ignored Files面板 4.312、版本控制的主要操作4.3121、Clone项目从Github上 4.3122、选择项目，创建本地仓库 4.3123、将本地项目上传到Github上 4.3124、Git工具栏操作按钮 Updata Project 更新项目 Commit 提交到本地仓库 compare with the same Respository version 当前文件与服务器上版本进行比较 show history 显示当前文件的历史记录 Revert 恢复 4.3125、Git 菜单选项 4.3126、Git - Commit操作面板 4.3127、Git - Push操作面板 4.3128、项目分支设置的入口 4.3129、Version Control 窗口 4.32、使用Gitkraken操作Git4.321、下载与安装 Gitkraken官网 GitKraken Support 4.322、配置与使用GitKraken面板预览图 4.3221、打开本地仓库 4.3222、Clone项目从远程仓库 4.3222、初始化本地或远程仓库 4.323、GitKraken面板介绍 4.33、使用SourceTree操作Git4.331、下载与安装 SourceTree官网 4.332、配置与使用 用SourceTree轻松Git项目图解 Gitlab和Sourcetree结合使用实现代码管理 4.34、使用SmartGit操作Git SmartGit使用教程 五、Git进阶指南5.1、遇到冲突了怎么解决？ Git commit与pull的先后顺序 该部分须继续完善，参考上文Git进阶指南部分。 六、参考资料 Git教程 Git - Documentation - Book [x] Git操作手册|命令速查表 [x] 在IDEA中实战Git IDEA中Git的更新、提交、还原方法 [x] IntelliJ-IDEA和Git、GitHub、Gitlab的使用 [x] git图形化工具GitKraken的使用 使用Gitkraken进行其他Git操作 git图形化工具GitKraken的使用——分支的创建与合并 git图形化工具GitKraken的使用——Stash和Pop git fetch和git pull之间的区别 七、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/版本管理分支命名规范","date":"2019-03-12T06:57:56.908Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/版本管理分支命名规范/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/版本管理/版本管理分支命名规范/","excerpt":"","text":"[TOC] 一、前言为了规范代码库的版本管理，使代码分支及版本结构清晰，方便维护，并避免由于维护造成的版本发布错误等问题。特制定此规范。本规范基于nvie的Git Flow模型制定。 Git Flow是构建在Git之上的一个组织软件开发活动的模型，是在Git之上构建的一项软件开发最佳实践。Git Flow是一套使用Git进行源代码管理时的一套行为规范和简化部分Git操作的工具。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.06 1.0 ZZ 初稿 2 2018.03.11 1.1 ZZ 补充完善 三、概念解析Git Flow 模型示意图 Git是一种分布式的版本控制工具。与传统的集中式（中心化）管理相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，即使没有网络你也可以提交变动到版本库（因为本地就有一个完整的版本库），Git的中心仓库（习惯命名为 origin）和SVN等传统版本控制系统不同，它不是一切的中心，也仅仅是一个副本，它的存在只是为了方便协作开发，大家方便提交变动和同步变动。 Git Flow模型中定义了主分支和辅助分支两类分支。下面介绍两类分之的定义及应用场景。 3.1、主分支主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支包括master和develop两种。 master 当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。每一次更新，都应有对应的版本号标签（TAG）。理论上是每次master更新后，都需要通过自动化部署工具进行上线发布。 develop develop分支是保存当前最新开发成果的分支。当develop分支上的代码已实现了软件需求说明书中所有的功能，通过了所有的测试后，并且代码已经足够稳定时，就可以将所有的开发成果合并回master分支了。任何需求分支都以这个分支为父分支进行建立。 3.2、辅助分支辅助分支是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。这些分支与主分支不同，通常只会在有限的时间范围内存在。主分支包括release和feature、hotfix三种。 release 预发布分支：开发完成和将一个迭代的所有修改合并到该分支供测试人员测试。 feature feature分支是短期的一个需求开发过程中创建的一个特性分支，理论上每一个需求可以细分成一个特性分支，一次迭代可能会细分出5-6个特性分支。 hotfix hotfix分支是为了解决一个紧急的线上问题而建立的分支。 四、分支命名规范通常每个应用或者是二方库的代码将包括 master、develop、release、hotfix、feature分支。release、hotfix 分支的命名规则分别为：release- ，hotfix- 。feature分支的命名可以使用除master，develop，release-，hotfix-之外的任何名称。 项目示例示例 123456|- ssh://git@localhost/home/git/repositories/Xxx.git |- master 主分支，提供给用户的可用的稳定tag版本 |- develop 主开发分支，需求分支都以这个分支为父分支进行建立 |- feature-* 功能分支，某个功能点正在开发阶段，临时分支 |- release-* 预发布分支，正式发布前的测试，临时分支 |- hotfix-* 热修复分支，线上代码的Bug修正，临时分支 五、软件版本命名规范 v1.0.0.180307_beta 第一位主版本号，主功能发布时增加，技术负责人审核； 第二位小版本号，增加小特性时增加，主开发审核； 第三位BUG版本号，修复BUG用，修复人员负责； 第四位日日期版本号 + 版本阶段号。 base: 初始设计版(假页面) alpha: 内测版 beta: 外测版 RC: 预发布版（发行候选版） Release: 终发行版 六、提交记录规范Commit必须要写，内容简介明了，有较强的可读性。格式非强制要求。 七、应用实例 待补充 八、参考资料 A successful Git branching Git 分支的最佳实践 Git 分支命名规范 Git分支管理策略 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在web项目中使用MarkDown组件","date":"2019-03-12T06:57:56.904Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在web项目中使用MarkDown组件/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在web项目中使用MarkDown组件/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用使用editor.md插件，读取md文件展示HTML页面的配置过程。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.08 1.0 ZZ 初稿 三、前期准备3.1、下载组件 GitHub - editor.md四、编辑页面 五、预览页面七、拓展阅读八、参考资料 异常处理_百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/如何使用markdown画思维导图","date":"2019-03-12T06:57:56.900Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/如何使用markdown画思维导图/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/如何使用markdown画思维导图/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/Atom搭建Markdown写作环境，托管到Git","date":"2019-03-12T06:57:56.900Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/Atom搭建Markdown写作环境，托管到Git/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/Atom搭建Markdown写作环境，托管到Git/","excerpt":"","text":"[TOC] 一、前言作者曾热衷于有道云笔记，但是每三个月导出一次的限制，和Linux系统客户端的实现不完美，使我再次寻求解决方案。在尝试过多种Markdown笔记工具后，认为Atom的实现是最好的。 Atom 可以通过导入项目的形式管理文件结构（tree-view）。通过Markdown-writer插件和Markdown-preview-enhanced实现写作与预览同步，并且Markdown-preview-enhanced集成了同步滚动，导出Html，PDF，eBook，目录导航等功能。还可以通过language-markdown插件实现代码高亮，minimap实现mini地图导航，tool-bar插件实现Markdown常用工具栏功能。以及Git插件实现文档托管。有需要还可以通过atom-simplified-chinese-menu实现软件的汉化。 总之，Atom及其插件的配合，实现了我使用Markdown写作的所有需求，并且性能稳定，文档安全。 测试环境：Deepin 15.5 发行版。Atom 1.22.1 x64。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.17 1.0 ZZ 初稿 三、安装及配置Atom 集成Markdown效果图 3.1、安装Atom Atom安装过程详见：Atom官网 3.2、安装插件可以通过编辑 - 偏好设置 - Settings - 安装拓展包/主题 ，搜索你需要安装的插件。并且安装后可以对插件的参数进行设置。 3.21、写作增强（Markdown-writer）它能让你更方便地管理和编辑Markdown文件，并自带tool-bar工具插件。提供Markdown写作中常用标签的快捷键。 3.22、预览增强（Markdown-preview-enhanced）Atom自带的Markdown预览插件markdown-preview功能比较简单，Markdown-preview-enhanced对其做了功能扩展和增强。使用该插件前，需要先禁用markdown-preview。 目录导航 支持同步预览 支持Latex公式。 Html，PDF，eBook导出。 3.23、语法增强（language-markdown）一般的Markdown编辑器提供了代码着色等基本功能，language-markdown除了能给代码着色，还提供了快捷的代码片段生成等功能。 3.24、迷你地图导航（minimap）在写作右侧显示迷你地图，以便于搜索和快速导航。 3.25、图标插件（file-icons）用于渲染文件扩展名的图标和颜色，以提高文件查找的视觉效果。 3.26、Git插件（Atom自带）可以实现Git常用功能的需求。 3.27、汉化插件（atom-simplified-chinese-menu）Atom 简体中文语言包，提供最新的菜单栏、右键菜单及设置完整汉化。 3.3、Atom的配置 可以通过直接编辑Atom样式表 styles.less，来设置软件的字体样式等。示例如下： 1234567891011121314151617181920.tree-view &#123; // background-color: whitesmoke; font-family:\"微软雅黑\"; font-size: 14px;&#125;``atom-pane, .command-palette &#123; font-family:\"微软雅黑\"; font-size: 14px;&#125;.settings-view &#123; font-family:\"微软雅黑\"; font-size: 12px; &#125;.tab-bar .tab .title &#123; font-family:\"微软雅黑\"; font-size: 15px;&#125; 八、参考资料 使用Atom打造无懈可击的Markdown编辑器 九、结语 由于插件的安装比较简单，故只做了功能介绍。目前尚欠缺的是博客发布功能，有待机进一步研究。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在JavaWeb项目中实现Markdown编辑器","date":"2019-03-12T06:57:56.900Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在JavaWeb项目中实现Markdown编辑器/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Markdown/在JavaWeb项目中实现Markdown编辑器/","excerpt":"","text":"[TOC] 一、前言本文介绍在JavaWeb项目中集成Markdown组件的方法，实现文章的编辑与保存，以及数据库或Git仓库*.md格式文章的读取与展示。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.12 1.0 ZZ 初稿 三、概念解析八、参考资料 markdown在项目中的使用 在web项目中使用MarkDown组件 javaweb项目集成editor.md编辑器—markdown编辑器 使用并改造editor.md在JAVA-WEB项目中实现Markdown编辑器 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/sublime text 3 简易教程","date":"2019-03-12T06:57:56.896Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/sublime text 3 简易教程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/sublime text 3 简易教程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/端口及配置索引","date":"2019-03-12T06:57:56.896Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/端口及配置索引/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/端口及配置索引/","excerpt":"","text":"一、前言二、设备概况 编号 应用 端口号 IP 说明 1 SSH 22 127.0.0.1 SSH连接 2 FTP 21 127.0.0.1 FTPF服务 3 Nginx 80 127.0.0.1 反向代理服务器 4 Tomcat–测试 8080 127.0.0.1 web测试服务器 5 Tomcat–发布 8888 127.0.0.1 web发布服务器 6 Mysql 3306 127.0.0.1 mysql数据库服务器 7 Redis 6379 127.0.0.1 缓存服务器 8 ActiveMQ 8161 127.0.0.1 消息队列服务器","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/运维相关的基本概念解析","date":"2019-03-12T06:57:56.896Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/运维相关的基本概念解析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/基础知识/运维相关的基本概念解析/","excerpt":"","text":"Web服务器 Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL。 应用服务器 Web服务器是应用服务器的一种。 反向代理服务器 [x] 一文看懂web服务器、应用服务器、web容器、反向代理服务器区别与联系 [x] 系统吞吐量（TPS）、用户并发量、性能测试概念和公式","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/InterliJ IDEA 使用总结","date":"2019-03-12T06:57:56.892Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/InterliJ IDEA 使用总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/InterliJ IDEA 使用总结/","excerpt":"","text":"[TOC] 一、前言由于工作需求，需要开发和阅读一部分前端和移动端代码，然而Eclipse对这些的支持不是很友好，所以尝试用InterliJ IDEA来开发这部分代码，本文用来记录InterliJ IDEA的常用配置，以作备忘。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.01.19 1.0 ZZ 初稿 三、代码风格设置3.1、编码/颜色/字体3.2、代码注释3.21、新建class类注释设置新建Java类时自动生成类的注解。 File -&gt; Setting -&gt; File and Code Templates 设置步骤图解如下： 12345/** * @author $&#123;USER&#125; * @date $&#123;TIME&#125; $&#123;DATE&#125; * @description TODO */ 3.22、自定义类和方法注释由于InterliJ IDEA不能像Eclipse那样，修改类和方法的Code Template注释，所以需要通过自定义快捷键的方式来实现。 File -&gt; Settings -&gt; Editor -&gt; Live Templates 设置步骤图解如下： 类注释： 12345** * @author $USER$ * @date $TIME$ $DATE$ * @description TODO */ 类注释使用时输入 /* + Enter 方法注释： 123456**$PARAMS$ * @return $RETURNS$ * @throws $EXCECPTION$ * @description TODO */ 如果要设置参数分列显示，须把$PARAMS$表达式的值为如下脚本： 1groovyScript(\"def result=''; def params=\\\"$&#123;_1&#125;\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=' * @param ' + params[i] + ((i &lt; params.size() - 1) ? '\\\\n' : '')&#125;; return result\", methodParameters()) 方法注释使用时输入 /** + Enter 3.3、快捷键风格3.31、快捷键设置因为以前一直使用Eclispe，为了使快捷键的使用不至于混乱，所以IntelliJ IDEA快捷键沿用Eclipse风格。设置如下： File -&gt; Setting -&gt; Keymap -&gt; Eclispe 3.32、快速输入 快速输入是通过设置快捷键的方式实现的，方法如自定义注解的方式相同。 常用快速输入设置如下： 快捷键 代码 logger static final Logger LOGGER 1main | ```public static void main(String [] agrs)&#123;$END$&#125; syso | 1for | ```for (int $i$=$start$; $i$&lt;$end$; $i$++) &#123;$cursor$&#125; foreach | ($i$ : $data$) &#123;$cursor$&#125;```1switch | ```switch ($VAR$) &#123;case $VAR_CHILDREN$:break;$END$&#125; if | if ($VAR_a$==$VAR_b$) {$cursor$} else if($VAR_a$==$VAR_b$) {$cursor$} else {$cursor$ } 使用时输入 快捷键 + Enter，例如 syso + + Enter 3.4、生成Javadoc文档 3.41、问题一： javadoc 编码GBK的不可映射字符 解决方案： 运行Tools -&gt; Gerenate JavaDoc时，在Other command line arguments 栏里输入：-encoding utf-8 -charset utf-8 。 3.42、问题二： @date等是未知标记 解决方案： 运行Tools -&gt; Gerenate JavaDoc时，在Other command line arguments 栏里输入：-tag date:a:”日期:” -tag description:a:”描述:” 。 四、开发环境设置4.1、JDK4.2、Tomcat4.3、JRebel热部署插件 现在 JRebel 对个人非商业用途的用户永久免费。 idea2017+热部署插件jRebel安装与配置 4.4、Maven4.5、SVN五、输入输出自定义模板六、相关术语七、拓展阅读八、参考资料 IntelliJ IDEA官方文档 IntelliJ IDEA使用语言构造的周围代码块 IntelliJ IDEA 自定义方法注解模板 Creating and Editing Template Variables 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/MyEclipse 使用总结","date":"2019-03-12T06:57:56.892Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/MyEclipse 使用总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/IDE & 编程软件/MyEclipse 使用总结/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.06 1.0 ZZ 初稿 三、概念解析3.1、如何改变Myeclipse编辑区背景色 Eclipse编辑区背景色调整 编辑窗口右键单击 –&gt; Preferences –&gt; General加号 –&gt; Editors –&gt; 点Text Editors字样 –&gt; 右下窗口选Backgroud color,右边点掉System Default按钮，点Color右边的颜色框，选择颜色OK背景颜色向你推荐：RGB 85 123 205 代码字体大小调整 窗口(Window) –&gt; 首选项（Preferences） –&gt; 常规（General） –&gt; 外观(Appearence) –&gt; 颜色与字体(Colors And Fonts)，在右边的对话框里选择Java –&gt; Java Editor Text Font，点击出现的修改（Change）按钮，将字体大小改成12或小四号，设置完之后点击右下角的应用(Apply)，最后点击确定（OK）即可。 xml的字体大小调整 window –&gt; preferences –&gt; General –&gt; appearance –&gt; colors and fonts –&gt; Basic –&gt; “Text font “ 然后点change,可以设置字体的大小 3.2、控制台乱码的解决run-&gt;debug configurations –&gt; 选中一个项目 点击Arguments 在vm arguments里面输入：-Dfile.encoding=GB2312 点击Common Encoding选择Other GBK (或者手动输入GBK) 3.3、改变字体颜色windows –&gt; Preferences –&gt; Java –&gt; Editor –&gt; Syntax Coloring –&gt; Java Annotations(注释): 107, 147, 186 浅蓝色 Deprecated members(不建议使用的成员): 0, 0, 0 Fields(字段): 128, 0, 128 紫色 KeyWord &apos;return&apos;(关键字&apos;return&apos;): 255, 0, 0 红色 Keyword excluding &apos;return&apos;(除了关键字以外的return): 255, 128 ,0 橙色 Local variable declarations(局部变量声明): 128, 128, 128 灰色 Method declarations(方法声明): 255, 128, 64 橙色 Method(方法): 0, 48, 96 暗浅蓝色 Operators and brackets(运算符与方括号): 255, 128, 0 橙色 Others(其他): 96 153, 0 深绿色 Static fields(静态字段): 33, 0, 189 深蓝色 Static Method invocations(静态方法调用): 77, 166 255 天蓝色 Strings(字符串): 132, 26, 238 中天蓝色 Type variables(类型变量): 128, 0, 25 红罗色 参考： 现在用的Eclipse色彩配置 3.4、JDK 版本的选择左侧窗口项目右键 –&gt; Bulid path-&gt;Configure Bulid path；Libraries –&gt; 选中JDK –&gt; Edit –&gt; Alternate JRE –&gt; Installed –&gt; add –&gt; 选择JDK目录 –&gt; 选中 –&gt; Finish； 3.5、GSP编码的设置UTF-8Window –&gt; preference，依次选择General –&gt; Content Types –&gt; text –&gt; 修改CSS、HTML、JAVA、JS、JSP、XML等改为UTF-8 –&gt; update –&gt; OK。局部修改：左侧窗口项目右键 –&gt; Rescource –&gt; Text file encoding –&gt; Other –&gt; UTF-8 –&gt; OK。 3.6、默认打开方式Window-&gt;preference，依次选择General-&gt;搜索file-&gt;选择File Associations-&gt;设置JSP、HTML、HTM 的默认打开方式。 3.7、TAB键设置 点击 window –&gt; preference,依次选择 Genera –&gt; Editors –&gt; Text Editors,选中右侧的 insert space for tabs;保存，第一步完成； 点击 window –&gt; preference-,依次选择 java（或C++ –&gt; code style –&gt; formatter,点击右侧的editor，选则左侧 tab policy的值为spaces only,确定，应用保存即可； 若出现应用Apply按钮为灰色的情况，需要回到上一步，点击new按钮，根据当前的样式重新生成一个新的样式并保存，重复第2步，编辑该样式即可。 补充：设置EditPlus中Tab用空格替换： Tools—Preferences –&gt; Setting&amp;syntax File types框中选中要将Tab使用空格替换的文件类型（我选择java文件），然后点击Tab/Indent Tab and Indent窗口中输入Tab的大小，和Indent大小，两个值设置成一样大。然后将Insert spaces instead of tab勾中，点击Ok。 3.8、自动生成注释点击Windows-&gt;preference，依次选择Java –&gt; Code Style –&gt; Code Templates –&gt; code –&gt; new Java file。格式如下：12345/** * @author ZZ * @date 创建时间：$&#123;date&#125; $&#123;time&#125; * @version 1.0 */ 3.9、将eclipse的配置导出 方法一：直接保存一个已经配置好但没建项目的空workspace（推荐）。 配置就保存在workspace中，把一个已配置好但没建工程的空workspace保存起来(如压缩一个副本) ，以后不要新建workspace,解压一下,改个新名字，启动Eclipse时指向新workspace就行。 方法二：使用eclipse的导出功能（不推荐，很多东西设置不能导出）。 在菜单栏选择File –&gt; Export -–&gt; General –&gt; Preferences，导出来即可！ 3.10、eclipse自动补全的设置 自动提示设置 Windows——&gt;Preferences——&gt;Java–&gt;Editor–&gt;Content Asist，在Auto activation triggers for Java后面的文本框里只有一个“.”。现在你将其改为“.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”即可。然后你再试试，会发现，现在的补全功能跟VS差不多了。你还可以在Advanced和Favorite里进行高级的设置。 自动补全设置： 打开Eclipse -–&gt; Window -–&gt; Preferences -–&gt; Java -–&gt; Editor -–&gt; Templates -–&gt; newname中写你要快捷的缩写，description这个是描述，pattern这个是代码块例如：name：sc pattern：Scanner input = new Scanner(System.in); 3.11、eclipse折叠展开所有方法 eclipse设置折叠所有方法： Window –&gt; Preferences –&gt; General –&gt; keys –&gt; Collapse All eclipse设置展开所有方法，可以使用下面的方法： Window –&gt; Preferences –&gt; General –&gt; keys –&gt; Expand All 3.12、eclipse自动生成构造方法Source -–&gt; Generate Constructor using Fields 3.13、eclipse中高亮显示相同的变量设置windows -–&gt; preferences -–&gt; java -–&gt; Editor -–&gt; Mark Occurences 四、常用快捷键五、拓展阅读六、参考资料 Eclipse设置、调优、使用 Eclipse Java注释模板设置详解 Eclipse背景和匹配出现单词的一些设置 七、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/阿里云服务器配置","date":"2019-03-12T06:57:56.876Z","updated":"2019-02-22T08:36:12.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/阿里云服务器配置/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/阿里云服务器配置/","excerpt":"","text":"[TOC] 一、前言本文记录了线上项目服务端的配置过程。测试环境：服务端系统为CentOS 7（阿里云服务器），客户端系统为Deepin 15.5发行版。 客户端系统配置详见：安装配置详见Java开发环境搭建及项目部署（Deepin系统） 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.28 1.0 ZZ 初稿 三、客户端远程工具Deepin 客户端利用深度终端进行SSH远程管理和上传下载（或filezilla）。Windows系统可以用Xshell和Xftp等进行管理。 3.1、SSH远程管理1# ssh root@101.132.148.105 3.2、上传下载 使用深度终端进行上传和下载文件之前，请先确保服务端安装 rz和sz命令。 1# yum install lrzsz 四、IP地址配置本段是虚拟机下的固定IP地址配置过程，阿里云不用配置。 4.1、vim 编辑网卡配置文件1# vim /etc/sysconfig/network-scripts/ifcfg-ens33（eth0）第1块网卡 4.2、配置示例1234567891011121314151617181920212223 HWADDR=00:0C:29:51:D6:22DEVICE=ens33TYPE=EthernetDEFROUTE=yesPEERROUTES=yesIPV4_FAILUER_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noname=ens33UUID=ae0965e7-22b9-45aa-8ec9-3f0a20a85d11BOOTPRT=staticIPADDR=192.168.48.123PREFIXO=24NETMASK=255.255.255.0GATEWAY=192.168.48.1BROADCAST=192.168.48.255DNS1=8.8.8.8DNS2=8.8.4.4ONBOOT=yes 4.3、保存退出，并重启服务1# service network restart 重启服务 4.4、测试1# ping www.baidu.com 五、安装FTP服务（按需）5.1、安装FTP服务5.11、检测是否安装ftp服务1# rpm -qa |grep vsftpd 5.12、安装ftp1# yum install vsftpd 5.13、开启服务1# service vsftpd start （/bin/systemctl start vsftpd.service） 5.14、查看服务启动状态1# service vsftpd status （/bin/systemctl status vsftpd.service） 5.2、配置用户及权限5.21、配置root用户登录（按需） 默认情况下root用户不能登陆ftp,可以修改ftpusers、user_list 使root可以登录。 12# vim /etc/vsftpd/ftpusers# vim /etc/vsftpd/user_list 5.22、增加用户ftpuser 增加用户ftpuser，并指定主目录为/home/ftp，指定分组ftp。并禁止ftp用户登陆系统。 1# useradd -d /home/ftp -g ftp -s /sbin/nologin ftpuser 5.23、为ftpuser设置密码1# passwd ftpuser 5.24、设置 vsftpd.conf123456789101112131415161718192021222324252627282930313233343536# Example config file /etc/vsftpd/vsftpd.conf#anonymous_enable=YESlocal_enable=YESwrite_enable=YESlocal_umask=022#anon_upload_enable=YES 关闭匿名访问#anon_mkdir_write_enable=YESdirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YES#chown_uploads=YES#chown_username=whoever#xferlog_file=/var/log/xferlogxferlog_std_format=YESidle_session_timeout=600 断开该FTP连接时间data_connection_timeout=120#async_abor_enable=YESascii_upload_enable=YESascii_download_enable=YESftpd_banner=Welcome to blah FTP service. 使用文本登陆时的欢迎提示#deny_email_enable=YES#banned_email_file=/etc/vsftpd/banned_emailschroot_local_user=YES 限制用户不能切换出自己的根目录#chroot_list_enable=YES#chroot_list_file=/etc/vsftpd/chroot_listls_recurse_enable=YESlisten=YES#listen_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YESuserlist_deny=NO userlist文件夹为允许用户local_root=/home/ftp 用户默认根目录use_localtime=YESallow_writeable_chroot=YES 允许用户在主目录下有写入权限 5.25、设置selinux=disable1# vim /etc/selinux/config 5.3、安装telnet123# yum -y install telnet*# yum -y install xinetd# chkconfig telnet on // 设置开机启动 5.4、# 禁用防火墙1# systemctl disable firewalld.service 5.5、# 查看ftp端口1# netstat -ntlp 5.6、设置开机启动1# chkconfig vsftpd on 5.7、重启服务1# service vsftpd restart 5.8、查询开机启动项1# systemctl list-unit-files 5.9、卸载ftp12# rpm -aq vsftpd &gt;&gt; vsftpd-2.0.5-16.el5_5.1# rpm -e vsftpd-2.0.5-16.el5_5.1 六、安装JDK6.0、查看当前有没有安装jdk12# rpm -qa |grep jdk 查看当前有没有安装jdk# rpm -e jdk-1.7.0_65-fcs.i586 如果有就移除 6.1、安装6.11、源码包安装（推荐）6.111、在/usr/目录下创建java目录12# mkdir/usr/java# cd /usr/java 6.112、下载JDK压缩包,然后解压12// 把压缩包上传到/usr/java文件夹# tar -zxvf jdk-7u13-linux-x64.tar.gz 6.12、用yum在线安装JDK（不推荐）6.121、查看yum库中都有哪些jdk版本1# yum search java|grep jdk 6.122、选择版本,进行安装12# cd /usr/java/jdk1.8.0 // 默认的安装目录# yum install java-1.8.0-openjdk 6.13、用rpm安装JDK安装包（推荐）6.131、下载rpm安装文件 把安装包上传到/usr/java/jdk1.8.0文件夹下 RPM包下载地址 6.132、使用rpm命令安装12# cd /usr/java/jdk1.8.0# rpm -ivh jdk-8u201-linux-x64.rpm 6.2、设置环境变量1# vim /etc/profile 在profile末尾加入添加如下内容1234JAVA_HOME=/usr/java/jdk1.8.0CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 6.3、修改生效1# source /etc/profile 6.4、验证JDK有效性1# java -version 七、安装Web服务器Tomcat7.1、下载安装包 Apache Tomcat7 下载 7.2、通过ftp上传到服务器7.3、解压文件1# tar -zxvf apache-tomcat-7.0.77.tar.gz 7.4、移动和重命名1# cp -R apache-tomcat-7.0.77 /usr/local/apache-tomcat-7.0.77 7.5、启动测试12# cd /usr/local/apache-tomcat-7.0.77/bin/# ./startup.sh 访问http://192.168.1.123:8080 查看是否成功 注：需要在阿里云安全组策略，配置开放8080端口 7.6、添加用户12cd /usr/local/apache-tomcat-7.0.77/conf# vim tomcat-users.xml 修改一下内容12&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;root&quot; password=&quot;123&quot; roles=&quot;manager-gui&quot;/&gt; 7.7、设置tomcat开机启动7.71、脚本文件启动 在/etc/rc.d/init.d/下面创建启动/停止脚本文tomcat，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/sh# chkconfig: 2345 10 90# description: Starts and Stops the Tomcat daemon.#by jj###############################################Startup script for Tomcat on Linux#filename tomcat.sh#Make sure the java and the tomcat installation path has been added to the PATHJAVA_HOME=/usr/java/jdk1.7.0_13 #JDK安装目录CATALINA_HOME=/usr/local/apache-tomcat-7.0.77 #tomcat安装目录export JAVA_HOMEexport CATALINA_HOME###############################################start_tomcat=$CATALINA_HOME/bin/startup.sh #tomcat启动文件stop_tomcat=$CATALINA_HOME/bin/shutdown.sh #tomcat关闭文件start() &#123; echo -n &quot;Starting tomcat: &quot; $&#123;start_tomcat&#125; echo &quot;tomcat start ok.&quot;&#125;stop() &#123; echo -n &quot;Shutting down tomcat: &quot; $&#123;stop_tomcat&#125; echo &quot;tomcat stop ok.&quot;&#125;# See how we were calledcase &quot;$1&quot; in start) start ;; stop) stop ;; restart) stop sleep 10 start ;; *) echo &quot;Usage: $0 &#123;start|stop|restart&#125;&quot;esacexit 0 7.73、后续设置1234- chmod a+x tomcat // 设置脚本属性:- chmod 755 tomcat // 给脚本权限- chkconfig --add tomcat // 添加到服务- service tomcat start // 配置成功 7.74、其他常用命令 查看进程 1# ps -ef|grep tomcat 八、安装MySql数据库（建议mysql 5.7 以上）8.0、安装前看是否安装过mysql123# yum list installed mysql*// 如果有就清理卸载# yum remove mysql 8.1、压缩包形式安装（推荐）8.11、创建安装文件夹1# mkdir /usr/local/mysql 8.12、在线下载安装包123# wget wget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz或FTP上传离线包至目标文件夹 8.13、解压并复制12# tar -xzvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz# mv mysql-5.7.17-linux-glibc2.5-x86_64 /usr/local/mysql 8.14、创建data目录1# mkdir /usr/local/mysql/data 8.15、添加用户mysql 到用户组mysql（按需）12# groupadd mysql# useradd -r -g mysql mysql 8.16、修改文件夹的所有者1# chown -R mysql:mysql /usr/local/mysql 8.17、初始化数据库，添加mysql用户12# cd /usr/local/mysql/# ./bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data 8.18、修改开机启动 复制配置文件到 /etc/my.cnf 123cp support-files/mysql.server /etc/init.d/mysqldchmod 755 /etc/init.d/mysqldcp support-files/my-default.cnf /etc/my.cnf //（选择y） 添加如下内容 1234datadir = /usr/local/mysql/datapid-file = /usr/local/mysql/data/mysql.pidport = 3306log-error=/var/log/mysqld.log 修改启动脚本 1# vim /etc/init.d/mysqld 添加如下内容 12basedir=/usr/local/mysql/datadir=/usr/local/mysql/data/mysqld 加入环境变量 1# vim /etc/profile 添加如下内容 1# export PATH=$PATH:/usr/local/mysql/bin 立即生效 1# source /etc/profile 设置开机启动 1# chkconfig mysqld on 8.19、设置用户密码和开启远程访问权限 设置用户密码（mysql 5.7 以上设置方法） 12345678// 忘记root密码也可按此步骤设置# mysqld_safe --skip-grant-tables &amp;# mysql -u root -p //直接回车&gt; use mysql ;&gt; update user set authentication_string = password(&apos;123&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;root&apos;;&gt; FLUSH PRIVILEGES;&gt; exit&gt; service mysql start 开启远程访问权限 12# mysql -u root -p //重新登录&gt; grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123&apos;; // 给远程IP用户授权 重启mysql 1# service mysqld restart 查看运行状态 1# service mysqld status 8.2、yum仓库在线安装 查看yum库下是否有mysql 1# yum list | grep mysql 如果有mysql，则安装mysql服务端 12# yum install mysql-server# yum install mysql-devel 启动mysql服务 1# service mysqld start 以下步骤同上 九、Git服务器安装（按需） 详见Git使用教程 十、反向代理Nginx10.1、反向代理隐藏Tomcat端口号HTTP协议默认的端口是80。域名解析设置成功后，如果想访问网站就要使用域名+Tomcat端口号8080，设置反向代理后可以直接用域名访问，隐藏Tomcat端口号。 参考：Nginx安装配置 10.2、Nginx负载均衡十一、安装部署DNS解析服务器十二、安装文件服务器 Linux中Samba详细安装 利用百度云做成网站文件服务器 CentOS 6.3安装Nginx 搭建文件服务器 CentOS 6 5下文件服务器 Samba+nfs 的安装与配置 CentOS6.5下搭建NFS文件服务器 十三、阿里云自定义镜像及跨服务器迁移十四、开启关闭防火墙14.1、查看防火墙状态1&gt; firewall-cmd --state 14.2、停止firewall1&gt; systemctl stop firewalld.service 14.3、禁止firewall开机启动1&gt; systemctl disable firewalld.service 十五、其他15.1、网段变更后，涉及IP地址更改 服务端：虚拟机网卡 &amp; DNS服务器IP地址 客户端：FTP服务器 &amp; Web服务器 &amp; Mysql服务器 &amp; 文件服务器 IP地址 十六、参考资料 异常处理_百度百科 十七、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/DevOps 自动化运维","date":"2019-03-12T06:57:56.864Z","updated":"2019-03-10T14:23:51.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/DevOps 自动化运维/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/DevOps 自动化运维/","excerpt":"","text":"[TOC] 一、前言本文讲述如何使用码云进行代码托管，并且使用阿里云 CodePipeline 服务构建并部署您托管在码云上的代码的过程。 大致步骤： 代码托管 - 构建触发器（编译 - 测试 - 打包） - 构建后部署到ESC 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 代码托管：码云 云服务器：阿里云 CentOS 7 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2019.03.10 1.0 ZZ 初稿 三、Paas 教程 阿里云 CodePipeline 服务 - 文档 四、参考文章 DevOps - 百度百科 你所在的公司是如何实施DevOps的？ 五、结语码云上面文档写的很详细，就不做赘言了~","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Windows系统）","date":"2019-03-12T06:57:56.864Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Windows系统）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Windows系统）/","excerpt":"","text":"[TOC] 一、前言本文记录了Java开发环境搭建与项目部署，以及日常应用过程中涉及到的常用命令和操作。测试环境：Windows10 系统。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.06 1.0 ZZ 初稿 2 2018.03.06 1.1 ZZ Git单独列出 三、JDK的安装及环境变量的配置 3.1、Java运行环境配置配置环境变量是为了让Java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 3.11、PATH环境变量作用是指定命令搜索路径，在shell下面执行命令时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把 jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如Javac/Java/Javadoc等，设置好 PATH变量后，就可以在任何目录下执行Javac/Java等工具了。 3.12、CLASSPATH环境变量作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPTH来寻找类的。我们需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，当然，当前目录“.”也必须加入到该变量中。 3.13、JAVA_HOME环境变量它指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。 3.14、永久配置方式Java_Home： C:\\Program Files\\Java\\jdk1.7.0_07 Path: %Java_Home%\\bin;%Java_Home%\\jre\\bin; 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找 3.15、临时配置方式(DOS)set path=%path%;C:\\Program Files\\Java\\jdk\\bin set classpath=XXX 注释：环境变量的配置已经完成，DOS命令下输入Java/Javac/Java –version检测。 3.16、补充几点如果没有定义环境变量classpath，Java启动JVM后，会在当前目录下查找要运行的类文件；如果指定了classpath，那么会在指定的目录下查找要运行的类文件。还会在当前目录找吗？两种情况： 如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。 如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。 一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。 四、Tomcat服务器的安装与部署4.1、搭建JavaWeb应用开发环境——Tomcat服务器Tomcat是一个实现了JAVA EE标准的最小的WEB服务器。 4.2、Tomcat的目录层次结构 Bin：存放启动和关闭Tomcat的脚本文件。 Conf：存放Tomcat服务器的各种配置文件。 Lib：存放Tomcat服务器的支持jar包 ogs：存放Tomcat的日志文件 Temp：存放Tomcat运行时产生的临时文件 Webapps：项目发布目录，存放web资源和java编译后的class文件 Works：Tomcat工作目录，存放jsp翻译后的的servlet和servlet编译后的class文件 4.3、Tomcat安装与配置4.31、把免安装版Tomcat解压包放到任意文件夹4.32、配置conf文件:server.xml connector端口号:8080(默认) charactor字符集:UFT-8 4.33、环境变量配置 Tomcat 7.x 会自动寻找位置，不需要环境变量配置。 JAVA 工具箱 1.0_ZZ.bat 为 了正确开闭服务所以配置了环境变量如下： CATALINA_HOME = D:\\apache-tomcat-7.0.70； 4.34、MyEclipse 配置 windouws–&gt;Preferences–&gt; TomCat 7.x 指定Tomca放置路径D:\\apache-tomcat-7.0.70。 指定JDK 版本为本项目应用版本。 4.35、开启Tomcat服务 Windows系统下，应用D:\\apache-tomcat-7.0.70\\bin 目录下批处理文件 startup.bat // 启动服务 shutdown.bat // 关闭服务 4.4、部署项目的几种方法4.41、静态部署4.411 利用Tomcat自动部署- 把JSP (war包) 放到Webapps容器中，启动服务 - 浏览器通过访问http://localhost:8080/news 注：Webapps目录是Tomcat默认的应用目录，当服务器启动时，会加载所有这个目录下的应用。 4.412 通过MyEclipse部署 部署按钮，编译源码生成Webapps容器中，启动服务 运行网页 http://localhost:8080/news/ 4.413 修改Server.xml文件部署一个Tomcat 值负责一个工程 1&lt;Context Path = \"/ItcastOA \" docBase = \"E:\\JAVA\\U100\\ItcastOA\\WebRoot\" reloadable = \"true\"/&gt; 热加载配置 –&gt; 修改java代码后，不用重新部署 拓展：jsp不用编译，故修改后自动更新 拓展：xml通过server.xml –&gt; autoDeploy=”true” 实现热加载 增加自定义web部署文件(推荐使用，不需要重启Tomcat ) 4.42 动态部署五、Mysql安装及配置 安装过程详见相关安装图解。 5.1 安装两个mysql数据库步骤安装时注意安装目录，数据目录和端口号不同即可。 六、Oracle安装及配置 安装过程详见相关安装图解。 七、SVN 安装及初始化操作 安装过程详见相关安装图解。根据需要安装客户端/服务端/SunEclipse插件 测试cmd–svn 服务器是否 七、Git 安装及初始化操作 详见 Git使用教程 八、Maven项目管理与配置九、mongoDB安装与配置十、JDBC 配置 、 Dom4j配置引入相关JAR包即可。 十一、参考资料 Tomcat部署Web应用方法总结 JavaWeb学习总结(二)–Tomcat服务器学习和使用(一) JavaWeb学习总结(三)–Tomcat服务器学习和使用(二) 十二、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Linux系统 ）","date":"2019-03-12T06:57:56.864Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Linux系统 ）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/服务器配置及开发环境搭建/Java 开发环境搭建及项目部署（Linux系统 ）/","excerpt":"","text":"[TOC] 一、前言本文记录了Java开发环境搭建与项目部署，以及日常应用过程中涉及到的常用命令和操作.。 测试环境：Deepin 15.5 发行版。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.18 1.0 ZZ 初稿 三、系统安装3.1、系统安装 详见深度科技社区主页 安装好deepin后，一定先要更新下，让系统保持更新。 1234// 更新整个仓库的版本信息sudo apt-get update// 后者是升级软件包sudo apt-get upgrade 3.2、安装后配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bash#先进到用户下载目录cd ~/Downloads#先更新一下sudo apt-get update &amp;&amp; sudo apt-get upgradesudo apt-get install wget curl#关闭开关机logo和不知道干嘛的设置（据说关闭之后会减少卡顿）gsettings set com.deepin.dde.startdde launch-welcome falsegsettings set com.deepin.dde.startdde swap-sched-enabled falsesudo plymouth-set-default-theme -R details # 修改开机logo为详细信息（个人喜好）#添加Chrome源到source.list.dwget -q -O - http://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo sh -c &apos;echo &quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google.list&apos;#添加VSCode源到source.list.dwget -q -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor - &gt; microsoft.gpgsudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpgsudo sh -c &apos;echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&apos;#添加Wine源到source.list.dwget -q -O - https://dl.winehq.org/wine-builds/Release.key | sudo apt-key add -sudo sh -c &apos;echo &quot;deb https://dl.winehq.org/wine-builds/debian/ DISTRO main&quot; &gt;&gt; /etc/apt/sources.list.d/winehq.list&apos;#卸载系统自带Flash（Chrome会自动更新的）sudo apt-get purge libflashplugin-pepperrm -rf ~/.config/google-chrome/PepperFlash/#卸载自带QQ（原因不解释，我喜欢TIM）sudo apt-get purge deepin.com.qq.im#安装软件sudo apt-get update &amp;&amp; sudo apt-get upgradesudo apt-get install google-chrome-stable #Chrome浏览器sudo apt-get install code #VSCodesudo apt-get install libappindicator3-1 #Lantern依赖，不安装的话会打不开蓝灯sudo apt-get install winehq-stable #wine deepin自带的那个有点旧sudo apt-get install python3.6 #安装Python3.6 系统中会共存2.7 3.5 3.6 通过python3.6 xxx调用sudo apt-get install qt5-qmake #安装qt5编译工具sudo apt-get install deepin.com.qq.office #安装TIMsudo apt-get install openjdk-8-jdk #安装openjdk8#安装Lantrenwget -q -O - https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer-64-bit.deb | sudo dpkg -i -#删除Chrome推荐设置sudo rm /etc/opt/chrome/policies/recommended/*.json#清理一下sudo apt-get autoremove --purge 四、JDK的安装及环境变量的配置4.1、压缩包安装 下载压缩包 jdk-7u13-linux-x64.tar.gz 新建一个文件夹，用作Java的安装目录。 12输入命令：cd /usr/输入命令：mkdir java 新建一个文件夹，用作Java的安装目录 拷贝下载好的压缩包到java文件夹下，并解压 1输入：tar -zxvf jdk-7u13-linux-x64.tar.gz 配置环境变量 1# vim /etc/profile 在最下面，添加一下内容 1234JAVA_HOME=/usr/java/jdk1.7.0_13PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 配置立即生效。 1# source /etc/profile 查看是否安装成功，出现下图相似的输出为安装成功。 1# java -version 注：装多个版本JDK时，按须配置。 4.2、Deepin应用商店安装。 安装过程略，不再支持JDK8以下。 4.3、IDEA安装安装IDEA时会默认安装JDK，并且Intellnj IDEA 2017启动不再支持JDK8以下。路径如下：1&gt; /usr/lib/jvm/java-1.8.0-openjdk-amd64 如果想使用JDK7，可以手动安装JDK7，不配置环境变量，然后手动配置SDKS路径。1&gt; /usr/java/jdk1.7.0_13 五、Tomcat服务器的安装与部署5.1、双Tomcat版 下载解压版Tomcat，放在相应目录，解压。 5.11、配置环境变量1# vim /etc/profile 首先要配置好JDK环境变量，如下所示：123456789101112131415# JAVAJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH# tomcat_1CATALINA_BASE_1=/home/zz/★软件安装★/apache-tomcat-7.0.70_1CATALINA_HOME_1=/home/zz/★软件安装★/apache-tomcat-7.0.70_1export CATALINA_BASE_1 CATALINA_HOME_1# tomcat_2CATALINA_BASE_2=/home/zz/★软件安装★/apache-tomcat-7.0.70_2CATALINA_HOME_2=/home/zz/★软件安装★/apache-tomcat-7.0.70_2export CATALINA_BASE_2 CATALINA_HOME_2 配置立即生效。1# source /etc/profile 5.12、修改catalina.sh / catalina.bat（Windows），在最后添加12# export CATALINA_HOME=$CATALINA_HOME_1# export CATALINA_BASE=$CATALINA_BASE_1 5.13、修改端口号修改apache-tomcat-7.0.70_发布的server.xml端口号为8888，8006，8010，并设置开机自启动； 5.14、启动1# sudo ./startup.sh 5.15、查看tomcat是否启动1# ps -ef|grep java 注：不需要手动启动时，须配置环境变量，IDE启动时配置startup.sh路径即可 六、Mysql安装及配置6.1、压缩包形式安装（推荐）6.2、在线安装（不推荐） 安装Mysql服务端（服务端） 1# sudo apt-get install mysql-server 安装MySQL客户端（客户端，根据情况） 1# sudo apt-get install mysql-client 安装chkconfig 1# sudo apt-get install chkconfig 将mysql加入到系统服务 1# chkconfig --add mysql 将mysql设置开机启动 1# chkconfig mysql on 开放远程登录权限（先root登录mysql），执行一下sql语句 12&gt; grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123&apos;;&gt; flush privileges; 开放3306端口 1# sudo /sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT; 开启防火墙 1// deepin默认没有防火墙 查看mysqld进程是否开启 1# pgrep mysqld / ps -ef | mysql 登录MySQL服务器 1mysql -h 192.168.2.100 -proot -u 其他 1234567891011121314// 手动启动数据库# sudo systemctl start mysql# sudo /etc/init.d/mysql start// 手动停止数据库# sudo systemctl stop mysql// 手动重启数据库# sudo systemctl restart mysql// 查看数据库运行状态# sudo systemctl status mysql// mysql 的是否处于listen状态# sudo netstat -tap | grep mysql// 卸载# sudo apt-get autoremove --purge mysql-server-5.7 七、Oracle安装及配置 略。 七、SQL Server安装及配置123# sudo apt-get install mssql-server mssql-tools密码：Yshow123@123端口：1433 [x] 详见 安装 SQL Server 并在 Ubuntu 上创建数据库 八、SVN 安装及初始化操作 安装过程详见相关安装图解。根据需要安装客户端/服务端/SunEclipse插件 九、Git 客户端操作 详见 Git使用教程 十、Maven项目管理与配置1IDEA 自带，不须单独安装 十一、Nginx安装配置11.1、源码编译安装11.11、安装gcc g++的依赖库12# sudo apt-get install build-essential# sudo apt-get install libtool 11.12、安装pcre依赖库123# sudo apt-get install libpcre3 libpcre3-dev// 查看pcre版本# sudo pcre-config --version 11.13、安装zlib依赖库1# sudo apt-get install zlib1g-dev 11.14、安装ssl依赖库1# sudo apt-get install openssl 11.15、安装 Nginx123456789// 下载 Nginx# sudo wget http://nginx.org/download/nginx-1.6.2.tar.gz# sudo tar zxvf nginx-1.6.2.tar.gz# cd nginx-1.6.2# sudo ./configure --prefix=/usr/local/webserver/nginx// 编译安装# sudo make install// 查看nginx版本# sudo /usr/local/webserver/nginx/sbin/nginx -v 11.2、Nginx的配置11.21、配置nginx.conf vim /usr/local/webserver/nginx/conf/nginx.conf [x] 参考：Nginx安装配置 11.3、启动 Nginx1# sudo /usr/local/webserver/nginx/sbin/nginx 11.4、访问测试1&gt; http://localhost/项目名 十二、参考资料 deepin下mysql的卸载和重装 11个Linux上最佳的图形化Git客户端 Deepin下安装nginx 十三、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/利用Jenkins进行持续集成的实践","date":"2019-03-12T06:57:56.852Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/利用Jenkins进行持续集成的实践/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/持续集成及自动化运维/利用Jenkins进行持续集成的实践/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用Jenkins 搭建自动化 CI/CD 流水线。以实现软件服务的快速迭代。测试环境：Centos 7 。 Jenkins 可实现如下功能： 持续集成Continuous Integration 持续交付Continuous Delivery 持续部署Continuous Deployment 自动化测试（可集成脚本或自动化平台） 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.05 1.0 ZZ 初稿 2 2018.03.14 1.0 ZZ 补充完整 三、概念解析3.1、持续集成持续集成（Continuous integration，简称CI）指的是，频繁地（一天多次）将代码集成到主干。 3.2、持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。 3.3、持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 四、持续集成部署图五、部署过程5.1、前期准备 安装JDK1.7及以上； 安装Git进行版本控制； 安装Maven进行项目构建，jar包管理； 搭建Nexus私服。 Maven jobs and Java versions compatibility 123Jenkins &gt;= 1.520 requires Java 6 thus Maven jobs must be launched with Java &gt;= 6.Jenkins &gt;= 1.612 requires Java 7 thus Maven jobs must be launched with Java &gt;= 7.Jenkins &gt;= 2.54 requires Java 8 thus Maven jobs must be launched with Java &gt;= 8. 5.2、Jenkins安装5.21、War包安装 Jenkins官方网站 - 下载地址 把解压得到的war包直接扔到tomcat下，启动tomcat。访问 http://localhost:8080/jenkins 5.22、Centos下的安装5.221、安装123# wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo# rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key# yum install jenkins 5.222、配置jdk安装路径12# whereis java --&gt; /usr/lib/jvm/java-1.8.0-openjdk-amd64# vim /etc/init.d/jenkins 在candidates中第一行添加java路径，如下：123456789candidates=\"/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java\" 5.223、修改端口号，默认808012# cd# java -jar jenkins.war –httpPort=18080 –ajp13Port=18009 5.224、其他命令1234// 停止/启动# service jenkins start [stop]/[restart]// 加入开机启动# chkconfig jenkins on 5.3、Jenkins安装5.31、访问 http://localhost:8080/jenkins/ 第一次启动时，会要求设置初始密码，如下图所示，找到密码并输入 七、拓展阅读八、参考资料 持续集成是什么？ Jenkins持续集成文档 [x] Jenkins 持续集成综合实战 [x] Nexus搭建私有Maven仓库 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx安装配置","date":"2019-03-12T06:57:56.836Z","updated":"2019-01-21T13:49:25.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx安装配置/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx安装配置/","excerpt":"","text":"[TOC] 一、前言Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。Nginx作为反向代理服务器，可以对Web服务器提供加速，并且具有负载均衡的功能。本文主要介绍了Nginx安装及配置，测试环境为Centos 7 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.11 1.0 ZZ 初稿 三、Nginx的安装 nginx 官网 nginx - GitHub 3.1、源码编译安装3.11、安装gcc g++的依赖库，zlib依赖库，ssl依赖库1# yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 3.12、安装 PCRE依赖库PCRE 作用是让 Nginx 支持 Rewrite 功能。123456789101112# cd /usr/local/src// 下载PCRE安装包# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz// 解压安装包# tar zxvf pcre-8.35.tar.gz// 进入安装包目录# cd pcre-8.35// 编译安装# ./configure# make &amp;&amp; make install// 查看pcre版本# pcre-config --version 3.13、安装 Nginx123456789// 下载 Nginx# wget http://nginx.org/download/nginx-1.6.2.tar.gz# tar zxvf nginx-1.6.2.tar.gz# cd nginx-1.6.2# ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35// 编译安装# make &amp;&amp; make install// 查看nginx版本# /usr/local/webserver/nginx/sbin/nginx -v 三、Nginx的配置3.1、配置nginx.conf vim /usr/local/webserver/nginx/conf/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#开启进程数 &lt;=CPU数worker_processes 1;#错误日志保存位置#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#进程号保存文件#pid logs/nginx.pid;#等待事件events &#123; #每个进程最大连接数（最大连接=连接数x进程数） worker_connections 1024;&#125;http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #日志文件输出格式 这个位置相于全局设置 #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #请求日志保存位置 #access_log logs/access.log main; #打开发送文件 sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 65; ##缓存cache参数配置## proxy_connect_timeout 5; #跟后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_read_timeout 60; #连接成功后_等候后端服务器响应的时间_其实已经进入后端的排队之中等候处理 proxy_send_timeout 5; #后端服务器数据回传时间_就是在规定时间内后端服务器必须传完所有数据 proxy_buffer_size 16k; #代理请求缓存区_这个缓存区间会保存用户的头信息以供Nginx进行规则处理_一般只要能保存下头信息即可 proxy_buffers 4 64k; #同上 告诉Nginx保存单个用的几个Buffer最大用多大空间 proxy_busy_buffers_size 128k; #如果系统很忙的时候可以申请更大的proxy_buffers 官方推荐*2 proxy_temp_file_write_size 128k; #proxy缓存临时文件的大小 proxy_temp_path /home/zz/data/nginx/temp; #用于指定本地目录来缓冲较大的代理请求 proxy_cache_path /home/zz/data/nginx/cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g; #设置web缓存区名为cache_one,内存缓存空间大小为12000M，自动清除超过15天没有被访问过的缓存数据，硬盘缓存空间大小200g #压缩配置 # gzip on; #打开gzip压缩功能 gzip_min_length 1k; #压缩阈值 gzip_buffers 4 16k; #buffer 不用修改 gzip_comp_level 2; #压缩级别:1-10，数字越大压缩的越好，时间也越长 gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #压缩文件类型 gzip_vary off; #跟Squid等缓存服务有关，on的话会在Header里增加 \"Vary: Accept-Encoding\" gzip_disable \"MSIE [1-6]\\.\"; #IE1-6版本不支持gzip压缩 #具体的服务器地址及端口号，该处可以配置集群实现负载均衡，cluster为服务器集群名 upstream cluster &#123; #这里指定多个源服务器，ip:端口,80端口的话可写可不写 server 127.0.0.1:80 weight=5 max_fails=2 fail_timeout=600s; #weigth参数表示权值，权值越高被分配到的几率越大，max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查，fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器 &#125; # nginx服务器,即代理服务器 server &#123; listen 80; #监听IP端口 server_name localhost; #服务器名 #charset utf-8; #设置字符集 #access_log logs/host.access.log main; #本虚拟server的访问日志 相当于局部变量 #动态请求代理给相应服务器 location / &#123; root /home/www; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 if ($request_filename ~* ^.*?.(js|html|css)$)&#123; #js css html 文件不缓存 add_header Cache-Control no-cache; &#125; if ($request_filename ~* ^.*?.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|jpg|png)$)&#123; # add_header Cache-Control max-age=864000; #缓存一天 expires 7d; &#125; #proxy_pass http://localhost:80; #proxy_pass http://cluster; #请求转向cluster定义的服务器列表 #proxy_redirect off; #proxy_set_header Host $host; #proxy_set_header X-Forwarded-For $remote_addr; &#125; #purge插件缓存清理 location ~ /purge(/.*) &#123; allow 127.0.0.1; #能够清除缓存的服务器IP地址 deny all; proxy_cache_purge cache_one $1$is_args$args; &#125; location /upload &#123; alias e:/upload; &#125; # 开启nginx的监控 location /NginxStatus &#123; stub_status on; access_log off; #allow 192.168.0.3; #deny all; #auth_basic \"NginxStatus\"; #auth_basic_user_file conf/htpasswd; &#125; # 定义错误提示页面 #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; #代理http跳转https这块配置 server &#123; listen 443 ssl; server_name localhost; ssl on; ### SSL log files ### access_log logs/ssl-access.log; error_log logs/ssl-error.log; ### SSL cert files ### ssl_certificate ../../cert/server.crt; ssl_certificate_key ../../cert/server.key; #ssl_session_cache shared:SSL:1m; #ssl_session_timeout 5m; #ssl_ciphers HIGH:!aNULL:!MD5; #ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://cluster; ### force timeouts if one of backend is died ## proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; ### Set headers #### proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; ### Most PHP, Python, Rails, Java App can use this header ### proxy_set_header X-Forwarded-Proto https; ### By default we don't want to redirect it #### proxy_redirect off; &#125; &#125;&#125; 检查配置文件ngnix.conf的正确性1# /usr/local/webserver/nginx/sbin/nginx -t 3.2、启动 Nginx1# /usr/local/webserver/nginx/sbin/nginx 3.3、访问站点 访问 http://www.lapland.top，返回tomcat默认页面，如下： 访问 http://ip/NginxStatus，返回如下：1234Active connections: 1server accepts handled requests380 380 30079Reading: 0 Writing: 1 Waiting: 0 3.4、Nginx 其他命令123456// 重新载入配置文件# /usr/local/webserver/nginx/sbin/nginx -s reload// 重启 Nginx# /usr/local/webserver/nginx/sbin/nginx -s reopen//停止 Nginx# /usr/local/webserver/nginx/sbin/nginx -s stop 和1234// 查询nginx主进程号# ps -ef | grep nginx// 强制停止Nginx# pkill -9 nginx 七、拓展阅读 Windows 下Nginx的安装和配置 Nginx+Tomcat实现动静分离、负载均衡 八、参考资料 [x] Nginx 安装配置 [x] Linux(CentOS)下设置nginx开机自动启动（2个办法） [x] tomcat 与 nginx，apache的区别是什么？ [x] Windows安装nginx服务 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx的负载均衡方案详解","date":"2019-03-12T06:57:56.836Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx的负载均衡方案详解/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx的负载均衡方案详解/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx+Tomcat实现动静分离、负载均衡","date":"2019-03-12T06:57:56.820Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx+Tomcat实现动静分离、负载均衡/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/Nginx/Nginx+Tomcat实现动静分离、负载均衡/","excerpt":"","text":"[TOC] 一、前言本文主要介绍了Nginx配合Tomcat的实现JavaWeb项目动静分离配置实例，测试环境为Centos 7。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.13 1.0 ZZ 初稿 七、拓展阅读 [x] Nginx安装配置 八、参考资料 [x] 百度搜索 - Nginx + Tomcat 动静分离 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/云计算/云计算是什么？","date":"2019-03-12T06:57:56.808Z","updated":"2019-03-11T06:19:01.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/云计算/云计算是什么？/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/云计算/云计算是什么？/","excerpt":"","text":"-[x]云计算是啥？近年来云发展了什么？云计算简史！","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/内外网隔离数据实时交互方案","date":"2019-03-12T06:57:56.800Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/内外网隔离数据实时交互方案/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/内外网隔离数据实时交互方案/","excerpt":"","text":"详见 内外网隔离数据实时交互方案","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/ArcGIS安装配置","date":"2019-03-12T06:57:56.800Z","updated":"2018-11-28T08:32:36.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/ArcGIS安装配置/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC05 项目配置 & 运维 & 容器化/ArcGIS安装配置/","excerpt":"","text":"一、 简介地理信息系统( Geographic Information System, 简称 GIS )是能提供存储、显示、分析地理数据功能的软件。主要包括数据输入与编辑、数据管理、数据操作以及数据显示和输出等。作为获取、处理、管理和分析地理空间数据的重要工具、技术和学科，得到了广泛关注和迅猛发展。 从技术和应用的角度， GIS 是解决空间问题的工具、方法和技术;从学科的角度， GIS 是在地理学、地图学、测量学和计算机科学等学科基础上发展起来的一门学科，具有独立的学科体系; 从功能上， GIS 具有空间数据的获取、存储、显示、编辑、处理、分析、输出和应用等功能;从系统学的角度， GIS 具有一定结构和功能，是一个完整的系统。 简而言之， GIS 是一个基于数据库管理系统( DBMS )的管理空间对象的信息系统，以地理数据为操作对象的空间分析功能是地理信息系统与其它信息系统的根本区别。 二、地图服务器配置2.1、IIS Web Server 作为地图服务器2.2、Tomcat 作为地图服务器 略 2.3、部署离线地图三、安装配置ArcGIS API3.1、配置路径 拷贝arcgis_js_api文件夹到地图服务器目录下(本机为D:\\Web) 打开D:\\Web\\arcgis_js_api\\library\\3.14\\3.14\\init.js，打开D:\\Web\\arcgis_js_api\\library\\3.14\\3.14\\dojo\\dojo.js找到其中的[HOSTNAME_AND_PATH_TO_JSAPI],替换为localhost/arcgis_js_api/library/3.14/3.14 3.2、测试-11234567891011121314151617181920212223242526272829303132&lt;!--静态缓存地图--&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Simple Map&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/arcgis_js_api/library/3.14/3.14/dijit/themes/tundra/tundra.css\" /&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/arcgis_js_api/library/3.14/3.14/esri/css/esri.css\" /&gt;&lt;script type=\"text/javascript\" src=\"http://localhost/arcgis_js_api/library/3.14/3.14/init.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; dojo.require(\"esri.map\"); function init() &#123; var myMap = new esri.Map(\"mapDiv\"); var myTiledMapServiceLayer = new esri.layers.ArcGISTiledMapServiceLayer(\"http://server.arcgisonline.com/ArcGIS/rest/services/NGS_Topo_US_2D/MapServer\"); myMap.addLayer(myTiledMapServiceLayer); &#125; dojo.addOnLoad(init);&lt;/script&gt;&lt;/head&gt;&lt;body class=\"tundra\"&gt; &lt;div id=\"mapDiv\" style=\"width:900px; height:600px; border:1px solid #000;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.3、测试-2官方测试代码给出的地图服务是缓存地图，如果地图服务是动态地图话需要使用动态图层ArcGISDynamicMapServiceLayer才能显示。 12","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/SQL语句优化/SQL语句性能优化","date":"2019-03-12T06:57:56.796Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL语句优化/SQL语句性能优化/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL语句优化/SQL语句性能优化/","excerpt":"","text":"[TOC] 一、前言目前参加的项目在处理大数据量的查询时，遇到了效率问题，后来在不断探索优化下得到了优化改善，现将优化思路和解决策略总结如下。 提高数据库检索速度的几个方案：1、优化SQL语句2、使用全文索引3、使用搜索引擎 建立索引的方法论为： 1、多数查询经常使用的列2、很少进行修改操作的列3、索引需要建立在数据差异化大的列上 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.10.30 1.0 ZZ 初稿 三、提高数据库检索速度的几个方案3.1、优化SQL语句1、建立索引/主键，查询时是否都利用到了索引/主键。2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。3、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，一个表的索引最多不超过6个。4，多加条件约束，多用and，尽量把要查的东西精确定位出来，少用like in这样的语句；5，越少列越好，查询结果尽量要那些字段就查那些字段，少用*，查询全部，查询一列，比查询全部要快很多。6、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。7、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。8、尽可能的使用 varchar/nvarchar 代替 char/nchar9、尽量避免左模糊查询，like/ in / not in 也要慎用，否则会导致全表扫描10、对于连续的数值，能用 between 就不要用 in 了，不连续数值用 exists 代替 in 是一个好的选择：11、如果在 where 子句中使用参数，进行表达式操作,进行函数操作也会导致全表扫描。可以改为强制查询使用索引1select id from t with(index(索引名)) where num=@num 12、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。13、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。可以在num上设置默认值0。14、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 3.2、使用全文索引 目前只有MySQL5.7支持全文索引 12mysql&gt; select version(); 或mysql&gt; status; 跟普通索引稍有不同，使用全文索引的格式： MATCH (columnName) AGAINST (‘string’) 1SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;) 当查询多列数据时，建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。 1SELECT * FROM `student` WHERE MATCH(`name`,`address`) AGAINST(&apos;聪 广东&apos;) 3.3、使用搜索引擎 详见：搜索引擎Solr的配置和使用 八、参考资料 [x] SQL语句优化 [x] MySQL使用全文索引(fulltext index) [x] mysql explain用法和结果的含义 [x] MySQL高级 之 explain执行计划详解","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/SQL语句优化/索引","date":"2019-03-12T06:57:56.796Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL语句优化/索引/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL语句优化/索引/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计步骤及示例","date":"2019-03-12T06:57:56.792Z","updated":"2018-11-28T09:06:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计步骤及示例/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计步骤及示例/","excerpt":"","text":"[TOC] 一、前言本文记录了一个实际项目的数据库设计流程。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.11.27 1.0 ZZ 初稿 三、数据库设计的基本步骤1）需求分析分析用户的需求，包括数据、功能和性能需求。 2）概念结构设计主要采用E-R模型进行设计，包括画E-R图。 3）逻辑结构设计通过将E-R图转换成表，实现从E-R模型到关系模型的转换。 4）物理结构设计主要是为所设计的数据库选择合适的存储结构和存取路径。 5）数据库实施包括编程、测试和试运行。 6）数据库的运行和维护系统的运行与数据库的日常维护。 3.1、文档样例 列名 数据类型 允许空值 自动编号 约束 说明 id int(11) not null auto PK 编号 category_id int(11) not null FK 分类编号 category_name varchar(50) not null 分类名称 title varchar(200) not null index 标题 description text null 使用说明 六、相关术语七、拓展阅读八、参考资料 异常处理_百度百科 九、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库设计基础/MySql基本语法学习","date":"2019-03-12T06:57:56.792Z","updated":"2018-11-28T09:24:32.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/MySql基本语法学习/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/MySql基本语法学习/","excerpt":"","text":"[TOC] 一、前言本文整理了MySql语句的使用方法，以备查询。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.11.28 1.0 ZZ 初稿 三、基本DOS命令操作 开启服务 1234方法一 : services.msc方法二 : DOS ctrl+shift+cmd 以管理员身份运行cmd net start mysql 开启服务 登陆: 12345678910111213mysql -uroot -pzz （密码zz）mysql -h192.168.0.110 -uroot -pzzmysql -uroot -p --&gt; Enter password: ***mysql&gt; USE bdqn; 选择数据库 SELECT * FROM Demo1; SELECT * FROM Demo1\\G; 格式化输出 SET NAMES utf8; 设置当前客户端的字符集 UPDATE USER SET PASSWORD=PASSWORD(\"zz\") WHERE USER=\"root\"; 修改密码 GRANT SELECT ON day16.employee TO 'eric'@'localhost' IDENTIFIED BY '123456'; 分配权限账户 ? 显示帮助 EXIT 退出 \\c 清理 -备份数据库1234567891011mysqldump -uroot -pzz quary_demo student &gt;i:/quary_demo_backup.sql # -h 主机名 # 仅备份和恢复 studentmysqldump -help# 常用参数:# --add-drop-table / --add-skip-add-drop-table # 删除drop语句# --add-lock # 锁定语句# -t / --no-create-info # 表已存在,不再创建,仅备份数据# -c / --complete-insert # 表结构修改,重建表,并备份# -d / --no-data # 仅备份表结构# --where '' # 选择性备份# --opt # 同时添加参数集(制定) 恢复数据库123456789mysql -uroot -pzz quary_demo &lt;i:/quary_demo_backup.sql或mysql -uroot -pzzuse quary_demosource i:/quary_demo_backup.sql或mysql -uroot -pzz # 提取特殊格式文本--备份导入select subjectname,classhour,gradeid into outfile 'i:/abc_backup.sql' from subject; # 提取文本 load data infile 'i:/abc_backup.sql' into table subject(subjectname,classhour,gradeid); # 导入文本 四、常用语句汇总12345678910111213141516171819USE DATABASE;SHOW TABLE;DROP DATABASE `dbqn`;DROP TABLE `bdqn`.`damo1`;TRUNCATE Demo1;CREATE databas `bdqn`;CREATE TABLE 'bdqn'(`Id` INT (4) UNSIGNED ZEROFILL AUTO_INCREMENT COMMENT '主键', PRIMARY KEY (`Id`));ALTER tabel `表名` 操作 `操作对象`;ALTER TABLE `demo1` RENAME AS `demo2`;ALTER TABLE Demo1 DROP `sex`;SELECT * FROM `demo1`;SELECT `name` FROM `demo1` INNER JOIN `demo2` ON demo1.id = demo2.id GROUP BY `sex` HAVING `id`&lt;5 ORDER BY demo1.id ASC LIMIT 0,5;INSERT INTO `demo1`(`gread`,`id`)VALUES('大三',3),('大三',2);UPDATE `demo1` SET `time` = 10 WHERE `id `= 1; 五、CRUD 增删改查 DDL / DML / DQL / DCL = 数据定义 / 数据操作 / 数据查询 / 数据删除 5.1、DDL数据库12345678910111213# 光标在哪一行就会执行那一句语句 F9SHOW DATABASES; # 查看数据库STATUS; # 查看数据库属性DROP DATABASE bdqn; # 删除数据库;DROP DATABASE IF EXISTS `bdqn`;CREATE DATABASE `bdqn`; # 新建数据库CREATE DATABASE IF NOT EXISTS `bdqn`;CREATE DATABASE `bdqn` CHARACTER SET gbk COLLATE gbk_chinese_ci;USE bdqn; # 使用数据库SHOW TABLES; # show 该数据库内所有表 5.2、DML表格123456789101112131415161718192021222324252627282930DESC `Demo1`; # 查看表的结构SHOW CREATE TABLE `Demo1`\\G; # 查看创建表的语句,并格式化输出DROP TABLE `bdqn`.`Demo1`; # 删除表格RENAME TABLE `bdqn`.`text1` TO `bdqn`.`Demo1`; # 表格重命名ALTER TABLE demo3 RENAME AS demo1; # 数据库名称无法改变CREATE TABLE `Demo1`( # ★ 创建表,定义字段 `Id` INT (4) UNSIGNED ZEROFILL AUTO_INCREMENT COMMENT '主键', # 数据类型属性 zerofill 默认unsigned `Name` VARCHAR(4) DEFAULT '匿名', `Age` TINYINT(4), # -128~127, #int(4)最少占四位 char(4)最多四位 `bornDate` TIMESTAMP DEFAULT NOW(), # TIMESTAMP时间戳 , new()不支持 DATETIME # 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 PRIMARY KEY (`Id`) # 集中定义约束)ENGINE = MYISAM # 数据表类型 INNODB --事物处理 增删改,MYISAM --全文索引 查询DEFAULT CHARSET = utf8 COLLATE = utf8_general_ciAUTO_INCREMENT = 100 COMMENT = '用户表'; # 主键从100开始 # Duplicate entry '127' for key 1 报错,自增不能超过数据范围ALTER TABLE Demo1 AUTO_INCREMENT = 200; # 已存在表格主键从200开始 //create时加``SET auto_increment_increment = 5; # 自动增长+5 ,影响全部 auto_incrementDELETE FROM Demo1; # 清空字段内容, 自增不会重新开始TRUNCATE Demo1; # 清空字段内容, 自增重新开始ALTER TABLE Demo1 ADD `Sex` VARCHAR(4) DEFAULT '男'; # ★ 新增字段ALTER TABLE Demo1 DROP `sex`; # 删除字段,不区分大小写ALTER TABLE Demo1 MODIFY `Name` VARCHAR(6) ; # 修改字段ALTER TABLE Demo1 CHANGE `Name` `userName` VARCHAR(5) DEFAULT '匿名'; # 字段更名及修改字段ALTER TABLE Demo1 ADD CONSTRAINT pk_demo1 PRIMARY KEY(Id); #定义主键ALTER TABLE Demo1 ADD CONSTRAINT fk_demo1_demo2 FOREIGN KEY(Id) REFERENCES demo2(Id); #定义外键 5.3、DML表格1234567891011121314151617181920212223242526TRUNCATE demo3;CREATE TABLE Demo3(`Id` INT(4),`Gread` VARCHAR(4));INSERT INTO Demo3 VALUES(1,'大一'); # ★ 新增字段内容INSERT INTO Demo3(id) VALUES(2);INSERT INTO Demo3(`gread`,`id`) VALUES('大三',3),('大二',2);ALTER TABLE Demo3 MODIFY id INT(4) PRIMARY KEY AUTO_INCREMENT; # 修改字段属性ALTER TABLE Demo3 ADD `Sex` VARCHAR(4) DEFAULT '男'; # 新增字段(表已经定义过后的新增)INSERT INTO Demo3 (`Gread`,`Sex`)VALUES('大四',DEFAULT),('研一','女'); # 定义主键自增后可不用定义id字段ALTER TABLE Demo3 ADD `Time` INT(4) DEFAULT 0;UPDATE Demo3 SET `time` = 10; # ★ 修改字段内容 (字段已经定义过后的修改)UPDATE Demo3 SET `time` = `time` + 10; # 自增运算UPDATE Demo3 SET gread = CONCAT('准',gread); # 可以用 MySql 函数 COUNT(1)等UPDATE Demo3 SET `time` = 60 WHERE gread = '准大四' &amp;&amp; sex = '男'; # 条件判断(and) ,结合 SET 使用UPDATE Demo3 SET gread = '博士' WHERE gread = '准大四';ALTER TABLE Demo3 ADD `Scord` CHAR(6) DEFAULT '及格' ;UPDATE Demo3 SET `scord` = 'lowBee' WHERE id &lt; 2 || `gread` = '博士'; # 条件判断(or)DELETE FROM Demo3 WHERE id = 4; # ★清空字段内容,自增不会重新开始TRUNCATE Demo3; # 完全清空字段内容, 自增重新开始 5.4、DQL表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879SELECT *FROM student; # 不建议使用 *SELECT stu.`StudentNo`,stu.`StudentName`,stu.`Phone` FROM student AS stu; # 筛选表单元素SELECT stu.`StudentNo` AS 编号,stu.`StudentName` AS 姓名,stu.`Phone` AS 电话 FROM student AS stu; # 重命名筛选输出信息SELECT DISTINCT r.`SubjectNo`,r.`StudentNo` FROM result r; # 去除重复数据,条件同时满足SELECT auto_increment_increment; # 查询属性-自增SELECT s.`ClassHour` 旧课时,s.`ClassHour`+10 新课时 FROM `subject` s; # 通过别名,更改特殊符号的显示SELECT s.`SubjectName` 课程名称,s.`ClassHour` 总课时,s.`ClassHour`/10 '平均课时/10' FROM `subject` s; # 练习# is null,is not null,between and,SELECT * FROM student WHERE studentname LIKE '张三'; # 完全匹配SELECT * FROM student WHERE studentname LIKE '张%'; # Like 用法 '%'SELECT * FROM student WHERE studentname LIKE '张_'; # 当单字符占位符 '_'SELECT * FROM student WHERE studentname LIKE '%:%%' ESCAPE ':'; # 定义':'为转义字符SELECT * FROM result r WHERE r.`StudentResult` IN (80,90,100); # 选择项筛选# 多表连接查询 = 内连接 + 外连接(左外,右外) # 内连接可获取两表的公共部分的记录 --&gt; ★ SELECT xxx FROM |左表| INNER JOIN |右表| ON |左列|=|右列| WHERE 附加条件 ★# 左外连接是以左边表中的数据为基准，若左表有数据右表没有数据，则显示左表中的数据右表中的数据显示为空。右外连接类似SELECT subjectname,gradename FROM `subject` INNER JOIN `grade` ON subject.`GradeID` = grade.`GradeID`; # 内连接SELECT subjectname,gradename FROM `subject`,`grade` WHERE subject.`GradeID` = grade.`GradeID`; # 等值查询,等效于内连接/SELECT student.`StudentNo`'学号',studentname'姓名',studentresult'成绩' FROM student INNER JOIN resultON student.`StudentNo` = result.`StudentNo` WHERE student.`StudentNo`&gt;1015; # 内连接举例SELECT student.`StudentNo`'学号',studentname'姓名',studentresult'成绩' FROM student,resultWHERE student.`StudentNo` = result.`StudentNo` AND student.`StudentNo`&gt;1015; # 等值查询举例,等效于内连接/SELECT student.`StudentNo`'学号',studentname'姓名',studentresult'成绩' FROM student LEFT OUTER JOIN resultON student.`StudentNo` = result.`StudentNo` WHERE student.`StudentNo`&gt;1015; # 左外连接(左列完整显示) (右外类似)SELECT student.`StudentNo`'学号',studentname'姓名',studentresult'成绩' FROM student,result # 两表的笛卡尔乘积# 自身连接查询(使用层级关系设计表格,方便层级关系变动)SELECT c1.categoryname,c2.categoryname FROM `category` c1 INNER JOIN `category` c2ON c2.pid = c1.categoryidORDER BY c1.categoryname ASC; # order by 排序 # desc 降序排列# 分页显示SELECT studentno,studentname,phone FROM student ORDER BY studentno ASC LIMIT 5,10; #从6开始,每页10条 # 从0起始# 子查询(where 条件,又嵌套查询语句)# 例程:高等数学-2,且分数不小于80的学生的姓名和学号# 分析:输出信息出自两个表格, 利用 SubjectName 限制输出内容SELECT s.`StudentNo`,s.`StudentName`,r.`StudentResult`FROM student s INNER JOIN result r ON s.`StudentNo` = r.`StudentNo`WHERE r.`SubjectNo` =(SELECT k.`SubjectNo`FROM `subject` k WHERE k.`SubjectName` = '高等数学-2')AND r.`StudentResult`&gt;80ORDER BY studentresult DESC LIMIT 0,5; # Limit 分页查询# 几个常用函数SELECT COUNT(studentno) 学生总数 FROM s tudent; # 定义计数器,并定义显示结果,student集合, where 限制SELECT CONCAT('学生:',studentName) 姓名 ,phone 电话 FROM student; # 对输出结果进行处理并输出SELECT VERSION(); # 查询版本号 # sum(),avg(),max(),min()# groud by 分组&amp; having 隐藏# 例程: 按照不同课程分组,并算出最高分,最低分,平均分,平均分低于80的科目不予显示SELECT COUNT(r.`StudentNo`)'总条数', MAX(r.`StudentResult`)'最高分', MIN(r.`StudentResult`)'最低分', AVG(r.`StudentResult`)'平均分', r.subjectno '科目代码' # 一旦分组,select后只可增加分组条件项FROM result rGROUP BY R.`SubjectNo` # 分组条件HAVING AVG(r.`StudentResult`)&gt;=80 # 平均分低于80的科目不予显示ORDER BY AVG(r.`StudentResult`) DESC; 六、MySql 事务处理12345678910111213141516# 只支持InnoDB和DBD数据表类型# 事务:一批语句同时成功,才算成功,否则全部取消# 事务的ACID原则:# 1.原子性:事务整体不可再分.# 1.一致性:数据保持前后一致.# 1.隔离性:事务之间互不影响(锁).# 1.持久性:物理持久保存.SET autocommit = 0; # 使用事务前应关闭自动提交,默认开启START TRANSACTION; # 开启事务,STARTA之后,roll/ccomm之前为一个事务UPDATE Demo3 SET `time` = `time` + 10;ROLLBACK; # 回滚 ,提交后便不能回滚COMMIT ; # 提交事务SET autocommit = 1 ; # 还原自动提交(工作中不用关闭) 七、MySQL的索引和备份12345678910111213141516171819202122232425262728293031323334353637383940# 主键索引 primary key 只能有一个主键# 唯一索引 unique key 主要作用为约束,可有多个唯一索引# 常规索引 index# 全文索引 fulltext 仅用于MyISM数据表,检索字符类型数据,适应大型数据集# 不要对经常改动的数据加索引,不要对小数据量加索引# 索引一般加查询比较多的地方CREATE TABLE `text`(# 定义索引 a INT PRIMARY KEY, b CHAR(5) UNIQUE, c INT, d,INT, KEY`index_cd`(`c`,`d`) # 常规索引联合定义 # 索引后剩最少数据的,放在前面 INDEX `index_c`(`c`) # 常规索引单个定义 studentname CHAR(10), # PRIMARY KEY(`a`) # 单独定义索引 # UNIQUE KEY 'index_b'(`b`) # INDEX KEY `index_c`(`c`) # FULLTEXT(`studentname`));# 添加索引 # ALTER TABLE student ADD PRIMARY KEY(`StudentNo`); # 修改表时添加索引 # ALTER TABLE student ADD UNIQUE INDEX(StudentName); # ALTER TABLE student ADD INDEX (StudentName); # ALTER TABLE student ENGINE=MYISAM; #先修改为MyISAM类型数据表 # ALTER TABLE student ADD FULLTEXT(StudentName); #select * from `text` where match(`studentname`) against (`love`); # 使用全文索引检索# 删除索引 DROP INDEX `index_b` ON `text` ALTER TABLE `text` DROP INDEX ` index_b` ALTER TABLE `text` DROP INDEX PRIMARY KEY# 查看索引 SHOW INDEX FROM `text` # 或 SHOW KEY FROM `text` 八、外键 &amp; 级联操作1234567891011# 被约束的表称为副表，约束别人的表称为主表，外键设置在副表上，主表的参考字段通用为主键# 当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表。# 当我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现。CONSTRAINT emlyee_dept FOREIGN KEY(deptId) REFERENCES dept(id)ON UPDATE CASCADE # 级联修改ON DELETE CASCADE # ON DELETE CASCADE# 添加数据： 先添加主表，再添加副表# 修改数据： 先修改副表，再修改主表# 删除数据： 先删除副表，再删除主表 九、触发器12345# 被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的# 当操作了某张表时，希望同时触发一些动作/行为，可以使用触发器完成CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW # 当向员工表插入一条记录时，希望同时往日志表插入数据INSERT INTO test_log(content) VALUES('员工表插入了一条记录'); 十、存储过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 存储过程就是带有逻辑的sql语句DELIMITER $ # 声明存储过程的结束符CREATE PROCEDURE findById(IN eid INT) # 存储过程名称(参数列表)CREATE PROCEDURE pro_testOut(OUT str VARCHAR(20))CREATE PROCEDURE pro_testInOut(INOUT n INT)CREATE PROCEDURE pro_testIf(IN num INT,OUT str VARCHAR(20))CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )BEGIN # 开始 SELECT * FROM employee; # 可以写多个sql语句+流程控制 SET str='hellojava'; # 带有条件判断的存储过程 IF num=1 THEN SET str='星期一'; ELSEIF num=2 THEN SET str='星期二'; ELSEIF num=3 THEN SET str='星期三'; ELSE SET str='输入错误'; END IF; # 带有循环功能的存储过程 DECLARE i INT DEFAULT 1; # 定义一个局部变量 DECLARE vsum INT DEFAULT 0; WHILE i&lt;=num DO SET vsum = vsum+i; SET i=i+1; END WHILE; SET result=vsum; SELECT empName INTO vname FROM employee WHERE id=eid;END $ # 结束 结束符# 调用CALL findById(4); # 执行存储过程，CALL 存储过程名称(参数);CALL pro_testIf(4,@str);SELECT @@str; # 查看某个全局变量CALL pro_testWhile(100,@result);SELECT @result; # 查看会话变量CALL pro_findById2(1,@NAME);SELECT @NAME;DROP PROCEDURE pro_testOut; # 删除存储过程 十一、三大范式 第一范式： 要求表的每个字段必须是不可分割的独立单元错误实例：顾客表(姓名、编号、地址…)其中”地址”列还可以细分为国家、省、市、区等。 第二范式： 在第一范式的基础上，确保表中的每列都和主键相关错误实例：订单表(订单编号、产品编号、定购日期、价格…)，”订单编号”为主键，”产品编号”和主键列没有直接的关系，即”产品编号”列不依赖于主键列，应删除该列。 第三范式： 在第二范式基础，要求每一个表都不包含其他表信息(外键除外)，确保每列都和主键列直接相关,而不是间接相关错误实例：员工表： 员工编号（主键） 员工姓名 部门编号 部门名 十二、参考资料 百度百科 十三、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计规范","date":"2019-03-12T06:57:56.784Z","updated":"2018-11-28T09:11:29.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计规范/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/数据库设计规范/","excerpt":"","text":"[TOC] 一、前言为了使数据库设计更合理，更易懂，更易修改，效率更高，故结合各方资料，权衡取舍，总结出此篇规范，作为以后数据库设计的指导性文件。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.08 1.0 ZZ 初稿 2 2018.11.26 1.1 ZZ 更新完善 三、数据库命名规范3.1、基本命名原则 使用有意义的英文词汇，词汇中间以下划线分隔（不要用拼音） 只能使用英文字母，数字，下划线，并以英文字母开头 库、表、字段全部采用小写，不要使用驼峰式命名 避免保留字，如desc，关键字如index 命名最好不要超过30个字符，建议使用名词 不同表存储相同数据的列名和类型必须一致 临时库、表名以tmp为前缀，并以日期为后缀 备份库、表名以bak为前缀，并以日期为后缀 问：为什么库、表、字段全部采用小写？ 答：在 MySQL 中，数据库和表对就于那些目录下的目录和文件。因而，操作系统的敏感性决定数据库和表命名的大小写敏感。 Windows下是不区分大小写的。 Linux下大小写规则： 数据库名与表名是严格区分大小写的； 表的别名是严格区分大小写的； 列名与列的别名在所有的情况下均是忽略大小写的； 变量名也是严格区分大小写的； 问：如果已经设置了驼峰式的命名如何解决？ 答：需要在MySQL的配置文件my.ini中增加 lower_case_table_names = 1即可。 3.2、数据库的命名命名规则为 【系统/子系统名】，比如: lapland smart_city bak_lapland_20180208 3.3、表的命名3.31、表名使用前缀同一个模块的表使用相同的前缀，前缀不超过5字，表名自解释。命名规则为 【模块名_表名】，比如: sys_user sys_dictionary sys_operatelog tmp_sys_operatelog_20180208 3.4、字段的命名 主键一般都为id，自增，外键为xxx_id。 布尔意义的字段以”is_”作为前缀，后接动词过去分词。 字段名称使用单词组合完成,最好是带表名前缀，如 web_user 表的字段: user_id user_name user_password 3.5、其他命名参考 对象 前缀 示例 存储过程 usp_表名_操作方法 视图 view_表名 view_user 函数 fn_功能名称 fn_splitStr 序列 seq_表名 seq_user_info 事务 trans_ 游标 crs_ 四、数据库基本设计规范1）所有表必须使用Innodb存储引擎。它支持事务、行级锁，更好的恢复性，高并发下性能更好。2）数据库和表的字符集统一使用UTF-8或UTF8mb4。3）所有表和字段都需要添加注释。4）从一开始就进行数据字典，文档的维护5）尽量控制单表数据量大小，建议控制在500万以内。6）尽量做到冷热数据分离，减少表的宽度。7）禁止在表中建立预留字段。8）禁止在数据库中存储图片，文件等二级制数据。9）不使用使用触发器。10）保存常用信息，当前版本，关联设计文档的名称、客户等信息。11）在数据库中引入版本控制机制来确定使用中的数据库的版本。 参考：mysql数据库设计规范浅谈(一) 4.1、三大范式第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式); 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段; 第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分; 备注：必须先满足第一范式; 第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段; 备注：必须先满足第二范式; 数据库的三范式：①字段不可分。②有主键，非主键字段依赖主键。③非主键字段不能互相依赖。 备注： 平衡范式与冗余(效率优先；往往牺牲范式)。 五、数据库索引设计规范mysql的索引有5种：主键索引、普通索引、唯一索引、全文索引、聚合索引（多列索引）。 1）限制每张表索引的数量，建议单表索引不超过5个 。索引并不是越多越好，能提高查询效率，也能降低插入，更新效率。应该根据实际情况来建立索引。 2）每个InnoDB表中必须有一个主键（唯一非空列）。不用使用频繁更新的列为主键，不使用MD5，UUID,HASH,字符串列作为主键。主键建议选择使用自增ID值。 3）常见索引列建议：where从句中的列 order by、group by、distinct 中的字段，多表join的关联列，如果在字句中是单个列，那就单独索引，有多个列，那可以建立联合索引。 4）如何选择索引列的顺序，区分度最高（比如主键列）的列，字段长度小，使用频繁的列放在联合索引的最左侧。 5）避免建立冗余和重复的索引：index（a,b,c），index(a,b)，index(a) 对于a就是重复索引。 6）对于频繁的查询优先考虑使用覆盖索引：包含了所有查询字段的索引。 7）尽量避免使用外键约束。外键会影响父表与子表的写操作从而降低性能。 8）不对索引做列运算。 六、数据库字段设计规范 1）优先选择符合存储需要的最小数据类型。2）避免使用Text、Blob数据类型，若需要使用，尽量分配到专门的扩展表中3）避免使用Enum枚举类型。order by操作效率低。禁止使用数值作为ENum枚举值4）尽可能把所有列定义为NOT NULL。索引NULL列需要更多的存储空间来保存。索引会失效。5）避免使用字符串来存储日期时间，使用TIMESTAMP或DATATIME来存储时间6）与财务相关的金额类型数据，必须使用Decimal类型。保证数据精度，计算时不丢失精度。7）表达是与否概念的字段，数据类型为unsigned的tinyint(1是，0否)。 注： MySQL5.0.3之前varchar(n)这里的n表示字节数，MySQL5.0.3之后varchar(n)这里的n表示字符数，比如varchar（200），不管是英文还是中文都可以存放200个。 单行最大限制为65535字节，如果大于65535，则转换为TEXT。 在utf-8状态下的varchar，最大只能到 (65535 - 2) / 3 = 21844字符在gbk状态下的varchar, 最大只能到 (65535 - 2) / 2 = 32766字符 七、数据库SQL开发规范详见SQL语句性能优化。 八、数据库操作行为规范1）对于程序连接数据库账号，遵循权限最小的原则。2）程序使用的账号原则上不准有drop权限。3）禁止在线上做数据库压力测试。4）禁止从开发环境、测试环境直连生成环境数据库。 九、补充 SQL语句注释样式： “–” 单行注释，”/**/“ 块注释 9.1、性能分析工具 show profile; mysqlsla; mysqldumpslow; explain; show slow log; show processlist; 十、拓展阅读命名不能用的数据库关键字 十一、参考资料 MySQL命名、设计及使用规范 Mysql数据库设计规范 MySQL中的数据类型 分析与设计数据库模型的简单过程 重点推荐 数据库设计规范 数据库设计规范 十二、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库设计基础/Oracle基本语法学习","date":"2019-03-12T06:57:56.776Z","updated":"2018-11-28T09:27:27.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/Oracle基本语法学习/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库设计基础/Oracle基本语法学习/","excerpt":"","text":"[TOC] 一、前言本文整理了Oracle语句的使用方法，以备查询。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.11.28 1.0 ZZ 初稿 三、操作 测试环境 pl/sql，本地安装 安装配置 1.1 安装教程 1.2 创建数据库实例 1. Database Configuration Assistant 实例名：yycg 2.配置监听（listener.ora）--&gt; 可通过 Net Manager 图形化界面配置 (SID_DESC = (GLOBAL_DBNAME = yycg) (ORACLE_HOME =D:\\Oracle\\product\\11.2.0\\dbhome_1) (SID_NAME = yycg)) 3. 配置 tnsnames.ora --&gt; 可通过 Net Manager 图形化界面配置 YYCG = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = yycg) ) ) 4.启动服务（注意同时只可以启动一个数据库实例OracleServiceXXX） OracleServiceYYCG OracleOraDb11g_home1TNSListener 1.3 pl/sql连接本地ORCL方法 1. 如果本地机为32位，直接在ol/sql 配置Oracle主目录（tns），OCI库位置 2. 若果本地机为64位，则需要拷贝客户端 instantclient_12_1 文件。pl/sql中配置客户端oci位置。 3. 1.4 pl/sql 连接远程虚拟机ORCL 方法 1. 设置ORCL 用户名和密码。 1. 设置服务器端网络配置为桥连，配置服务器端监听器 3. 设置服务器端的IP地址。 4. 客户端 + oci.dll 1.5 基本操作 2. 管理员登陆：sqlplus &quot;sys/root as sysdba&quot; 3. 普通用户登陆：sqlplus scott/tiger 4. 更改用户密码 alter user sys identified by zz; 5. 创建新用户 create user 创建表空间 2.1 sys登陆 2.2 SQL语句： create tablespace yycg0730 logging datafile &apos;E:\\Oracle Datafiles\\yycg\\yycg0730.dbf&apos; size 32m autoextend on next 32m maxsize 2048m extent management local; 2.3 查看TableSpace（表空间） 创建用户（默认的表空间是yycg0730） 3.1 sys登陆 3.2 SQL语句 create user yycg0730 identified by zz default tablespace yycg0730 temporary tablespace temp; 3.3 给用户授权 grant connect,resource,dba to yycg0730; 建立表结构、初始化数据 4.1 yycg0730登陆 4.2 SQL语句 @D:/oracle_sql/yycg_table.sql @D:/oracle_sql/yycg_data.sql 4.3 查看Table（表结构）、Sequences（序列）、Procedures（存储过程）、Triggers(触发器）是否有数据 5.如果表结构有乱码 配置NLS_LANS环境变量 十二、参考资料 百度百科 十三、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/其他小知识点","date":"2019-03-12T06:57:56.764Z","updated":"2019-01-25T01:54:58.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/其他小知识点/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/其他小知识点/","excerpt":"","text":"解决Sql文件太大无法导入问题1234mysql&gt; set wait_timeout=2880000;mysql&gt; set interactive_timeout=2880000;mysql&gt; set global max_allowed_packet=500*1024*1024;mysql&gt; show global variables like &apos;max_allowed_packet&apos;;","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库连接密码加密","date":"2019-03-12T06:57:56.748Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库连接密码加密/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库连接密码加密/","excerpt":"","text":"-[x] 加密连接数据库明文密码 -[x] 数据库连接用户名和密码加密","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/Spring配置多数据源，并实现注解切换","date":"2019-03-12T06:57:56.740Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/Spring配置多数据源，并实现注解切换/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/Spring配置多数据源，并实现注解切换/","excerpt":"","text":"[TOC] 一、前言本文讲述如何使用Spring AOP注解配置多数据源，并实现注解动态切换。 测试环境：SSM + JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.13 1.0 ZZ 初稿 三、配置过程3.1、配置数据源 jdbc.properties 1234567891011#mysql数据库jdbc.mysql.driver = com.mysql.jdbc.Driverjdbc.mysql.url = jdbc:mysql://localhost:3306/ningbo_court?characterEncoding=utf-8&amp;allowMultiQueries=truejdbc.mysql.username = rootjdbc.mysql.password = 123#sqlserver数据库jdbc.sqlserver.driver=com.microsoft.sqlserver.jdbc.SQLServerDriverjdbc.sqlserver.url=jdbc:sqlserver://192.168.3.16:1433;DatabaseName=nbwfytjjdbc.sqlserver.username=sajdbc.sqlserver.password=123 3.2、配置连接池 spring-context-database.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!-- 引用配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;bean id=\"mySqlDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" scope=\"singleton\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.mysql.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.mysql.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.mysql.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.mysql.password&#125;\"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\"/&gt; &lt;!-- 最大空闲值，当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 最小空闲值，当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\"/&gt; &lt;!-- 最大建立连接等待时间，如果超过此时间将接到异常。设为 -1表示无限制 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;jdbc.maxWait&#125;\"/&gt; &lt;!-- 连接的超时时间，默认为半小时 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;jdbc.minEvictableIdleTimeMillis&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"sqlServerDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" scope=\"singleton\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.sqlserver.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.sqlserver.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.sqlserver.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.sqlserver.password&#125;\"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\"/&gt; &lt;!-- 最大空闲值，当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 最小空闲值，当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\"/&gt; &lt;!-- 最大建立连接等待时间，如果超过此时间将接到异常。设为 -1表示无限制 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;jdbc.maxWait&#125;\"/&gt; &lt;!-- 连接的超时时间，默认为半小时 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;jdbc.minEvictableIdleTimeMillis&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.yshow.aop.DynamicDataSource\"&gt; &lt;!-- 为targetDataSources注入两个数据源 --&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map&gt; &lt;entry key=\"mySqlDataSource\" value-ref=\"mySqlDataSource\"/&gt; &lt;entry key=\"sqlServerDataSource\" value-ref=\"sqlServerDataSource\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 为指定默认的数据源--&gt; &lt;property name=\"defaultTargetDataSource\" ref=\"mySqlDataSource\"/&gt; &lt;/bean&gt; &lt;!-- 会话工厂 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"mapperLocations\"&gt; &lt;list&gt; &lt;value&gt;classpath:mappers/*Mapper.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper扫描器，这里自动由于没有在mybatis-config配置mapper，所以必须保证mapper和dao接口在同一个目录且同名 --&gt; &lt;bean name=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 定义被扫描的mapper所在包路径 --&gt; &lt;property name=\"basePackage\" value=\"com.yshow.dao\"&gt;&lt;/property&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 3.3、配置AOP切面 spring-mvc.xml 12345&lt;mvc:annotation-driven/&gt;&lt;!-- 启动对@AspectJ注解的支持 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt;&lt;!-- DataSource注解 --&gt;&lt;bean id=\"DataSourceAspect\" class=\"com.yshow.aop.DataSourceAspect\" /&gt; DataSourceAspect.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.yshow.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.Method;/** * DataSourceAspect * @author zz * @date 下午3:55 18-7-11 */ @Aspect public class DataSourceAspect &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceAspect.class); @Pointcut(\"@annotation(com.yshow.aop.DataSource)\") public void dataSourceAspect() &#123; &#125; @AfterReturning(value = \"dataSourceAspect()\", returning = \"result\") public void afterReturning(JoinPoint joinPoint, Object result) &#123; DataSourceHolder.clearDataSourceType(); &#125; @Before(value = \"dataSourceAspect()\") public void before(JoinPoint joinPoint) throws Throwable &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = methodSignature.getMethod(); //如果方法体上使用了DataSource注解 if (method.isAnnotationPresent(DataSource.class)) &#123; //获取该方法上的注解名 DataSource datasource = method.getAnnotation(DataSource.class); //将方法体上的注解的值赋予给DataSourceHolder数据源持有类 DataSourceHolder.setDataSourceType(datasource.value()); LOGGER.info(\"切换数据源为：\" + datasource.value()); &#125; &#125; &#125; 3.3、AOP注解配置 DataSource 元注解类 12345678910111213141516package com.yshow.aop;import java.lang.annotation.*;/** * 自定义注解 - 数据源 * @author zz * @date 下午3:53 18-7-11 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)public @interface DataSource &#123; String value() default \"\";&#125; DynamicDataSource.java 12345678910111213141516package com.yshow.aop;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;/** * 动态数据源 * @author zz * @date 上午11:51 18-7-10 */public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceHolder.getDataSourceType(); &#125;&#125; DataSourceHolder.java 123456789101112131415161718192021222324252627282930313233343536package com.yshow.aop;/** * 数据源持有类 * @author zz * @date 下午3:50 18-7-11 */public class DataSourceHolder&#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); /** * 设置数据源类型 * @param dataSourceType * 数据库类型 * @return void */ public static void setDataSourceType(String dataSourceType) &#123; contextHolder.set(dataSourceType); &#125; /** * 获取数据源类型 * @return java.lang.String */ public static String getDataSourceType() &#123; return contextHolder.get(); &#125; /** * 清除数据源类型 * @return void */ public static void clearDataSourceType() &#123; contextHolder.remove(); &#125;&#125; 3.4、注解使用 EAJServiceImpl.java 12345678910111213141516171819202122232425262728package com.yshow.service.impl;import com.yshow.common.ServerResponse;import com.yshow.dao.EAJMapper;import com.yshow.pojo.EAJ;import com.yshow.service.EAJService;import com.yshow.aop.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * EAJServiceImpl * @author zz * @date 上午10:11 18-7-11 */@Servicepublic class EAJServiceImpl implements EAJService &#123; @Autowired EAJMapper EAJMapper; @Override @DataSource(\"sqlServerDataSource\") public ServerResponse&lt;EAJ&gt; getEAJ(String id) &#123; EAJ eaj = EAJMapper.selectByPrimaryKey(id); return ServerResponse.createBySuccess(eaj); &#125;&#125; 八、参考资料 [x] Spring多数据源配置系列 [x] springboot+mybatis多数据源最简解决方案 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/SQL习题108道","date":"2019-03-12T06:57:56.732Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL习题108道/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/SQL习题108道/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/mysql 主从热备，主主互备","date":"2019-03-12T06:57:56.728Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/mysql 主从热备，主主互备/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/mysql 主从热备，主主互备/","excerpt":"","text":"mysql 主从热备，主主互备","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/Java连接SqlServer实践","date":"2019-03-12T06:57:56.728Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/Java连接SqlServer实践/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/Java连接SqlServer实践/","excerpt":"","text":"[TOC] 一、前言本文主要介绍JDBC连接SqlServer数据库的方法。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.09 1.0 ZZ 初稿 三、实例3.1、方法一：JDBC类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.sql.DriverManager;import java.sql.*;/** * SqlService 连接测试类 * @author zz * @date 下午8:01 18-7-9 */public class javaConnSSQL &#123; public static void main(String[] args) &#123; String JDriver = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";// SQL数据库引擎 String connectDB = \"jdbc:sqlserver://192.168.3.16:1433;DatabaseName=nbwfytj\";// 数据源 try &#123; Class.forName(JDriver);// 加载数据库引擎，返回给定字符串名的类 &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"加载数据库引擎失败\"); System.exit(0); &#125; System.out.println(\"数据库驱动成功\"); try &#123; String user = \"sa\"; String password = \"123\"; Connection con = DriverManager.getConnection(connectDB, user, password);// 连接数据库对象 System.out.println(\"连接数据库成功\"); Statement stmt = con.createStatement();// 创建SQL命令对象 // 创建表 //System.out.println(\"开始创建表\"); //String query = \"create table TEST1(ID NCHAR(2),NAME NCHAR(10))\";// 创建表SQL语句 //stmt.executeUpdate(query);// 执行SQL命令对象 System.out.println(\"表创建成功\"); // 输入数据 System.out.println(\"开始插入数据\"); String a1 = \"INSERT INTO TEST1 VALUES('1','宁波中级人民法院')\";// 插入数据SQL语句 String a2 = \"INSERT INTO TEST1 VALUES('2','宁波中级人民法院')\"; String a3 = \"INSERT INTO TEST1 VALUES('3','宁波中级人民法院')\"; stmt.executeUpdate(a1); stmt.executeUpdate(a2); stmt.executeUpdate(a3); System.out.println(\"插入数据成功\"); // 读取数据 System.out.println(\"开始读取数据\"); ResultSet rs = stmt.executeQuery(\"SELECT * FROM TEST1\");// 返回SQL语句查询结果集(集合) // 循环输出每一条记录 while (rs.next()) &#123; System.out.println(rs.getString(\"ID\") + \"\\t\" + rs.getString(\"NAME\")); &#125; System.out.println(\"读取完毕\"); // 关闭连接 stmt.close();// 关闭命令对象连接 con.close();// 关闭数据库连接 &#125; catch (SQLException e) &#123; System.out.println(\"数据库连接错误\"); System.exit(0); &#125; &#125;&#125; 3.2、方法二：数据源连接池 jdbc.properties 12345#sqlserver数据库db.driver=com.microsoft.sqlserver.jdbc.SQLServerDriverdb.url=jdbc:sqlserver://192.168.3.16:1433;DatabaseName=nbwfytjdb.username=sadb.password=123 spring-context-database.xml 12345678&lt;!--数据源配置,使用Tomcat jdbc pool--&gt;&lt;bean id=\"dataSource\" class=\"org.apache.tomcat.jdbc.pool.DataSource\" destroy-method=\"close\"&gt; &lt;!--Connection Info--&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt; 七、拓展阅读 Spring配置多数据源，并实现注解切换.md 八、参考资料 百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/记录一次数据库恢复","date":"2019-03-12T06:57:56.720Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/记录一次数据库恢复/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/记录一次数据库恢复/","excerpt":"","text":"重装系统后发现mysql数据库忘记导出sql语句了，幸好备份了数据盘，看看mysql文件夹下有什么东西： 其中*.frm是表结构文件，db.opt编码格式，ib_logfile0是日志文件，ibdata1是具体的数据。 是接下来要做的就是把备份的除了mysql、sys、performance_schema外的数据库文件夹和ibdata1文件拷贝复制到新的数据库相应目录下，重启服务器，搞定！ 注：记得及时备份sql语句。 如果mysql错误还是无法恢复，可以卸载后重装，切记卸载时不要勾选删除数据。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库操作的几种方式","date":"2019-03-12T06:57:56.720Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库操作的几种方式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库操作的几种方式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/非关系型数据库和关系型数据库","date":"2019-03-12T06:57:56.720Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/非关系型数据库和关系型数据库/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/非关系型数据库和关系型数据库/","excerpt":"","text":"[TOC] 一、前言 本文介绍了非关系型数据库和关系型数据库的概念、特性以及实际应用中的选型参考依据。两种类型的数据库各有自身特点及应用场景，总之，没有最好的方案，只有最合适的方案。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.12.28 1.0 ZZ 初稿 三、概念解析3.1、关系型数据库 关系型数据库，是指采用了关系模型来组织数据的数据库。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。关系型数据库的最大特点就是事务的一致性。读写操作都是事务的，具有ACID的特点，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。 常见的关系型数据库有Oracle、DB2、Mysql等。 3.2、非关系型数据库（NOSQL） 非关系型数据库，是指那些非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。NOSQL数据库不提供sql支持，非关系型数据库是基于CAP模型的。 常见的非关系型数据库有Redis、Memcached、MongoDB、HBase等。 四、关系型数据库的特性4.1、关系型数据库的优点 结构化查询 - SQL语言 通用的SQL语言使得操作关系型数据库非常方便。关系型数据库可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 数据一致性 关系型数据库的最大特点就是事务的一致性。这个特性使得关系型数据库被应用于几乎对一致性有要求的系统中，如银行系统。为了维护一致性所付出的代价就是其读写性能比较差。 持久存储 数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库。 4.2、关系型数据库的瓶颈 高并发读写需求 网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。 海量数据的高效率读写 网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。 高扩展性和可用性 在基于web的结构中，数据库是最难进行横向扩展的。因为关系型数据库具有有预定义好的结构(列的定义)，和多表查询机制。虽然预定义结构带来了可靠性和稳定性，但是当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。或者由于系统的升级，功能的增加，数据结构变动比较大，此时对数据库系统升级和扩展都是非常痛苦的事情。 性能 关系型数据库将数据存储在硬盘中，查询速度不如NOSQL数据库。 五、非关系型数据库的特性 非关系型数据库往往在某些特定的领域具有优势。 5.1、非关系型数据库的优点 性能 NOSQL数据库将数据存储于内存，查询速度非常快，例如redis作为数据的缓存。 高并发读写需求 key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表。 海量数据的高效率读写 面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB。 高扩展性和可用性 分布式数据库：NoSQL数据之间没有耦合性，数据的格式十分灵活没有固定的表结构，所以非常容易水平扩展。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。 5.2、非关系型数据库的瓶颈 数据一致性 非关系型数据库一般强调的是数据最终一致性，而不没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么非关系型数据库并不一个很好的选择，非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景。 不提供关系型数据库对事物的处理。 六、关系型数据库与非关系型数据库的选择 事务一致性: 关系型数据库在对事物一致性的维护中有很大的开销，而现在很多web2.0系统对事物的读写一致性都不高。 读写实时性: 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比如发一条消息之后，过几秒乃至十几秒之后才看到这条动态是完全可以接受的。 复杂SQL，特别是多表关联查询: 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站（SNS，专指社交网络服务，包括了社交软件和社交网站。），从需求以及产品阶级角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能极大的弱化了。 七、拓展阅读 结构化数据 非结构化数据 八、参考资料 SQL与NoSQL（关系型与非关系型）数据库的区别 九、结语 初稿完成，后续完善。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC04 数据库应用/数据库外键的使用以及优缺点","date":"2019-03-12T06:57:56.712Z","updated":"2018-11-28T08:32:48.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库外键的使用以及优缺点/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC04 数据库应用/数据库外键的使用以及优缺点/","excerpt":"","text":"摘录网上讨论共同观点：主键和索引是不可少的，不仅可以优化数据检索速度，开发人员还省不其它的工作, 矛盾焦点：数据库设计是否需要外键。这里有两个问题：一个是如何保证数据库数据的完整性和一致性；二是第一条对性能的影响。 正方观点：1，由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。eg：数据库和应用是一对多的关系，Ａ应用会维护他那部分数据的完整性，系统一变大时，增加了Ｂ应用，Ａ和Ｂ两个应用也许是不同的开发团队来做的。他们如何协调保证数据的完整性，而且一年以后如果又增加了C应用呢？2，有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要。3，外键在一定程度上说明的业务逻辑，会使设计周到具体全面。 反方观点：1，可以用触发器或应用程序保证数据的完整性2，过分强调或者说使用主键／外键会平添开发难度，导致表过多等问题3，不用外键时数据管理简单，操作方便，性能高（导入导出等操作，在insert, update, delete 数据的时候更快）eg:在海量的数据库中想都不要去想外键，试想，一个程序每天要insert数百万条记录，当存在外键约束的时候，每次要去扫描此记录是否合格，一般还不 止一个字段有外键，这样扫描的数量是成级数的增长！我的一个程序入库在3个小时做完，如果加上外键，需要28个小时！ 结论：1，在大型系统中（性能要求不高，安全要求高），使用外键；在大型系统中（性能要求高，安全自己控制），不用外键；小系统随便，最好用外键。2，用外键要适当，不能过分追求3，不用外键而用程序控制数据一致性和完整性时，应该写一层来保证，然后个个应用通过这个层来访问数据库。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Solr安装及应用","date":"2019-03-12T06:57:56.680Z","updated":"2018-12-17T01:18:01.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Solr安装及应用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Solr安装及应用/","excerpt":"","text":"1、安装solr服务器1.1 solr服务器下载1&gt; wget http://mirrors.hust.edu.cn/apache/lucene/solr/7.5.0/solr-7.5.0.tgz 1.2 解压、启动123456&gt; tar -zxvf solr-7.5.0.tgz#移动到我的工作目录下&gt; mv solr-7.5.0 /home/zz/service/Web/solr&gt; cd /home/zz/service/Web/solr/bin#启动solr 默认端口8983&gt; ./solr start 1.3 访问测试1http://localhost:8983 1.3 整合到SpringBoot1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 运用2、安装ikanalyzer分词器3、solr单节点数据库同步数据 Solr全文检索服务器搭建与基本使用介绍","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Sorl连接Mysql数据库，并导入数据","date":"2019-03-12T06:57:56.608Z","updated":"2018-12-13T03:19:12.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Sorl连接Mysql数据库，并导入数据/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/搜索引擎Solr的配置和使用/Sorl连接Mysql数据库，并导入数据/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用Jenkins 搭建自动化 CI/CD 流水线。以实现软件服务的快速迭代。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.12.11 1.0 ZZ 初稿 三、步骤-0、拷贝sample样板工程到/home/zz/service/Web/solr/server/solr下，并命名为info（自定义的core名称 ） 1、修改Solr配置文件 solrconfig.xml123456789101112131415161718# 检查lib标签,查看是否和下面代码一致(一般不须修改)&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/dist/\" regex=\"solr-dataimporthandler-.*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/contrib/extraction/lib\" regex=\".*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/dist/\" regex=\"solr-cell-\\d.*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/contrib/langid/lib/\" regex=\".*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/dist/\" regex=\"solr-langid-\\d.*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/contrib/velocity/lib\" regex=\".*\\.jar\" /&gt;&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/dist/\" regex=\"solr-velocity-\\d.*\\.jar\" /&gt;# 加载DataImport配置文件路径&lt;requestHandler name=\"/dataimport\" class=\"org.apache.solr.handler.dataimport.DataImportHandler\"&gt; &lt;lst name=\"defaults\"&gt; &lt;str name=\"config\"&gt;db-data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; -2、配置数据库连接信息 db-data-config.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;dataConfig&gt; &lt;!-- 数据源配置 --&gt; &lt;dataSource name=\"JdbcDataSource\" type=\"JdbcDataSource\" driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://192.168.2.100:3306/pybbs\" user=\"root\" password=\"root\" /&gt; &lt;document&gt; &lt;!--name:数据库中表的名称;dataSource:数据源;pk:唯一标识(不是表的主键);query:查询语句;--&gt; &lt;!--column:表的字段名称;name:属性名称--&gt; &lt;entity name=\"fly_article\" pk=\"id\" query=\"select * from fly_article\"&gt; &lt;field column=\"title\" name=\"title\" /&gt; &lt;field column=\"infoId\" name=\"infoId\" /&gt; &lt;field column=\"infoType\" name=\"infoType\" /&gt; &lt;field column=\"userId\" name=\"userId\" /&gt; &lt;field column=\"categoryId\" name=\"categoryId\" /&gt; &lt;field column=\"content\" name=\"content\" /&gt; &lt;field column=\"createTime\" name=\"createTime\" dateTimeFormat='yyyy-MM-dd HH:mm:ss'/&gt; &lt;field column=\"recommend\" name=\"recommend\" /&gt; &lt;field column=\"weight\" name=\"weight\" /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 3、创建索引的表的配置managed-schema.xml（复制managed-schema改名为managed-schema.xml） 123456789101112131415161718192021222324252627282930313233# 索引字段，type：分词类型&lt;field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" /&gt;&lt;field name=\"userId\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"title\" type=\"text_ik\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"infoId\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"infoType\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"categoryId\" type=\"vertical_text\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"content\" type=\"text_ik\" indexed=\"true\" stored=\"true\" required=\"true\" default=\"\" /&gt;&lt;field name=\"createTime\" type=\"pdate\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"recommend\" type=\"pint\" indexed=\"true\" stored=\"true\" required=\"true\" default=\"0\" /&gt;&lt;field name=\"weight\" type=\"pdouble\" indexed=\"true\" stored=\"true\" required=\"true\" default=\"0\" /&gt;# 索引多字段联合查询&lt;uniqueKey&gt;id&lt;/uniqueKey&gt;&lt; source=\"userId\" dest=\"text\"/&gt;&lt;copyField source=\"title\" dest=\"text\"/&gt;&lt;copyField source=\"infoId\" dest=\"text\"/&gt;&lt;copyField source=\"infoType\" dest=\"text\"/&gt;&lt;copyField source=\"categoryId\" dest=\"text\"/&gt;&lt;copyField source=\"content\" dest=\"text\"/&gt;&lt;copyField source=\"createTime\" dest=\"text\"/&gt;&lt;copyField source=\"recommend\" dest=\"text\"/&gt;&lt;copyField source=\"weight\" dest=\"text\"/&gt;# 设置ik分词器，fieldType：分词类型&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer isMaxWordLength=\"false\" class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" /&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer isMaxWordLength=\"true\" class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"true\" /&gt; &lt;/analyzer&gt;&lt;/fieldType&gt; 4、导入数据库连接jar 拷贝Solr根目录下的dist文件夹里面的solr-dataimporthandler-7.1.0，solr-dataimporthandler-extras-7.1.0，mysql-connector-java-5.1.38，ikanalyzer-5.5到info/lib目录下； 如果是用Solr是使用Tomcat容器启动，则拷贝到\\webapps\\solr\\WEB-INF\\lib目录下。 5、重启Solr，刷新solr页面 6、导入数据，查询数据 导入操作 查询操作 删除所有数据 12&lt;delete&gt;&lt;query&gt;*:*&lt;/query&gt;&lt;/delete&gt;&lt;commit/&gt; 四、参考资料 [x] solr搜索之mysql导入数据到solr（四） [x] solr学习之四——–Field、CopyField、DynamicField [x] Solr学习总结（四）Solr查询参数 五、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Java Web在线预览Office文件","date":"2019-03-12T06:57:56.600Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Java Web在线预览Office文件/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Java Web在线预览Office文件/","excerpt":"","text":"[TOC] 一、前言公司某项目有需求，要求可以在Html页面中打开演示PPT，并能打开点击播放PPT中的视频、音频。现有解决思路如下，会逐一实现，并进行比较。 使用poi将PPT转为图片,在线预览PPT 根据PDF模板生成PDF文件 下载 在线预览 使用poi实现word、excel、ppt转html 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.18 1.0 ZZ 初稿 三、概念解析3.1、占位四、正文五、正文六、相关术语七、拓展阅读八、参考资料九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Apache POI使用入门","date":"2019-03-12T06:57:56.600Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Apache POI使用入门/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Web Office/Apache POI使用入门/","excerpt":"","text":"[TOC] 一、前言Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.18 1.0 ZZ 初稿 - POI_Excel 三、API 文档说明3.1、包名称说明 HSSF：提供读写Microsoft Excel格式档案的功能。 XSSF：提供读写Microsoft Excel OOXML格式档案的功能。 HWPF：提供读写Microsoft Word格式档案的功能。 HSLF：提供读写Microsoft PowerPoint格式档案的功能。 HDGF：提供读写Microsoft Visio格式档案的功能。 HPBF：提供读Microsoft Publisher格式档案的功能。 HSMF：提供读Microsoft Outlook格式档案的功能。 3.2、POI_Excel常用类说明 Workbook：Excel工作薄 Sheet ：Excel工作表 Row：Excel行 Cell ：Excel单元格 Font ：Excel字体 四、POI_Excel实例 Excel 输出模板.xlsx pom 依赖 1234567891011&lt;!-- poi操作office文件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt; ExportExcelUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200package com.lapland.utils.poiUtil;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.xssf.usermodel.XSSFRichTextString;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.*;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;/** * 根据模板导出Excel表工具类 * @author zz * @date 上午2:01 18-7-20 */public class ExportExcelUtil &#123; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(ExportExcelUtil.class); //声明一个模板工作薄(写入流数据) private static Workbook tempWorkBook; //Excel当前行数 private static int CUTRRENT_ROW_NUM = 0; //数据输出流 private static OutputStream outputStream; /** * 根据模板导出Excel表 * @param exportPath * 输出文件路径 * @param tempPath * 模板文件路径 * @param columnNames * 列名集合 * @param sheetTitle * 表头 * @param objects * 内容集合 * @return void */ public static void exportExcelByTemp(String exportPath, String tempPath, String sheetTitle, List&lt;String&gt; columnNames, List&lt;List&lt;Object&gt;&gt; objects) &#123; // Excel写入检查 File file = checkFile(exportPath); // 加载模板 loadTempWorkbook(tempPath); // 导出表头 writeExcelData(file, sheetTitle, columnNames, objects); // 资源释放 dispose(); &#125; /** * 写入excel表头数据 * @param file * 文件名 * @param columnNames * 表头 * @param sheetTitle * 标题 */ private static void writeExcelData(File file, String sheetTitle, List&lt;String&gt; columnNames, List&lt;List&lt;Object&gt;&gt; objects ) &#123; // 获取第一个工作表对象 Sheet sheet = tempWorkBook.getSheetAt(0); // 获取表头对象 Row MergedRow = sheet.getRow(CUTRRENT_ROW_NUM); Cell mergedCell = MergedRow.getCell(0); mergedCell.setCellValue(new XSSFRichTextString(sheetTitle)); CUTRRENT_ROW_NUM++; // 获取表格标题栏对象 Row row = sheet.getRow(CUTRRENT_ROW_NUM); for (int i = 0; i &lt; columnNames.size(); i++) &#123; Cell cell = row.getCell(i); cell.setCellValue(new XSSFRichTextString(columnNames.get(i))); &#125; CUTRRENT_ROW_NUM++; // 写入excel正文数据 for (List&lt;Object&gt; dataRow : objects) &#123; // 获取当前行对象 Row contentRow = sheet.getRow(CUTRRENT_ROW_NUM); for (int j = 0; j &lt; dataRow.size(); j++) &#123; // 当前行包含的单元格 Cell contentCell = contentRow.getCell(j); Object dataObject = dataRow.get(j); if (dataObject != null) &#123; if (dataObject instanceof Integer) &#123; contentCell.setCellValue(Integer.parseInt(dataObject.toString())); &#125; else if (dataObject instanceof Double) &#123; contentCell.setCellValue(Double.parseDouble(dataObject.toString())); &#125; else if (dataObject instanceof Long &amp;&amp; dataObject.toString().length() == 13) &#123; contentCell.setCellValue(formatDate(new Date(Long.parseLong(dataObject.toString())))); &#125; else if (dataObject instanceof Date) &#123; contentCell.setCellValue(formatDate((Date) dataObject)); &#125; else &#123; contentCell.setCellValue(dataObject.toString()); &#125; &#125; else &#123; // 设置单元格内容为字符型 contentCell.setCellValue(\"\"); &#125; &#125; CUTRRENT_ROW_NUM++; &#125; try &#123; outputStream = new FileOutputStream(file); tempWorkBook.write(outputStream); LOGGER.info(\"工作表数据写入成功\"); &#125; catch (IOException e) &#123; LOGGER.error(\"工作表数据写入错误\" + e.getMessage()); &#125; &#125; /** * Excel文件写入检查 * @param exportPath * 输出路径 * @return file */ private static File checkFile(String exportPath) &#123; File file = new File(exportPath); if (file.exists()) &#123; if (file.isDirectory()) &#123; LOGGER.error(\"文件不存在\"); &#125; if (!file.canWrite()) &#123; LOGGER.error(\"文件不可写\"); &#125; &#125; else &#123; File parent = file.getParentFile(); if (parent != null) &#123; if (!parent.mkdirs() &amp;&amp; !parent.isDirectory()) &#123; LOGGER.error(\"文件不可创建\"); &#125; &#125; &#125; return file; &#125; /** * 加载模板文件 * @param tempPath * 模板文件路径 * @return void */ private static void loadTempWorkbook(String tempPath) &#123; try &#123; // 根据模板创建Excel文件的输入流对象 FileInputStream tempFile = new FileInputStream(tempPath); // 根据模板创建excel工作簿 tempWorkBook = new XSSFWorkbook(tempFile); LOGGER.info(\"Excel模板加载成功\"); &#125; catch (IOException e) &#123; LOGGER.error(\"Excel模板文件不存在\" + e.getMessage()); &#125; &#125; /** * 资源释放 * @return void */ public static void dispose() &#123; try &#123; if (outputStream != null) &#123; outputStream.flush(); outputStream.close(); &#125; outputStream = null; tempWorkBook = null; LOGGER.info(\"输出流关闭成功\"); &#125; catch (IOException e) &#123; LOGGER.error(\"输出流关闭异常\" + e.getMessage()); &#125; &#125; /** * 日期转化为字符串,格式为yyyy-MM-dd HH:mm:ss * @param date * @return java.lang.String */ private static String formatDate(Date date) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); return sdf.format(date); &#125;&#125; POI_Excel_Test.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.lapland.utils.poiUtil;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Date;import java.util.LinkedList;import java.util.List;/** * POI_Excel_测试类 * @author zz * @date 上午2:13 18-7-20 */public class POI_Excel_Test &#123; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(POI_Excel_Test.class); // 输出模板 private static final String TEMP_PATH = \"src/main/resources/resources/输出模板.xlsx\"; // 输出文件路径 private static final String FILE_PATH = \"export/test.xlsx\"; /** * 输出Excel表格测试 * @return void */ @Test public void test1() &#123; // 输出工作表 String sheetTitle = \"测试文档\"; // 准备表头数据 List&lt;String&gt; columnNames = new LinkedList&lt;&gt;(); columnNames.add(\"ID\"); columnNames.add(\"日期-String\"); columnNames.add(\"日期-Date\"); columnNames.add(\"时间戳-Long\"); columnNames.add(\"客户编码\"); columnNames.add(\"整数\"); columnNames.add(\"带小数的正数\"); // 准备正文数据 List&lt;List&lt;Object&gt;&gt; objects = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= 20; i++) &#123; List&lt;Object&gt; dataA = new LinkedList&lt;&gt;(); dataA.add(i); dataA.add(\"2016-09-06 17:27:25\"); dataA.add(new Date(1451036631012L)); dataA.add(1451036631012L); dataA.add(\"000628\"); dataA.add(i); dataA.add(1.323 + i); objects.add(dataA); &#125; // 写入Excel ExportExcelUtil.exportExcelByTemp(FILE_PATH, TEMP_PATH, sheetTitle, columnNames, objects); &#125; /** * 读取Excel表格测试 * @return void */ @Test public void test2() &#123; &#125;&#125; 输出Excel.xlsx 五、POI_Excel 拓展阅读 ReadExcelUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263package com.lapland.utils.poiUtil;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;/** * 操作Excel工具类 * @author zz * @date 上午2:07 18-7-20 */public class ReadExcelUtil &#123; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(ReadExcelUtil.class); public static final int Excel2003 = 0; public static final int Excel2007 = 1; /** * 根据版本号，获取Excel poi对象 * @param edition * @param in * @throws IOException */ public static Workbook getWorkbook(int edition, InputStream in) throws IOException &#123; if (edition == 0) &#123; return new HSSFWorkbook(in); &#125; else if (edition == 1) &#123; return new XSSFWorkbook(in); &#125; return null; &#125; /** * 从指定excel表格中逐行读取数据 * @param workbook * 工作簿 * @param startRow * 开始行 * @param startCol * 开始单元格 * @param indexSheet * 工作表页码 */ public static List&lt;List&lt;String&gt;&gt; getExcelString(Workbook workbook, int startRow, int startCol, int indexSheet) &#123; List&lt;List&lt;String&gt;&gt; stringTable = new ArrayList&lt;List&lt;String&gt;&gt;(); // 获取指定工作表对象 Sheet sheet = workbook.getSheetAt(indexSheet); // 获取最大行数 int rowNum = sheet.getLastRowNum(); for (int i = startRow; i &lt;= rowNum; i++) &#123; List&lt;String&gt; oneRow = new ArrayList&lt;String&gt;(); Row row = sheet.getRow(i); // 根据当前指针所在行数计算最大列数 int colNum = row.getLastCellNum(); for (int j = startCol; j &lt;= colNum; j++) &#123; // 确定当前单元格 Cell cell = row.getCell(j); String cellValue = null; if (cell != null) &#123; // 验证每一个单元格的类型 switch (cell.getCellType()) &#123; case Cell.CELL_TYPE_NUMERIC: // 表格中返回的数字类型是科学计数法因此不能直接转换成字符串格式 cellValue = new BigDecimal(cell.getNumericCellValue()).toPlainString(); break; case Cell.CELL_TYPE_STRING: cellValue = cell.getStringCellValue(); break; case Cell.CELL_TYPE_FORMULA: cellValue = new BigDecimal(cell.getNumericCellValue()).toPlainString(); break; case Cell.CELL_TYPE_BLANK: cellValue = \"\"; break; case Cell.CELL_TYPE_BOOLEAN: cellValue = Boolean.toString(cell.getBooleanCellValue()); break; case Cell.CELL_TYPE_ERROR: cellValue = \"ERROR\"; break; default: cellValue = \"UNDEFINE\"; &#125; &#125; else &#123; cellValue = \"\"; &#125; // 生成一行数据 oneRow.add(cellValue); &#125; stringTable.add(oneRow); &#125; return stringTable; &#125; /** * 根据给定的数据直接生成workbook * @param workbook * @param sheetName * @param data */ public static Workbook createExcel(Workbook workbook, String sheetName, List&lt;List&lt;String&gt;&gt; data) &#123; Sheet sheet = workbook.createSheet(sheetName); for (int i = 0; i &lt; data.size(); i++) &#123; List&lt;String&gt; oneRow = data.get(i); Row row = sheet.createRow(i); for (int j = 0; j &lt; oneRow.size(); j++) &#123; Cell cell = row.createCell(j); cell.setCellValue(oneRow.get(j)); &#125; &#125; return workbook; &#125; /** * 往指定的sheet表中插入数据，插入的方法是提供一组valueMap。int[]是2维数组代表需要插入的数据坐标，从0开始 * @param workbook * @param sheetIndex * @param valueMap */ public static Workbook insertExcel(Workbook workbook, int sheetIndex, Map&lt;int[], String&gt; valueMap) &#123; Sheet sheet = workbook.getSheetAt(sheetIndex); Iterator&lt;Map.Entry&lt;int[], String&gt;&gt; it = valueMap.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;int[], String&gt; cellEntry = it.next(); int x = cellEntry.getKey()[0]; int y = cellEntry.getKey()[1]; String value = cellEntry.getValue(); Row row = sheet.getRow(y); Cell cell = row.getCell(x); cell.setCellValue(value); &#125; return workbook; &#125; /** * 设置指定行的行高 * @param workbook * @param rowHight * @param sheetIndex * @param rowIndex */ public static Workbook setRowHeight(Workbook workbook, int rowHight, int sheetIndex, int rowIndex) &#123; Sheet sheet = workbook.getSheetAt(sheetIndex); Row row = sheet.getRow(rowIndex); row.setHeight((short) rowHight); return workbook; &#125; /** * 设置列宽 * @param workbook * @param columnWidth * @param sheetIndex * @param columnIndex */ public static Workbook setColumnWidth(Workbook workbook, int columnWidth, int sheetIndex, int columnIndex) &#123; Sheet sheet = workbook.getSheetAt(sheetIndex); sheet.setColumnWidth(columnIndex, columnWidth); return workbook; &#125; /** * 删除指定行 * @param workbook * @param sheetIndex * @param rowIndex */ public static Workbook removeRow(Workbook workbook, int sheetIndex, int rowIndex) &#123; Sheet sheet = workbook.getSheetAt(sheetIndex); int lastRowNum = sheet.getLastRowNum(); if (rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; lastRowNum) &#123; sheet.shiftRows(rowIndex + 1, lastRowNum, -1); &#125; if (rowIndex == lastRowNum) &#123; sheet.removeRow(sheet.getRow(rowIndex)); &#125; return workbook; &#125; /** * 在指定位置插入空白行 * @param workbook * @param sheetIndex * @param rowIndex */ public static Workbook insertBlankRow(Workbook workbook, int sheetIndex, int rowIndex) &#123; Sheet sheet = workbook.getSheetAt(sheetIndex); int lastRowNum = sheet.getLastRowNum(); if (rowIndex &gt;= 0 &amp;&amp; rowIndex &lt;= lastRowNum) &#123; sheet.shiftRows(rowIndex, lastRowNum, 1); // 获得上一行的Row对象 Row preRow = sheet.getRow(rowIndex - 1); short rowNum = preRow.getLastCellNum(); Row curRow = sheet.createRow(rowIndex); // 新生成的Row创建与上一个行相同风格的Cell for (short i = preRow.getFirstCellNum(); i &lt; rowNum; i++) &#123; Cell cell = preRow.getCell(i); CellStyle style = cell.getCellStyle(); curRow.createCell(i).setCellStyle(style); &#125; return workbook; &#125; return null; &#125; /** * 根据sheet(0)作为模板重建workbook * @param workbook * @param sheetNum * @param sheetNames */ public static Workbook rebuildWorkbook(Workbook workbook, int sheetNum, String... sheetNames) &#123; if (sheetNames.length == sheetNum) &#123; for (int i = 0; i &lt; sheetNum; i++) &#123; workbook.cloneSheet(0); // 生成后面的工作表并指定表名 workbook.setSheetName(i + 1, sheetNames[i]); &#125; // 删除第一张工作表 workbook.removeSheetAt(0); return workbook; &#125; return null; &#125; /** * 检查Excel * @param file * @return void * @throws IOException */ public static void checkFile(File file) throws IOException &#123; //判断文件是否存在 if (null == file) &#123; LOGGER.error(\"文件不存在！\"); throw new FileNotFoundException(\"文件不存在！\"); &#125; //获得文件名 String fileName = file.getName(); String suffix = fileName.substring(fileName.lastIndexOf(\".\") + 1); //判断文件是否是excel文件 if (\"xls\".equals(suffix) || \"xlsx\".equals(suffix)) &#123; LOGGER.error(fileName + \"不是excel文件\"); throw new IOException(fileName + \"不是excel文件\"); &#125; &#125;&#125; 六、拓展阅读 tableExport.min.js 前端页面表格导出插件，配合bootstrap-table和bootstrap-table-export.js使用。 参考：分页功能实现 - 导出功能 六、参考资料 [x] POI - 百度百科 [x] POI使用详解 [x] Apache POI - the Java API for Microsoft Documents [x] POI生成EXCEL文件 [x] JAVA实现大数据量导出excel [ ] HSSFworkbook,XSSFworkbook,SXSSFworkbook区别简述 [ ] POI实现一个通用的Excel读取模板 七、结语 目前只完成常用的POI_Excel操作部分，其他Office文档操作待补充。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/消息中间件/RocketMQ消息队列","date":"2019-03-12T06:57:56.596Z","updated":"2019-02-27T01:16:27.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/消息中间件/RocketMQ消息队列/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/消息中间件/RocketMQ消息队列/","excerpt":"","text":"[TOC] 一、前言消息即是信息的载体。为了让消息发送者和消息接收者都能够明白消息所承载的信息（消息发送者需要知道如何构造消息；消息接收者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。而消息从发送者到接收者的方式也有两种。一种我们可以称为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是我们已经介绍过的RPC（当然单纯的http通讯也满足这个定义）；另一种方式称为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列。 当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能。 本文主要选取RocketMQ来实现Web系统消息管理模块开发以介绍消息队列的的使用。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2019.02.19 1.0 ZZ 初稿 三、应用场景消息队列主要解决应用解耦，异步 通信 ，流量削锋等问题 异步处理：例如短信通知、终端状态推送、App推送、用户注册等 数据同步：业务数据推送同步 重试补偿：记账失败重试 系统解耦：通讯上下行、终端异常监控、分布式事件中心 流量消峰：秒杀场景下的下单处理 发布订阅：HSF的服务状态变化通知、分布式事件中心 高并发缓冲：日志服务、监控上报 三、消息模式3.1、点对点模式（point to point， queue）和发布/订阅模式（publish/subscribe，topic）。区别是：是否可以重复消费。 3.11、P2P模式P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。 P2P的特点： 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)； 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列； 接收者在成功接收消息之后需向队列应答成功。如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。 3.12、Pub/sub模式包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。 Pub/Sub的特点： 每个消息可以有多个消费者； 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息； 为了消费消息，订阅者必须保持运行的状态； 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。 3.2、推模式和拉模式：消息的更新者推(push)模式是一种基于C/S机制、由服务器主动将信息送到客户器的技术。拉（pull）模式与推模式相反，是由客户器主动发起的事务。 四、MQ性能对比及选型 特性 ActiveMQ RabbitMQ RocketMQ Kafka 成熟度 成熟 成熟 比较成熟 成熟 授权方式 开源 开源 开源 开源 开发语言 Java Erlang Java Scala&amp;Java 消息丢失 低 低 理论上不会丢失 理论上不会丢失 社区 Apache Mozilla Public License Ali Apache 社区活跃度 高 高 中 高 多语言 支持，JAVA优先 语言无关 Java，C++ （不成熟） 支持，JAVA优先 商业支持 无 无 阿里云 无 API完备性 高 高 高 高 文档的完备性 高 高 高 高 消息批量操作 支持 不支持 支持 支持 消息推拉模式 多协议，Pull/Push 均有支持 多协议,Pull/Push均有支持 多协议,Pull/Push均有支持 Pull 单机呑吐量 最差（万级） 其次（万级） 最高（十万级） 次之（十万级） 消息延迟 微秒级 比Kafka快 毫秒级 持久化能力 内存、文件、数据库 内存，文件 磁盘文件 磁盘文件 是否有序 可以支持有序 若想有序，只能使用一个Client 有序 多Client葆证有序 事务 支持 不支持 支持 不支持,但可以通过Low Level APH呆证仅消费一次” 集群 支持 支持 支持 支持 负载均街 支持 支持 支持 支持 管理界面 一般 较好 命令行界面 “Yahoo开源自己的Kafka Web管理界面Kafka -Manager” 部署方式 独立 独立 独立 独立 可用性 高 高 非常高（分布式） 非常高（分布式） 五、SpringBoot集成RocketMQRocketMQ是一个分布式消息传递和流媒体平台，是一款分布式、队列模型的消息中间件。具有低延迟，高性能和可靠性，万亿级容量和灵活的可扩展性。阿里开源的消息中间件，已经捐献给了 Apache 。 Github地址：https://github.com/apache/rocketmq/官方样例代码：https://github.com/apache/rocketmq/tree/master/example官方地址：https://rocketmq.apache.org/使用文档：https://rocketmq.apache.org/docs/quick-start/ 5.1、专业术语 Producer消息生产者，生产者的作用就是将消息发送到 MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 MQ。 Producer Group生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。 Consumer消息消费者，简单来说，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。 Consumer Group消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。 TopicTopic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。 MessageMessage 是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如你需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。 Tag标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。 BrokerBroker 是 RocketMQ 系统的主要角色，其实就是前面一直说的 MQ。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。 Name ServerName Server 为 producer 和 consumer 提供路由信息 5.2、安装部署RocketMQ服务器5.21、下载安装JDK略 5.22、安装Maven12&gt; sudo apt-get install maven&gt; mvn -version 5.24、下载RocketMQ源码并编译12345# cd /server/web 安装目录&gt; git clone -b develop https://github.com/apache/rocketmq.git&gt; cd rocketmq&gt; mvn -Prelease-all -DskipTests clean install -U&gt; cd distribution/target/apache-rocketmq 5.25、启动 name server12345# 启动命令,并且常驻内存# start mqnamesrv.cmd（window）&gt; nohup sh bin/mqnamesrv &amp;（Linux）# 查看启动日志能看到：The Name Server boot success字样则成功，按 ctrl+c 可直接关闭退出&gt; tail -f ~/logs/rocketmqlogs/namesrv.log 5.26、启动 broker123456# 启动命令，并且常驻内存:注意ip地址要配置成为服务的ip地址，保证地址以及端口能够访问# start mqbroker.cmd -n localhost:9876（window）&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;（Linux）# 查看启动日志&gt; tail -f ~/logs/rocketmqlogs/broker.log 5.27、关闭服务12&gt; sh bin/mqshutdown broker&gt; sh bin/mqshutdown namesrv 5.28、RocketMQ可视化监控界面 下载RocketMQ-console 找到application.properties,修改配置 123# 设置rocketmq-console的启动端口和需要监听的RocketMQ服务端的ip地址和端口号server.port=8888rocketmq.config.namesrvnameAddr=localhost:9876 用maven构建rocketmq-console， 1mvn clean package -Dmaven.test.skip=true 进入rocketmq-console\\target，找到编译好的jar包 12# 启动项目java -jar rocketmq-console-ng-1.0.0.jar 浏览器访问 http://localhost:8888 5.29、参考资料 Quick Start - 官网 RocketMQ 安装详细说明 RocketMQ之消息中间件需要解决的问题 5.3、SpringBoot集成RocketMQ pom.xml 123456&lt;!-- Rocketmq --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt;&lt;/dependency&gt; application.yml 12345678910apache: rocketmq: # 生产者的组名 producer: producerGroup: Producer # 消费者的组名 consumer: PushConsumer: PushConsumer # NameServer地址 namesrvAddr: localhost:9876 5.4、生产者Producer将业务应用程序系统生成的消息发送给Broker，RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列。 12```## 5.5、消费者Consumer 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 六、使用RocketMQ实现 Feed流 &amp; 通知模块Feed流是社交和信息推荐的App与网站中非常常见的功能，在众多产品中都有展现，通过Feed流可以把动态实时的传播给订阅者，是用户获取信息流的一种有效方式。比如我们每天都会用到的朋友圈，微博，就是一种非常典型的Feed流产品，很多App的都会有一个模块，要么叫动态，要么叫消息广场，这些也是Feed流产品，可以说，Feed流产品是遍布天下所有的App中。## 6.1、概念- Feed：Feed流中的每一条状态或者消息都是Feed，比如朋友圈中的一个状态就是一个Feed，微博中的一条微博就是一个Feed。- Feed流：持续更新并呈现给用户内容的信息流。每个人的朋友圈，微博关注页等等都是一个Feed流。- Timeline：按发布的时间顺序排序- Rank：按某个非时间的因子排序，一般是按照用户的喜好度排序- Aggregate：聚合类型- Notice：通知类型## 6.2、模块分析### 6.21、模实现功能介绍- 评论/回复/留言/私信/- 关注/转发- 应用通知/系统通知用户或管理员的以上行为均可构成一个Event事件，在事件分发中心被分发 事件分发可分为两类基于关注用户构造基于用户关系的Feed流需要如下表users: 用户表posts: 日志表followings: 关注/粉丝表events: 事件表基于关注标签tags：标签表优先级高：实时性消息中：服务器定时推送 Push低：客户端定时拉取 Pull- 句子结构分析 someone do something in someone’s something someone = 提醒的触发者，或者发送者，标记为senderdo something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为actionsomething = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为targetsomeone’s = 提醒的动作作用对象的所有者，标记为targetOwner` 6.22、消息管理模块实现的几种方法 短轮询 长轮询 长连接 WebSocket 双向通信 [x] Feed设计与实现 消息系统设计与实现「上篇」 消息系统设计与实现「下篇」 SNS（社交网络服务）_百度百科 七、拓展阅读八、参考资料 消息队列 RocketMQ_官网 消息队列使用的四种场景介绍 九、结语 文章仅作为个人学习总结之用，水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/通过Web页面上传下载功能实现","date":"2019-03-12T06:57:56.584Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/通过Web页面上传下载功能实现/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/通过Web页面上传下载功能实现/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.22 1.0 ZZ 初稿 三、概念解析六、相关术语七、拓展阅读八、参考资料 异常处理_百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/基于Bootstrap-Table的分页查询功能实现","date":"2019-03-12T06:57:56.584Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/基于Bootstrap-Table的分页查询功能实现/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/基于Bootstrap-Table的分页查询功能实现/","excerpt":"","text":"[TOC] 一、前言分页插件有许多种，比较常用的有Bootstrap Table / Bootstrap Paginator / PageHelper等。本文介绍Bootstrap Table的使用。 Bootstrap Table的分页可以分为 前端分页和后端分页，主要是看返回数据量的大小，比较常用的是后端分页。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.08.08 1.0 ZZ 初稿 2 2018.08.08 1.1 ZZ 统一接口返回格式 三、实例3.1、前端代码 pageHelp.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;!-- 公共CSS --&gt; &lt;link href=\"../../../style/common/bootstrap/css/bootstrap-table.min.css\" rel=\"stylesheet\"&gt; &lt;link href=\"../../../style/common/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"color: red; text-align: center\"&gt;&lt;h4&gt;服务端分页&lt;/h4&gt;&lt;/div&gt;&lt;!--采用JS代码方式来初始化表格插件，只须声明一个表格对象即可--&gt;&lt;table id=\"tab-1\" class=\"table table-hover\"&gt;&lt;/table&gt;&lt;div style=\"color: red; text-align: center\"&gt;&lt;h4&gt;客户端分页&lt;/h4&gt;&lt;/div&gt;&lt;table id=\"tab-2\" class=\"table table-hover\"&gt;&lt;/table&gt;&lt;/body&gt;&lt;!-- 公共JS --&gt;&lt;script src=\"../../../style/common/jquery/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../../../style/common/bootstrap/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../../../style/common/bootstrap/js/bootstrap-table.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../../../style/common/bootstrap/js/bootstrap-table-zh-CN.min.js\"&gt;&lt;/script&gt;&lt;!-- bootstrap-table拓展模块 - 导出 --&gt;&lt;script src=\"../../../style/common/bootstrap/js/bootstrap-table-export.js\"&gt;&lt;/script&gt; &lt;script src=\"../../../style/common/bootstrap/js/tableExport.min.js\"&gt;&lt;/script&gt;&lt;!-- 用户JS --&gt;&lt;script src=\"pageHelp-1.js\"&gt;&lt;/script&gt;&lt;script src=\"pageHelp-2.js\"&gt;&lt;/script&gt;&lt;/html&gt; pageHelp-1.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 服务端分页 * @author zz * @date 上午2:06 18-08-08 */$(function () &#123; // 初始化bootstrap-table的内容 var queryUrl = 'http://localhost:8080/SmartCity-Service/monitor/getLogByPage'; $('#tab-1').bootstrapTable(&#123; method: 'get', //请求方式（*） url: queryUrl, //请求后台的URL（*） // height: 500, //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度 cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*） pagination: true, //是否显示分页条（*） sidePagination: 'server', //分页方式：client客户端分页，server服务端分页（*） queryParams: queryParams, responseHandler: function (res) &#123; // 对返回的数据格式进行处理(因为统一过接口返回格式) return res.data; &#125;, pageNumber: 1, //初始化加载第一页，默认第一页,并记录 pageSize: 5, //每页的记录行数（*） pageList: [5, 10, 20, 30], //可供选择的每页的行数（*） striped: true, //是否显示行间隔色 search: true, //是否显示表格搜索 showRefresh: true, //是否显示刷新按钮 showColumns: true, //是否显示所有的列（选择显示的列） clickToSelect: true, //是否启用点击选中行 showToggle: true, //是否显示详细视图和列表视图的切换按钮 cardView: false, //是否显示详细视图 showExport: true, //是否数据导出按钮 exportDataType: \"all\", toolbar: '#toolbar', //指定工作栏 toolbarAlign: 'right', //工具栏对齐方式 buttonsAlign: 'right', //按钮对齐方式 columns: [ // field须与返回字段一一对应 &#123; checkbox: true, width: 25, align: 'center', valign: 'middle' &#125;, &#123; title: 'ID', field: 'id', visible: true, // 是否默认显示 sortable: true // 是否可排序 &#125;, &#123; title: '日志标题', field: 'title', sortable: true &#125;, &#123; title: '级别', field: 'level', sortable: true &#125;, &#123; title: '操作用户', field: 'userName', sortable: true &#125;, &#123; title: '操作时间', field: 'operTime', sortable: true &#125;, &#123; title: '请求IP', field: 'reqIp', sortable: true &#125;, &#123; title: 'URI', field: 'reqUri', &#125;, &#123; title: '请求方法', field: 'method' &#125;, &#123; title: '请求参数', field: 'operEvent' &#125;, &#123; title: '状态', field: 'operStatus', align: 'center', formatter: operateFormatter // 数据转义函数 &#125; ], locale: 'zh-CN', // 中文支持, &#125;) // 数据转义函数 function operateFormatter(value) &#123; if (value == 2) &#123; return '&lt;i class=\"fa fa-lock\" style=\"color:red\"&gt;&lt;/i&gt;' &#125; else if (value == 1) &#123; return '&lt;i class=\"fa fa-unlock\" style=\"color: #000;r:green\"&gt;&lt;/i&gt;' &#125; else &#123; return '数据错误' &#125; &#125; // 提交到服务器端的参数，前端动态赋值 function queryParams(params) &#123; return &#123; limit: params.limit, // 分页大小 offset: params.offset, // sql查询索引，offset=(pageIndex-1)*limit // Name: $('#search_name').val(), // Tel: $('#search_tel').val() &#125; &#125;&#125;) pageHelp-2.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 前端分页 * @author zz * @date 上午2:06 18-08-08 */$(function () &#123; // 初始化bootstrap-table的内容 var queryUrl = '../../../json/tableHelpData-2.json'; $('#tab-2').bootstrapTable(&#123; method: 'get', //请求方式（*） url: queryUrl, //请求后台的URL（*） // height: 500, //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度 cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*） pagination: true, //是否显示分页条（*） sidePagination: 'clinet', //分页方式：client客户端分页，server服务端分页（*） // queryParams: queryParams, responseHandler: function (res) &#123; // 对返回的数据格式进行处理(因为统一过接口返回格式) return res.data; &#125;, pageNumber: 1, //初始化加载第一页，默认第一页,并记录 pageSize: 5, //每页的记录行数（*） pageList: [5, 10, 20, 30], //可供选择的每页的行数（*） striped: true, //是否显示行间隔色 search: true, //是否显示表格搜索 showRefresh: true, //是否显示刷新按钮 showColumns: true, //是否显示所有的列（选择显示的列） clickToSelect: true, //是否启用点击选中行 showToggle: true, //是否显示详细视图和列表视图的切换按钮 cardView: false, //是否显示详细视图 showExport: true, //是否数据导出按钮 exportDataType: \"all\", toolbar: '#toolbar', //指定工作栏 toolbarAlign: 'right', //工具栏对齐方式 buttonsAlign: 'right', //按钮对齐方式 columns: [ &#123; checkbox: true, width: 25, align: 'center', valign: 'middle' &#125;, &#123; title: 'ID', field: 'id', visible: true, sortable: true &#125;, &#123; title: '父级', field: 'pid', sortable: true &#125;, &#123; title: '状态', field: 'status', sortable: true &#125;, &#123; title: '名称', field: 'name', sortable: true &#125;, &#123; title: '权限', field: 'permissionValue', sortable: true &#125; ], locale: 'zh-CN',//中文支持, &#125;) function operateFormatter(value, row, index) &#123; if (value == 2) &#123; return '&lt;i class=\"fa fa-lock\" style=\"color:red\"&gt;&lt;/i&gt;' &#125; else if (value == 1) &#123; return '&lt;i class=\"fa fa-unlock\" style=\"color:green\"&gt;&lt;/i&gt;' &#125; else &#123; return '数据错误' &#125; &#125; // 前端查询，提交到服务器端的参数，可无 // function queryParams(params) &#123; // return &#123; // // Name: $('#search_name').val(), // // Tel: $('#search_tel').val() // &#125; // &#125;&#125;) 3.2、请求返回数据如下所示，前端分页返回的是一个JSON格式数组，服务端分页返回的是一个必须包含total和rows字段的JSON格式数据（其他说明字段酌情添加）。 又由于我的接口统一过返回格式，故BootStrap-table接收数据后，需要做处理，添加如下代码。 12345$('#tab-1').bootstrapTable(&#123; responseHandler: function (res) &#123; // 对返回的数据格式进行处理(因为统一过接口返回格式) return res.data; &#125;&#125;) 实际上经测试，前端分页的情况下，不做处理也可以，也能找到正确的数据位置。 GET http://localhost:8080/SmartCity-Service/monitor/getLogByPage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#123; \"code\": 0, \"desc\": \"SUCCESS\", \"timestamp\": 1533674106829, \"data\": &#123; \"limit\": 10, \"page\": 1, \"rows\": [ &#123; \"id\": 1647, \"title\": \"用户登录\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533671221000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/submitLogin\", \"method\": \"submitLogin(),POST\", \"operEvent\": \"用户名=root\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1648, \"title\": \"进入主页，获取menu菜单\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533671221000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/menu\", \"method\": \"getMenus(),GET\", \"operEvent\": \"\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1649, \"title\": \"进入主页，获取menu菜单\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533671222000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/menu\", \"method\": \"getMenus(),GET\", \"operEvent\": \"\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1650, \"title\": \"用户登录\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533674035000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/submitLogin\", \"method\": \"submitLogin(),POST\", \"operEvent\": \"用户名=root\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1651, \"title\": \"进入主页，获取menu菜单\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533674036000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/menu\", \"method\": \"getMenus(),GET\", \"operEvent\": \"\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1652, \"title\": \"进入主页，获取menu菜单\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533674036000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/menu\", \"method\": \"getMenus(),GET\", \"operEvent\": \"\", \"operStatus\": 1, \"logDesc\": null &#125;, &#123; \"id\": 1653, \"title\": \"用户登录\", \"level\": \"INFO\", \"userName\": \"超级管理员\", \"operTime\": 1533674078000, \"reqIp\": \"0:0:0:0:0:0:0:1\", \"reqUri\": \"/manage/submitLogin\", \"method\": \"submitLogin(),POST\", \"operEvent\": \"用户名=root\", \"operStatus\": 1, \"logDesc\": null &#125; ], \"total\": 8 &#125;&#125; GET tableHelpData-2.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&#123; \"code\": 0, \"desc\": \"SUCCESS\", \"timestamp\": 1533674106829, \"data\": [ &#123; \"id\": 1, \"pid\": 0, \"status\": 1, \"name\": \"系统管理\", \"permissionValue\": \"open:system:get\" &#125;, &#123; \"id\": 2, \"pid\": 0, \"status\": 1, \"name\": \"字典管理\", \"permissionValue\": \"open:dict:get\" &#125;, &#123; \"id\": 3, \"pid\": 1, \"status\": 1, \"name\": \"新增系统\", \"permissionValue\": \"open:system:add\" &#125;, &#123; \"id\": 4, \"pid\": 1, \"status\": 1, \"name\": \"编辑系统\", \"permissionValue\": \"open:system:edit\" &#125;, &#123; \"id\": 5, \"pid\": 1, \"status\": 1, \"name\": \"删除系统\", \"permissionValue\": \"open:system:delete\" &#125;, &#123; \"id\": 6, \"pid\": 2, \"status\": 1, \"name\": \"系统环境\", \"permissionValue\": \"open:env:get\" &#125;, &#123; \"id\": 7, \"pid\": 33, \"status\": 1, \"name\": \"新增环境\", \"permissionValue\": \"open:env:add\" &#125;, &#123; \"id\": 8, \"pid\": 33, \"status\": 1, \"name\": \"编辑环境\", \"permissionValue\": \"open:env:edit\" &#125;, &#123; \"id\": 9, \"pid\": 33, \"status\": 0, \"name\": \"删除环境\", \"permissionValue\": \"open:env:delete\" &#125;, &#123; \"id\": 10, \"pid\": 0, \"status\": 1, \"name\": \"系统管理\", \"permissionValue\": \"open:system:get\" &#125;, &#123; \"id\": 11, \"pid\": 0, \"status\": 1, \"name\": \"字典管理\", \"permissionValue\": \"open:dict:get\" &#125;, &#123; \"id\": 12, \"pid\": 1, \"status\": 1, \"name\": \"新增系统\", \"permissionValue\": \"open:system:add\" &#125;, &#123; \"id\": 13, \"pid\": 1, \"status\": 1, \"name\": \"编辑系统\", \"permissionValue\": \"open:system:edit\" &#125;, &#123; \"id\": 14, \"pid\": 1, \"status\": 1, \"name\": \"删除系统\", \"permissionValue\": \"open:system:delete\" &#125;, &#123; \"id\": 15, \"pid\": 2, \"status\": 1, \"name\": \"系统环境\", \"permissionValue\": \"open:env:get\" &#125;, &#123; \"id\": 16, \"pid\": 33, \"status\": 1, \"name\": \"新增环境\", \"permissionValue\": \"open:env:add\" &#125;, &#123; \"id\": 17, \"pid\": 33, \"status\": 1, \"name\": \"编辑环境\", \"permissionValue\": \"open:env:edit\" &#125;, &#123; \"id\": 18, \"pid\": 33, \"status\": 0, \"name\": \"删除环境\", \"permissionValue\": \"open:env:delete\" &#125; ]&#125; 3.3、服务端代码前端分页，服务端的处理比较简单，只须查询所有数据，封装成JSON数组返回即可，故不做讲解。服务端分页，需要前端控件传入 limit、offset两个参数，后端配合sql语句进行查询。下面讲解服务端分页代码。 operLogController.java 1234567891011121314151617181920212223242526272829303132333435363738package com.lapland.monitor.controller;import com.lapland.common.controller.BaseController;import com.lapland.monitor.model.OperLog;import com.lapland.monitor.service.LogService;import com.lapland.tools.pageHelp.PageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 日志页面 * @author zz * @date 下午2:46 18-8-3 */@RestController@RequestMapping(\"/monitor\")public class operLogController extends BaseController &#123; @Resource(name = \"logService\") private LogService logService; /** * 日志页面分页查询 * @param offset * sql查询索引 * @param limit * 分页大小 * @return com.lapland.core.response.ServerResponse&lt;com.lapland.tools.pageHelp.PageHelper&lt;com.lapland.monitor.model.OperLog&gt;&gt; */ @RequestMapping(value = \"/getLogByPage\") public ServerResponse&lt;PageHelper&lt;OperLog&gt;&gt; getLogByPage(int offset, int limit) &#123; PageHelper&lt;OperLog&gt; operLog = logService.selectLogByPage(offset, limit); return ServerResponse.createSuccess(operLog); &#125;&#125; LogService.java 1234567891011121314151617181920package com.lapland.monitor.service;import com.lapland.monitor.model.OperLog;import com.lapland.tools.pageHelp.PageHelper;/** * 日志操作service接口 * @author zz * @date 上午9:55 18-7-25 */public interface LogService &#123; /** * 按照页码查询日志 - 用于服务端分页 * @param offset sql查询索引 * @param limit 分页大小 * @return com.lapland.tools.pageHelp.PageHelper&lt;com.lapland.monitor.model.OperLog&gt; */ PageHelper&lt;OperLog&gt; selectLogByPage(int offset, int limit);&#125; LogServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lapland.monitor.service.impl;import com.lapland.monitor.daoMapper.OperLogMapper;import com.lapland.monitor.model.OperLog;import com.lapland.monitor.service.LogService;import com.lapland.tools.pageHelp.PageHelper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * LogService实现类 * @author zz * @date 上午9:56 18-7-25 */@Service(value = \"logService\")public class LogServiceImpl implements LogService &#123; @Autowired private OperLogMapper operLogMapper; /** * 按照页码查询日志 - 用于服务端分页 * @param offset * sql查询索引 * @param limit * 分页大小 * @return com.lapland.tools.pageHelp.PageHelper&lt;com.lapland.monitor.model.OperLog&gt; */ public PageHelper&lt;OperLog&gt; selectLogByPage(int offset, int limit) &#123; PageHelper&lt;OperLog&gt; pageHelper = new PageHelper&lt;OperLog&gt;(); // 统计总记录数 Integer total = operLogMapper.getLogTotal(); pageHelper.setTotal(total); // 查询当前页实体对象 List&lt;OperLog&gt; list = operLogMapper.getLogByPage(offset, limit); pageHelper.setRows(list); pageHelper.setPage(offset / limit + 1); pageHelper.setLimit(limit); return pageHelper; &#125;&#125; OperLogMapper.java 123456789101112131415package com.lapland.monitor.daoMapper;import com.lapland.monitor.model.OperLog;import org.apache.ibatis.annotations.Param;import java.util.List;public interface OperLogMapper &#123; // 获取日志总条数 - 用于服务端分页 int getLogTotal(); // 获取分页日志 List&lt;OperLog&gt; getLogByPage(@Param(\"offset\") int offset, @Param(\"limit\") int limit);&#125; OperLogMapper.xml 123456789&lt;!--用户自定义 - 服务端分页--&gt;&lt;select id=\"getLogTotal\" resultType=\"int\"&gt; SELECT count(1) FROM t_log&lt;/select&gt;&lt;select id=\"getLogByPage\" resultMap=\"BaseResultMap\"&gt; SELECT * FROM t_log LIMIT #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; PageHelper.java 12345678910111213141516171819202122232425package com.lapland.tools.pageHelp;import lombok.Data;import java.util.ArrayList;import java.util.List;/** * 封装返回数据实体类 * @author zz * @date 下午9:40 18-8-7 */@Datapublic class PageHelper&lt;T&gt; &#123; // 分页大小 private int limit; // 页码 private int page; //实体类集合 private List&lt;T&gt; rows = new ArrayList&lt;T&gt;(); //数据总条数 private int total;&#125; OperLog.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.lapland.monitor.model;import com.alibaba.fastjson.annotation.JSONField;import lombok.Data;import java.io.Serializable;import java.util.Date;/** * 日志操作实体类,对应t_log表 * @author zz * @date 上午9:55 18-7-25 */@Datapublic class OperLog implements Serializable &#123; private static final long serialVersionUID = -8690056878905494181L; /** 日志唯一id */ private Long id; /** 日志标题,删除，新增，修改，查询，登录，退出 */ private String title; /** 日志级别 */ private String level; /** 操作用户Name */ private String userName; /** 操作时间 */ @JSONField(format = \"yyyy-MM-dd HH:mm:ss\") private Date operTime; /** 请求IP */ private String reqIp; /** 请求uri */ private String reqUri; /** 提交方式（GET,POST） */ private String method; /** 请求参数 */ private String operEvent; /** 操作状态（1：成功，2：失败） */ private int operStatus; /** 描述信息 */ private String logDesc;&#125; 3.4、sql分页查询语句123# SELECT * FROM t_log LIMIT startIndex,pageSize# SELECT * FROM t_log LIMIT (pageIndex - 1)*pageSize,pageSizeSELECT * FROM t_log LIMIT 0,10 四、显示效果 五、参考项目 bootstrapTable 五、参考资料 [x] Bootstrap Table 中文网 [x] Bootstrap Table的使用小结 [x] bootstrap table详细使用指南 六、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Lombok使用方法简介","date":"2019-03-12T06:57:56.580Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Lombok使用方法简介/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Lombok使用方法简介/","excerpt":"","text":"[TOC] 一、前言Lombok是一个可以通过注解的形式来帮助我们简化 Java 代码的工具。它可以帮助我们在编译生成getter / setter、构造函数、toString()、hashcode()等一些常用的方法的字节码文件，而在源码中不必写这些代码。 本文主要介绍如何使用Lombok插件来简化代码。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 官网地址 Github地址 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.06.25 1.0 ZZ 初稿 三、Lombok配置3.1、添加Lombok依赖123456&lt;!-- model生成其构造器、getter、setter、equals、hashcode、toString方法 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.0&lt;/version&gt;&lt;/dependency&gt; 3.2、添加IDEA插件 3.3、启用Annotation编译 File –&gt; Settings –&gt; Builder，Execution，Deployment –&gt; Compiler –&gt; Annotation Processors。选中下图中复选框 , 重启服务器。 四、Lombok使用4.1、Lombok注解下面只是介绍了几个常用的注解，更多的请参见https://projectlombok.org/features/index.html。 4.111、@Getter / @Setter可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。 4.112、@EqualsAndHashCode默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。 4.113、@ToString生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。 4.114、@NoArgsConstructor，@RequiredArgsConstructor，@AllArgsConstructor无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。 @NoArgsConstructor 生成一个无参数的构造方法 @RequiredArgsConstructor 会生成构造方法（可能带参数也可能不带参数），如果带参数，这参数只能是以final修饰的未经初始化的字段，或者是以@NonNull注解的未经初始化的字段。 @AllArgsConstructor 会生成一个包含所有变量，同时如果变量使用了NotNull annotation ， 会进行是否为空的校验。 4.115、@Data自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor。 4.116、@Log4j注解在类上；提供一个 属性名为log 的 log4j 日志对象，调用 log.info(xxxx)； 五、参考资料 lombok Java奇淫巧技之Lombok Lombok 之 Constructor 六、结语 待补充实例","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/国际化(i18n)应用","date":"2019-03-12T06:57:56.580Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/国际化(i18n)应用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/国际化(i18n)应用/","excerpt":"","text":"[TOC] 一、前言国际化（internationalization）是设计和制造容易适应不同区域要求的产品的一种方式。它要求从产品中抽离所有的与语言，国家／地区和文化相关的元素。换言之，应用程序的功能和代码设计考虑在不同地区运行的需要，其代码简化了不同本地版本的生产。开发这样的程序的过程，就称为国际化。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.22 1.0 ZZ 初稿 三、概念解析四、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.lapland.utils.i18n;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.DateFormat;import java.text.MessageFormat;import java.text.NumberFormat;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.ResourceBundle;/** * i18n_Test * jdk转换命令 -native2ascii（中文转Ascii编码） * @author zz * @date 上午4:10 18-7-20 */public class i18n_Test &#123; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(i18n_Test.class); @Test public void test() &#123; // 根据资源包基名和语言环境加载对应的语言资源文件 ResourceBundle bundler = ResourceBundle.getBundle(\"resources.MessageResource\", Locale.CHINA); LOGGER.info(bundler.getString(\"username\")); LOGGER.info(bundler.getString(\"password\")); LOGGER.info(bundler.getString(\"email\")+\"\\n\"); Locale locale = Locale.getDefault(); //Locale locale = new Locale(\"zh\", \"CN\"); //Locale locale = new Locale(\"en\", \"US\"); // 数值，货币格式化 NumberFormat numberFormat = NumberFormat.getCurrencyInstance(locale); double i = 123456.78; LOGGER.info(numberFormat.format(i) + \"\\n\"); // 日期，时间格式化 Date date = new Date(); DateFormat dateFormat_0 = DateFormat.getDateInstance(DateFormat.LONG, locale); DateFormat dateFormat_1 = DateFormat.getTimeInstance(DateFormat.FULL, locale); DateFormat dateFormat_2 = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, locale); LOGGER.info(dateFormat_0.format(date)); LOGGER.info(dateFormat_1.format(date)); LOGGER.info(dateFormat_2.format(date) + \"\\n\"); // 文本格式化 String pattern1 = \"&#123;0&#125;，你好！你于 &#123;1&#125; 在工商银行存入 &#123;2&#125; 元。\"; String pattern2 = \"At &#123;1,time,short&#125; On &#123;1,date,long&#125;，&#123;0&#125; paid &#123;2,number, currency&#125;.\"; Object[] params_1 = &#123;\"John\", new GregorianCalendar().getTime(), 1.0E3&#125;; //使用默认本地化对象格式化信息 String msg1 = MessageFormat.format(pattern1, params_1); //使用指定的本地化对象格式化信息 MessageFormat mf = new MessageFormat(pattern2, Locale.US); String msg2 = mf.format(params_1); LOGGER.info(msg1); LOGGER.info(msg2 + \"\\n\"); // 资源文件动态文本格式化 String pattern_A = bundler.getString(\"message\"); Object[] params_A = &#123;dateFormat_0.format(date), 99, 100000000&#125;; MessageFormat format_A = new MessageFormat(pattern_A, Locale.CHINA); String msg_A = format_A.format(params_A); LOGGER.info(msg_A); &#125;&#125; 五、拓展阅读 Spring MVC异常统一处理(异常信息的国际化,日志记录) 六、参考资料 [x] 国际化(i18n) [x] jquery-i18n-properties国际化 [x] 深入理解spring国际化 七、结语 此篇仅为测试代码，须继续在实际项目中验证完善。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Redis缓存","date":"2019-03-12T06:57:56.568Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Redis缓存/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Redis缓存/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/OSWorkFlow工作流框架","date":"2019-03-12T06:57:56.568Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/OSWorkFlow工作流框架/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/OSWorkFlow工作流框架/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Quartz任务调度框架 - 实现动态定时任务","date":"2019-03-12T06:57:56.564Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Quartz任务调度框架 - 实现动态定时任务/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Quartz任务调度框架 - 实现动态定时任务/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.12.18 1.0 ZZ 初稿 2 2018.11.30 1.1 ZZ 更新quartz.xml 三、概念解析3.1、占位 scheduler：任务调度器 trigger：触发器，用于定义任务调度时间规则 job：任务，即被调度的任务 misfire：错过的，指本来应该被执行但实际没有被执行的任务调度 Quartz 组件关系图 四、正文 spring-context-quartz.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;beans&gt; &lt;!-- 配置quartz定时任务 --&gt; &lt;bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"simpleTrigger_init\"/&gt; &lt;ref bean=\"simpleTrigger_6h\"/&gt; &lt;ref bean=\"cronTrigger_6h\"/&gt; &lt;ref bean=\"simpleTrigger_20min\"/&gt; &lt;ref bean=\"cronTrigger_20min\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Trigger - 单位:ms， 配置项目启动后任务就执行一次 --&gt; &lt;bean id=\"simpleTrigger_init\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\" ref=\"Job_init\"/&gt; &lt;property name=\"startDelay\" value=\"1000\"/&gt; &lt;property name=\"repeatInterval\" value=\"0\"/&gt; &lt;property name=\"repeatCount\" value=\"0\"/&gt; &lt;/bean&gt; &lt;!-- Job - 初始化 --&gt; &lt;bean id=\"Job_init\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\" ref=\"job_init\"/&gt; &lt;property name=\"targetMethod\" value=\"execute\"/&gt; &lt;/bean&gt; &lt;!-- Trigger - 单位:ms， 配置项目启动后任务就执行一次 --&gt; &lt;bean id=\"simpleTrigger_20min\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\" ref=\"Job_20min\"/&gt; &lt;property name=\"startDelay\" value=\"1000\"/&gt; &lt;property name=\"repeatInterval\" value=\"0\"/&gt; &lt;property name=\"repeatCount\" value=\"0\"/&gt; &lt;/bean&gt; &lt;!-- Trigger - 每隔20min执行一次 --&gt; &lt;bean id=\"cronTrigger_20min\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\" ref=\"Job_20min\"/&gt; &lt;property name=\"cronExpression\" value=\"0 0/20 * * * ?\"/&gt; &lt;/bean&gt; &lt;!-- Job - 每隔20min执行一次 --&gt; &lt;bean id=\"Job_20min\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\" ref=\"job_20min\"/&gt; &lt;property name=\"targetMethod\" value=\"execute\"/&gt; &lt;property name=\"concurrent\" value=\"true\"/&gt; &lt;/bean&gt; &lt;!-- Trigger - 单位:ms， 配置项目启动后任务就执行一次 --&gt; &lt;bean id=\"simpleTrigger_6h\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\" ref=\"Job_6h\"/&gt; &lt;property name=\"startDelay\" value=\"1000\"/&gt; &lt;property name=\"repeatInterval\" value=\"0\"/&gt; &lt;property name=\"repeatCount\" value=\"0\"/&gt; &lt;/bean&gt; &lt;!-- Trigger - 每隔6小时执行一次 --&gt; &lt;bean id=\"cronTrigger_6h\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\" ref=\"Job_6h\"/&gt; &lt;property name=\"cronExpression\" value=\"0 0 0/6 * * ?\"/&gt; &lt;/bean&gt; &lt;!-- Job - 每隔6小时执行一次 --&gt; &lt;bean id=\"Job_6h\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\" ref=\"job_6h\"/&gt; &lt;property name=\"targetMethod\" value=\"execute\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Job_6h.java 12345678910@Component(\"job_6h\")public class Job_6h &#123; private final static Logger LOGGER = LoggerFactory.getLogger(Job_6h.class); public void execute() &#123; LOGGER.info(\"+++++++ 6h定时任务执行Start +++++\"); &#125;&#125; 八、参考资料 [x] 在线Cron表达式生成器 [x] Quartz - 官方文档 Quartz使用总结 Quartz总结 Quartz定时任务（附demo）九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]浅谈Java项目日志记录和分析 (基于log4j介绍)","date":"2019-03-12T06:57:56.556Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]浅谈Java项目日志记录和分析 (基于log4j介绍)/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]浅谈Java项目日志记录和分析 (基于log4j介绍)/","excerpt":"","text":"[TOC] 一、前言日志记录是应用程序运行中必不可少的一部分。具有良好格式和完备信息的日志记录可以在程序出现问题时帮助开发人员迅速地定位错误的根源。记录日志只是有效地利用日志的第一步，更重要的是如何对程序运行时产生的日志进行处理和分析。 一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标： 对程序运行情况的记录和监控； 在必要时可详细了解程序内部的运行状态； 对系统性能的影响尽量小。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、日志基础1、日志组件 Java日志API由以下三个核心组件组成： Loggers：负责捕捉事件并将其发送给合适的Appender。 Appenders：也称为Handlers，它负责接收日志事件，使用Layout格式化，然后输出到指定位置。 Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。 2、日志框架在Java中，输出日志需要使用一个或者多个日志框架，这些框架提供了必要的对象、方法和配置来传输消息。Java在java.util.logging包中提供了一个默认的框架。除此之外，还有很多其它第三方框架，包括Log4j、Logback以及tinylog。还有其它一些开发包，例如SLF4J和Apache Commons Logging，它们提供了一些抽象层，对你的代码和日志框架进行解耦，从而允许你在不同的日志框架中进行切换。 Java Logging API （Oracle） Java默认的日志框架 Log4j （Apache） 开源日志框架 Logback （Logback Project） 开源项目，被设计成Log4j版本1的后续版本 tinylog （tinylog） 轻量级开源logger 3、日志抽象层诸如SLF4J这样的抽象层，会将你的应用程序从日志框架中解耦。应用程序可以在运行时选择绑定到一个特定的日志框架（例如java.util.logging、Log4j或者Logback），这通过在应用程序的类路径中添加对应的日志框架来实现。如果在类路径中配置的日志框架不可用，抽象层就会立刻取消调用日志的相应逻辑。抽象层可以让我们更加容易地改变项目现有的日志框架，或者集成那些使用了不同日志框架的项目。 4、日志配置尽管所有的Java日志框架都可以通过代码进行配置，但是大部分配置还是通过外部配置文件完成的。这些文件决定了日志消息在何时通过什么方式进行处理，日志框架可以在运行时加载这些文件。 4.1、配置实例Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties格式的文件。比较常用的是properties文件。 properties格式 1234567891011121314151617181920212223242526272829303132# ====================================================================== ## 配置根 logger (日志级别, 输出位置)log4j.rootLogger=INFO, fileI, fileE, Console# ====================================================================== ## 控制台输出 Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.Target=System.outlog4j.appender.Console.layout=$&#123;log4j.log.layout&#125;log4j.appender.Console.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;# ====================================================================== ## 文件输出 fileInfolog4j.appender.fileI=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.fileI.Threshold = INFOlog4j.appender.fileI.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.fileI.File=$&#123;log4j.log.layout.baseFile&#125;_info.loglog4j.appender.fileI.layout=$&#123;log4j.log.layout&#125;log4j.appender.fileI.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;# ====================================================================== ## 文件输出 fileErrorlog4j.appender.fileE=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.fileE.Threshold = ERRORlog4j.appender.fileE.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.fileE.File=$&#123;log4j.log.layout.baseFile&#125;_error.loglog4j.appender.fileE.layout=$&#123;log4j.log.layout&#125;log4j.appender.fileE.layout.ConversionPattern=$&#123;log4j.log.layout.pattern&#125;# ====================================================================== ## 配置参数log4j.log.encoding=UTF-8log4j.log.layout=org.apache.log4j.PatternLayoutlog4j.log.layout.pattern=[%-5p] [%-21t:%r] - %m%nlog4j.log.layout.baseFile=D\\://apache-tomcat-7.0.70_log/AnjiOnline# ====================================================================== # XML格式 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration PUBLIC \"-//log4j/log4j Configuration//EN\" \"log4j.dtd\"&gt;&lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt; &lt;appender name=\"RollingAppender\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"logs/info.log\" /&gt; &lt;param name=\"Encoding\" value=\"UTF-8\" /&gt; &lt;param name=\"DatePattern\" value=\"'.'yyyy-MM-dd\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[%p] %d %c %M - %m%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;priority value=\"DEBUG\" /&gt; &lt;appender-ref ref=\"RollingAppender\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 4.2、配置说明4.2.1、rootLogger log4j.rootLogger = [ level ] , appenderName, appenderName, … level：是log4j的日志级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。appenderName：就是指定日志信息输出到哪个地方。可同时指定多个输出目的地。 4.2.2、配置日志信息输出目的地Appender，其语法为：1234567891011log4j.appender.appenderName = fully.qualified.name.of.appender.classlog4j.appender.appenderName.option1 = value1...log4j.appender.appenderName.optionN = valueN# 其中,Log4j提供的appender有以下几种:org.apache.log4j.ConsoleAppender（控制台）;org.apache.log4j.FileAppender（文件）;org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）;org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）;org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 4.2.3、置好appender后，针对appender的配置4.2.3.1、.ConsoleAppender选项 Threshold=WARN：指定日志消息的输出最低层次。 ImmediateFlush=true：默认值是true,意谓着所有的消息都会被立即输出。 Target=System.err：默认情况下是：System.out,指定输出控制台 4.2.3.2、.FileAppender 选项 Threshold=WARN：指定日志消息的输出最低层次。 ImmediateFlush=true：默认值是true,意谓着所有的消息都会被立即输出。 File=mylog.txt：指定消息输出到mylog.txt文件。 Append=false：默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。 4.2.3.3、.DailyRollingFileAppender 选项 Threshold=WARN：指定日志消息的输出最低层次。 ImmediateFlush=true：默认值是true,意谓着所有的消息都会被立即输出。 File=mylog.txt：指定消息输出到mylog.txt文件。 Append=false：默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。 DatePattern=’.’yyyy-ww：每周滚动一次文件，即每周产生一个新的文件。当然也可以指定按月、周、天、时和分。即对应的格式如下： ‘.’yyyy-MM：每月 ‘.’yyyy-ww: 每周 ‘.’yyyy-MM-dd: 每天 ‘.’yyyy-MM-dd-a: 每天两次 ‘.’yyyy-MM-dd-HH: 每小时 ‘.’yyyy-MM-dd-HH-mm: 每分钟 4.2.3.4、.RollingFileAppender 选项 Threshold=WARN：指定日志消息的输出最低层次。 ImmediateFlush=true：默认值是true,意谓着所有的消息都会被立即输出。 File=mylog.txt：指定消息输出到mylog.txt文件。 Append=false：默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。 MaxFileSize=100KB：后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件 MaxBackupIndex=2：指定可以产生的滚动文件的最大数。 4.2.4、配置日志信息的布局，其语法为：12345678910log4j.appender.appenderName.layout = fully.qualified.name.of.layout.classlog4j.appender.appenderName.layout.option1 = value1...log4j.appender.appenderName.layout.option = valueN# 其中，Log4j提供的layout有以下几种：org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 4.2.5、打印参数如下： %d：输出日志时间点的日期或时间，默认格式为ISO8601。 %t：输出产生该日志线程的线程名。 %c：输出所属的类目，通常就是所在类的全名。 %p：输出日志级别。 %m：输出代码中指定的消息。 %n：输出一个回车换行符。 %r：输入自应用启动到输出该log信息耗费的毫秒数。 %l：输出日志事件发生的位置，包括类名、线程名，以及所在代码的行数。 4.3、日志级别SLF4J把Log由高到低分成了Error，Warn，Info，Debug和Trace五个级别。我们可以分成用户级别和开发级别。 4.3.1 用户级别Error、Warn和Info这三个级别的Log会出现在生产环境上，他们必须是运维人员能阅读明白的 4.3.1.1 Error 影响到程序正常运行、当前请求正常运行的异常情况,例如： 打开配置文件失败 第三方应用网络连接异常 SQLException 不应该出现的情况，例如： 某个Service方法返回的List里面应该有元素的时候缺获得一个空List 做字符转换的时候居然报错说没有GBK字符集 4.3.1.2 Warn 不应该出现但是不影响程序、当前请求正常运行的异常情况，例如： 有容错机制的时候出现的错误情况 找不到配置文件，但是系统能自动创建配置文件 即将接近临界值的时候，例如： 缓存池占用达到警告线 4.3.1.3 Info 系统运行信息 Service方法的出入口 主要逻辑中的分步骤 外部接口部分 客户端请求参数和返回给客户端的结果 调用第三方时的调用参数和调用结果 4.3.2 开发级别Debug和Trace这俩个级别主要是在开发期间使用或者当系统出现问题后开发人员介入调试的时候用的，需要有助于提供详细的信息。 4.3.2.1 Debug 用于记录程序变量，例如： 多次迭代中的变量 用于替代代码中的注释 4.3.2.2 Trace主要用于记录系统运行中的完整信息，比如完整的HTTP Request和Http Response 5、调用实例1234567891011121314151617181920212223242526272829303132333435package com.demo;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 日志管理的Demo */public class LoggingDemo &#123; private Integer a = 1; private Integer b = 0; private String name = \"图灵\"; // 创建LOGGER private final static Logger LOGGER = LoggerFactory.getLogger(LoggingDemo.class); @Test public void LoggingDemo() &#123; try &#123; LOGGER.debug(\"读取被除数b的值为[&#123;&#125;]\", b); LOGGER.info(\"读取配置文件[&#123;&#125;]\", \"/src/main/resources/config.properties\"); LOGGER.warn(\"添加[&#123;&#125;]为管理员\", name); a = a / b; System.out.println(\"--&gt;出现异常后,try内异常后面的代码不再执行,所以try范围不能过大\"); &#125; catch (ArithmeticException e) &#123; // e.printStackTrace(); LOGGER.error(\"被除数不能为0\", e); &#125; finally &#123; System.out.println(\"--&gt; finally内的代码始终被执行\"); &#125; System.out.println(\"--&gt; 异常捕获后,try外的代码正常执行\"); &#125;&#125; 三、日志记录的注意点通常情况下在程序日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。 如何正确的写日志 合理使用日志分级； 正确的使用输出模式； 尽量带入上下文的信息； 尽量不要包含敏感信息； 变量用[]与普通文本区分开来； 日志信息应该简洁,易读,易解析； 不允许出现printStackTrace、println语句。 那些地方需要写日志 任何业务异常都应该记下来完整的异常信息； 非预期执行，为程序在“有可能”执行到的地方打印日志； 程序中对外部系统与模块的依赖调用前后都记下日志，方便接口调试； 程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程； 系统入口与出口，这个粒度可以是重要方法级或模块级。记录它的输入与输出，方便定位。 具体参考：阿里巴巴JAVA编程规范之异常日志 四、pom.xml参考模板123456789101112131415161718192021222324252627&lt;properties&gt; &lt;!-- log4j版本号 --&gt; &lt;slf4j.version&gt;1.7.5&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt;&lt;dependencies&gt; 五、配置过程中遇到的问题 如何以json格式输出日志 日志输出路径没有权限的问题 如何把日志写入数据库或发送邮件 六、日志分析工具 一个Java写的日志分析工具 ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台 用Kibana和logstash快速搭建实时日志查询、收集与分析系统 七、拓展阅读 使用AOP与注解记录Java日志的方法 八、参考资料 Java日志终极指南 Slf4j提供的最佳实践 正确使用日志的10个技巧 阿里巴巴JAVA编程规范之异常日志 程序那些事：日志记录的作用和方法 JAVA - 优雅的记录日志（log4j实战篇） Java程序员修炼之道 之 Logging(2/3) - 怎么写Log java日志组件介绍（common-logging，log4j，slf4j，logback ） 九、结语 本文缺少日志分析和源码分析部分内容，仅适用于小型项目应用参考，有待后续完善。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]跨域问题的几种解决方法","date":"2019-03-12T06:57:56.552Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]跨域问题的几种解决方法/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]跨域问题的几种解决方法/","excerpt":"","text":"[TOC] 一、 前言二、 版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 2 2017.12.26 1.0 ZZ 完善 CORS + Demo 三、为什么会产生跨域问题域名、协议、端口者都相同就是同一个域，否则就是跨域。 JavaScript出于安全方面的考虑，采取了同源策略，即当前域的客户端脚本不允许在没有明确授权的情况下，读取其他域的资源。如果没有同源策略，那么一旦误执行了恶意网站的js脚本，该js脚本便可以随意获取其他域页面document、session、cookie等信息，很不安全。 然而我们经常把网站的一些脚本、图片或其他资源放到静态服务器，页面可以更快的加载，而且减少了Web服务器的压力。或者系统间接口调用。这时就产生了跨域问题。 eg：console 报错如下（端口不同）： 1XMLHttpRequest cannot load http://localhost:8888/other/index.jsp. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:8080&apos; is therefore not allowed access. 四、如何解决跨域问题4.1、代理服务器一种简单的办法，就是把跨域的工作交给服务器，从后台获取其他站点的数据再返回给前台，也就是跨域代理（Cross Domain Proxy）。这种方法似乎蛮简单的，改动也不太大。不过就是http请求多了些，响应慢了些，服务器的负载重了些。 4.2、通过jQuery实现JSONP的方式实现跨域 JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。 JSONP实现跨域请求的原理是动态创建标签，然后利用的src 不受同源策略约束来跨域获取数据。 JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 前端ajax请求： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;button id=\"btn_jsonp\" onclick=\"jsonp_function()\"&gt;HttpApi - JSONP点击&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type = \"text/javascript\"&gt; function jsonp_function()&#123; // $(\"#btn\").click(function() &#123; $.ajax(&#123; async: true, url: \"http://localhost:8080/ApiDemo_Yshow/Student/getStudentList\", type: \"GET\", dataType : \"jsonp\", // 返回的数据类型，设置为JSONP方式 jsonp : 'callback', // 回调函数名形参 url?callback = call_back jsonpCallback: 'call_back', // 回调函数名实参 success: function(data, status) &#123; console.log('状态为：' + status); console.log(data); &#125; &#125;); // &#125;); &#125; &lt;/script&gt;&lt;/html&gt; 服务端处理请求： 12345678910111213141516171819202122232425262728package com.api.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import com.alibaba.fastjson.JSON;import com.api.common.ListResponse;import com.api.model.Student;import com.api.service.StudentService;@Controller@RequestMapping(\"/Student/\")public class StudentController &#123; @Autowired StudentService studentService; @RequestMapping(value = \"getStudentList\", produces=\"text/html;charset=UTF-8\") @ResponseBody public String getStudentList(String callback) &#123; // 回调函数名也可以写死 ListResponse&lt;Student&gt; studentList = studentService.getStudentList(); return callback+\"(\"+JSON.toJSONString(studentList)+\")\"; &#125;&#125; 服务端返回的数据格式如下： 123456789101112131415161718call_back(&#123; \"items\": [ &#123; \"age\": 21, \"classes\": \"173521班\", \"id\": 1, \"name\": \"张敏\", \"sex\": \"女\" &#125;, &#123; \"age\": 21, \"classes\": \"173521班\", \"id\": 2, \"name\": \"江南\", \"sex\": \"男\" &#125; ]&#125;) 如上述代码所示jQuery实现jsonp调用的步骤是： 浏览器端定义回调函数作为url参数传送到服务端。url?callback = call_back。 服务端接收到参数后根据参数名+data数据封装成js函数格式的数据返回到浏览器端。 浏览器端接受到数据后执行回调函数，Jquery中为success函数。执行返回的js代码。 从而得到data数据。 JSONP是较为常用的一种跨域方式，不受浏览器兼容性的限制，然而它支持GET请求，RESTful架构并不适用。 4.3、通过CORS实现跨域（推荐） 跨域资源共享（Cross-Origin Resource Sharing）是由W3C提出的一个用于浏览器以XMLHttpRequest方式向其他源的服务器发起请求的规范。不同于JSONP，CORS是以Ajax方式进行跨域请求，需要服务端与客户端的同时支持。目前CORS在绝大部分现代浏览器中都是支持的。 前端ajax请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;button id=\"btn_cors\" onclick=\"CORS_function()\"&gt;HttpApi - CORS点击&lt;/button&gt; &lt;button id=\"btn_cors\" onclick=\"RESTCORS_function()\"&gt;RESTApi - GET - CORS点击&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;!--HttpApi - CORS解决跨域，简单请求--&gt;&lt;script type=\"text/javascript\"&gt; function CORS_function() &#123; $.ajax(&#123; async: true, url: \"http://localhost:8080/ApiDemo_Yshow/Student/getStudentByName\", type: \"POST\", dataType: \"json\", data: &#123; \"name\": \"江南\" &#125;, success: function(data, status) &#123; console.log('状态为：' + status); console.log(data); var data = JSON.stringify(data,null,4); $(\"#backData\").html(data); &#125;, error: function() &#123; $(\"#backData\").html(\" 数据请求失败!\"); &#125; &#125;); &#125;&lt;/script&gt;&lt;!--RESTApi - CORS解决跨域--&gt;&lt;script type=\"text/javascript\"&gt; function RESTCORS_function() &#123; $.ajax(&#123; async: true, url: \"http://localhost:8080/ApiDemo_Yshow/user/\", type: \"GET\", dataType: \"json\", //contentType: \"application/json\", // 提交数据类型，application/json编码默认UTF-8 //data: &#123; // \"name\": \"江南\" //&#125;, success: function(data, status) &#123; console.log('状态为：' + status); console.log(data); var data = JSON.stringify(data,null,4); $(\"#backData\").html(data); &#125;, error: function() &#123; $(\"#backData\").html(\" 数据请求失败!\"); &#125; &#125;); &#125;&lt;/script&gt;&lt;/html&gt; 服务端处理请求 - 方法1 - setHearder： 12345678910111213141516171819202122232425262728293031package com.api.controller;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.api.common.SingleResponse;import com.api.service.StudentService;@Controller@RequestMapping(\"/Student/\")public class StudentController &#123; @Autowired StudentService studentService; @RequestMapping(value = \"getStudentByName\") @ResponseBody public SingleResponse getStudentByName(@RequestParam(value = \"name\", required = false) String name,// HttpServletResponse response) &#123; SingleResponse student = studentService.getStudentByName(name); response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH\"); return student; &#125;&#125; 服务端处理请求 - 方法2 - @CrossOrigin 注释（SpringMVC4.2以上） 12345678910111213141516171819202122232425262728package com.api.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import com.api.common.SingleResponse;import com.api.service.StudentService;@Controller@RequestMapping(&quot;/Student/&quot;)public class StudentController &#123; @Autowired StudentService studentService; @CrossOrigin(origins = &quot;*&quot;, maxAge = 3600) @RequestMapping(value = &quot;getStudentByName&quot;,method = RequestMethod.POST) @ResponseBody public SingleResponse getStudentByName(String name) &#123; SingleResponse student = studentService.getStudentByName(name); return student; &#125;&#125; 服务端处理请求-方法3 - 自定义CORSFilter - web.xml 12345678&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.restApi.configuration.CORSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 12345678910111213141516171819202122232425262728293031package com.restApi.configuration;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;public class CORSFilter implements Filter &#123; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PUT, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with\"); chain.doFilter(req, res); &#125; @Override public void init(FilterConfig filterConfig) &#123;&#125; @Override public void destroy() &#123;&#125;&#125; 服务端处理请求-方法4 - 第三方CORSFilter - web.xml 123456789101112131415161718192021222324252627282930313233&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt; &lt;param-value&gt;GET,POST,HEAD,OPTIONS,PUT&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt; &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers,自定义header&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt; &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.support.credentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.preflight.maxage&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 五、参考资料 Jsonp解决ajax跨域问题 跨域资源共享 CORS 详解 ajax jsonp跨域乱码解决方案 解决ajax跨域的方法原理详解_cnsd Ajax跨域问题的两种解决方法 _博客园 说说JSON和JSONP，也许你会豁然开朗 SpringMVC开启CORS支持 java 服务端设置跨域 CORS解决ajax跨域问题 六、结语 本文仅用于学习笔记。初始版本比较粗糙,后续会不断完善。 六、遗留问题 OPTIONS 403 (Forbidden)","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/websocket总结","date":"2019-03-12T06:57:56.552Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/websocket总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/websocket总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成富文本编辑器","date":"2019-03-12T06:57:56.540Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成富文本编辑器/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成富文本编辑器/","excerpt":"","text":"ckkindEditor","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]Java加密部署，使用自定义的classloader解密的方法实例","date":"2019-03-12T06:57:56.540Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]Java加密部署，使用自定义的classloader解密的方法实例/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/[已发布]Java加密部署，使用自定义的classloader解密的方法实例/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 1. 简介使用jfinalQ-encrypt开源软件。对项目的class文件加密，防止反编译，可自定义加密解密算法，支持tomcat部署。 2.jfinalQ-encrypt 项目结构 3. 流程 2.1 首先将class文件进行字节流加密；2.2 然后自定义tomcat的ClassLoader；2.3 最后通过自定义的ClassLoader解密并加载class。 二、加密本节以Test项目为例，对其class文件进行加密。并用自定义的classloader进行解密。 1. Test项目目录结构 1.1 web.xml 配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.demo.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 1.2 HelloServlet代码123456789101112131415161718192021222324252627package com.demo;import java.io.IOException;/** * 请求地址 ：http://localhost:8080/Test/HelloServlet */public class HelloServlet extends HttpServlet &#123; // handle post request private static final long serialVersionUID = 1L; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(\"userName\"); response.setContentType(\"text/html\"); response.setCharacterEncoding(\"UTF-8\"); PrintWriter out = response.getWriter(); out.println(\"欢迎你: \"+new String(name.getBytes(\"ISO-8859-1\"), \"UTF-8\")+ \"!\"); &#125; // destroy public void destroy() &#123; &#125;&#125; 1.3 前端页面代码1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" pageEncoding=\"UTF-8\" language=\"java\"%&gt;&lt;!-- 请求地址： localhost:8080/Test/index.jsp --&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;HelloServlet&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"HelloServlet\" name=\"form\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"userName\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 此时部署成功后经测试，tomcat下class文件可以轻松反编译，JSP页面可正常访问servlet文件。接下来对class文件进行加密。 2. 加密解密算法，可修改 3. 运行QEncryptFrame.java文件 选择需要加密的文件 加密成功后显示 4. 把生成的加密后的class文件拷贝到源class文件的位置。 覆盖完成后，不要做修改代码，clean等操作，否则加密后的class会被再次覆盖。 5. 测试 此时再对class文件进行反编译，则如下报错 并且JSP文件不可正常请求servlet 点击登录后返回 三、解密1. 配置 loader.properties 文件 此配置文件指定了自定义的ClassLoader需要进行解析的classs文件范围。 12encrypted_package=com.demoencrypted_class_path=D\\:/apache-tomcat-7.0.70/webapps/Test/WEB-INF/classes/ encrypted_package 需要进行解密的包，多个包名用逗号分隔； encrypted_class_path tomcat中项目的classess文件夹路径。 2. 打包自定义classloader文件 将jfinalQ-encrypt中的loader包和QClassUtil打为一个jar，并命名为++classloaderQ.jar++，如下图所示： 3. 更改tomcat的默认loader，改为自定义classloader 修改tomcat/conf/context.xml文件，添加如下代码： 1&lt;Loader loaderClass=\"com.uikoo9.loader.QClassLoader\" delegate=\"true\"&gt;&lt;/Loader&gt; 4. 替换jar包 把classloaderQ.jar放到Tomcat的lib（D:\\apache-tomcat-7.0.70\\lib）文件夹下面。 5. 测试 对class文件进行反编译，报错 JSP文件可正常请求servlet. 点击登录后返回页面 测试成功 四、源码 源码下载 五、结语 由于时间原因，jfinalQ-encrypt源代码没能细读，只能做到初步应用，此文有待逐步后续完善。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成Markdown工具","date":"2019-03-12T06:57:56.540Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成Markdown工具/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成Markdown工具/","excerpt":"","text":"editor.md","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成思维导图工具","date":"2019-03-12T06:57:56.536Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成思维导图工具/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/网页集成思维导图工具/","excerpt":"","text":"开源思维导图工具","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Springboot使用Hibernate-validator进行参数校验","date":"2019-03-12T06:57:56.528Z","updated":"2019-02-19T01:45:22.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Springboot使用Hibernate-validator进行参数校验/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/第三方组件应用/Springboot使用Hibernate-validator进行参数校验/","excerpt":"","text":"[TOC] 一、前言在开发中经常需要字段校验，如字段非空，字段长度限制，邮箱格式验证等。如果这些都拿到业务中来 处理，则会使代码冗长，重复，并且此类的代码与主线业务逻辑关系不大，相互耦合在一起显得层结构不清。因此，我们选用Hibernate-validator框架进行参数校验。 Hibernate Validator 的作用 验证逻辑与业务逻辑之间进行了分离，降低了程序耦合度；统一且规范的验证方式，无需你再次编写重复的验证代码；你将更专注于你的业务，将这些繁琐的事情统统丢在一边。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2019.02.11 1.0 ZZ 初稿 三、添加依赖 spring-boot-starter-web包里面有hibernate-validator包，不需要引用hibernate validator依赖。 非SpringBoot中的依赖为 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt; 四、Hibernate Validator 的使用Hibernate Validator主要有 @Valid注解 和 封装工具类 两种进行入参校验方式 4.1、Java对象添加约束注解12345678910111213141516public class Account &#123; private String id; @NotNull @Length(max = 20) private String userName; @NotNull(message = \"密码不能为空\", groups = &#123;AddGroup.class, UpdateGroup.class&#125;) @Pattern(regexp = \"[A-Z][a-z][0-9]\") private String passWord; @DateTimeFormat(pattern = \"yyy-MM-dd\"，groups = &#123;AddGroup.class&#125;) private Date createTime; private String alias; @Max(10) @Min(1) private Integer level; private Integer vip;&#125; 4.2、@Valid注解进行入参校验12345@PostMapping(\"/saveAccount\")public ResultResponse saveAccount(@Valid Account account)&#123; accountService.saveAccount(account); return ResultResponse.success();&#125; 注：接口入参 需要添加 @Valid 注解，才会对入参进行参数校验。 4.3、封装工具类ValidatorUtils进行入参校验4.31、工具类123456789101112131415161718192021public class ValidatorUtils &#123; private static Validator validator; static &#123; validator = Validation.buildDefaultValidatorFactory().getValidator(); &#125; /** * @param object 待校验对象 * @param groups 待校验的组 * @throws RRException 校验不通过，则报RRException异常 */ public static void validateEntity(Object object, Class&lt;?&gt;... groups) throws RRException &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = validator.validate(object, groups); if (!constraintViolations.isEmpty()) &#123; ConstraintViolation&lt;Object&gt; constraint = (ConstraintViolation&lt;Object&gt;) constraintViolations.iterator().next(); throw new RRException(constraint.getMessage()); &#125; &#125;&#125; 4.32、分组校验的实现如果Account 对象 在不同的业务中校验规则不同的话，我们可以使用分组校验，对不同的校验规则进行隔离校验，互相不受影响。 12public interface AddGroup &#123;&#125; 12public interface UpdateGroup &#123;&#125; 123@GroupSequence(&#123;AddGroup.class, UpdateGroup.class&#125;)public interface Group &#123;&#125; 4.32、工具类的使用12345678@PostMapping(\"/saveAccount\")public ResultResponse saveAccount(Account account)&#123; // 参数校验 ValidatorUtils.validateEntity(account, SaveGroup.class); accountService.saveAccount(account); return ResultResponse.success();&#125; 4.4、级联校验通过在属性上添加@Valid注解就可以进行级联校验了。如下： 1234567class Car &#123; @NotNull private String manufacturer; @Valid private Driver driver; // getter setter&#125; 4.5、自定义constraint123456789101112131415161718192021```## 五、拓展（其他参数校验方法）## 5.1、封装工具类```javapublic abstract class Assert &#123; public static void isBlank(String str, String message) &#123; if (StringUtils.isBlank(str)) &#123; throw new RRException(message); &#125; &#125; public static void isNull(Object object, String message) &#123; if (object == null) &#123; throw new RRException(message); &#125; &#125;&#125; 5.2、工具类校验1234567@RequestMapping(value = \"/password/change\", method = RequestMethod.POST)public ResultResponse changePassword(String password, String newPassword) &#123; Assert.isBlank(newPassword, \"新密码不为能空\"); userService.changePassword(getUserId(), newPassword); return ResultResponse.success();高效使用hibernate-validator校验框架&#125; 六、Bean Validation 中内置的 constraint12345678910111213141516171819@Null 被注释的元素必须为 null@NotNull 被注释的元素必须不为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max=, min=) 被注释的元素的大小必须在指定的范围内@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式Hibernate Validator 附加的 constraint@NotBlank(message =) 验证字符串非null，且长度必须大于0@Email 被注释的元素必须是电子邮箱地址@Length(min=,max=) 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串的必须非空@Range(min=,max=,message=) 被注释的元素必须在合适的范围内 @NotNull 和 @NotEmpty 和 @NotBlank 区别 @NotBlank 只用于String，不能为null且trim()之后size&gt;0 @NotNull 不能为null，但可以为empty，没有Size的约束，用在基本类型上 @NotEmpty 不能为null，且Size&gt;0， 用在String类或集合类上面 八、参考资料 [x] 官方文档 [x] 高效使用hibernate-validator校验框架 [x] hibernate-validator 九、结语 文章仅作为个人学习总结之用，水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/Spring Boot入门","date":"2019-03-12T06:57:56.520Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/Spring Boot入门/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/Spring Boot入门/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/SpringCloud","date":"2019-03-12T06:57:56.520Z","updated":"2018-12-18T06:09:45.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/SpringCloud/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/微服务/SpringCloud/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro+Token实现APP、Web统一登录认证和权限管理","date":"2019-03-12T06:57:56.516Z","updated":"2018-12-31T07:08:29.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro+Token实现APP、Web统一登录认证和权限管理/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro+Token实现APP、Web统一登录认证和权限管理/","excerpt":"","text":"[TOC] 一、前言公司原来项目的技术架构是JSP + SpringMVC + Shiro，使用SpringMVC做页面跳转路由，Shiro做用户认证和用户鉴权。现在要改造成前后端分离架构，同样使用Shiro来做权限管理，则会遇到如下不同情况。 基于session的认证（JSP+ SpringMVC + Shiro）： Web前端把username和password，提交到服务端的登录api，服务端验证正确后，生成一个token，并把token和userId，存在缓存里（推荐redis数据库）；前端将session加密后存在cookie中，每次请求浏览器自动把cookie放入header中，从而实现会话验证。 基于session的认证（Html + SpringMVC + Shiro）： 前后端分离后，Web端的Shiro认证也是基于上面的思路，然而还会有自己特殊的问题，那就是需要解决跨域产生的ajax是无法携带cookie信息的问题。 基于token的鉴权机制： APP前端把username和password，提交到服务端的登录api，服务端验证正确后，生成一个token，并把token和userId，存在缓存里（推荐redis数据库）；然后把token返回给前端。让APP保存在本地，每次请求把该token放入header中，从而实现会话验证。又由于APP把token保存在本地，存在安全问题，因此需要对token进行加密。 关键字：SpringMVC + shiro + JWT 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.06.10 1.0 ZZ 初稿 1 2018.07.31 1.1 ZZ 补充完善 三、概念解析3.1、占位不适用前后断分离的方法 将sessionId和数据库的userId进行绑定认证 1JSESSIONID=476dae2a-4cf7-49f9-a684-3a4736d2b1b6 之前是后台项目内部拦截请求，控制页面跳转，现在前端分离后就不能在后端控制了。我们只能通过接口的方式给前端提供登录相关数据，前端根据我们返回的状态码等信息自己去控制页面跳转！ 四、正文五、正文六、相关术语网站应用一般使用Session进行登录用户信息的存储及验证，而在移动端使用Token则更加普遍。它们之间并没有太大区别，Token比较像是一个更加精简的自定义的Session。 6.1、JWTJWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 6.2、JJWTJJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。 七、拓展阅读八、参考资料 shiro实现APP、web统一登录认证和权限管理 前后端分离架构下的登录系统设计 国服最强JWT生成Token做登录校验讲解，看完保证你学会！ java对cookie的操作 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro安全框架","date":"2019-03-12T06:57:56.512Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro安全框架/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/Shiro安全框架/","excerpt":"","text":"[TOC] 一、前言Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能： 基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。 权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、概念解析 Subject：主体，抽象概念，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等。 SecurityManager：安全管理器。shiro的核心，它负责安全认证与授权。 所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject。 Authentication：认证，也就是验证用户的身份，就是确定你是不是你，比如通过用户名、密码的方式验证，或者某些第三方认证，比如微信认证。 Authorization：授权，也叫访问控制，也就是看你是否有权限做什么事情，比如是否有权限看某个文件，或者是否有权限做后台管理。 Realm：shiro和应用程序的权限数据之间的桥梁，为shiro提供安全数据。 SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。 Token:令牌， Principal：身份，就是一种用于标识用户身份的一种属性，比如邮箱、电话号码、用户名、微信号等。 Persmission：权限，用于描述系统的某项基础功能，比如 “打开一个文件”，“查看’/user/list/’页面”，“打印文档”，这些都算是一种权限。 Role：角色，在Shiro中，角色就是权限的组合。 Session：会话，也就是用户登录之后的上下文，在用户登出之前可以不用传递用户名、密码就可以做各种操作。 Credential：证书，比如密码、指纹或者网银的Key都算是证书的一种。系统通过将用户提供的证书和系统存储的证书比较，如果一致就认为用户的身份是对的。 Cipher：加密方式，这里主要有几种常用的加密方式，比如分组密码（Block Ciphers）、流密码（Stream Ciphers）、对称加密（Symmetric Ciphers）、非对称加密（Asymmetric Ciphers）。 Hash：哈希，一种单相的数据加密算法。 三、项目实例四、Spring整合项目实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\" default-lazy-init=\"true\"&gt; &lt;description&gt;Shiro安全配置&lt;/description&gt; &lt;!-- Shiro Filter 拦截器相关配置 --&gt; &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;!-- 安全管理器 --&gt; &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt; &lt;!-- 默认的登陆访问url --&gt; &lt;property name=\"loginUrl\" value=\"/manage/toLogin\" /&gt; &lt;!-- 登录成功后要跳转的连接 --&gt; &lt;property name=\"successUrl\" value=\"/manage/index\" /&gt; &lt;!-- 没有权限跳转的url --&gt; &lt;property name=\"unauthorizedUrl\" value=\"/403\" /&gt; &lt;!-- 自定义filter配置 --&gt; &lt;property name=\"filters\"&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中 --&gt; &lt;entry key=\"authc\" value-ref=\"formAuthenticationFilter\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 过滤器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;!-- filterChainDefinitions参数说明,注意其验证顺序是自上而下 ================================================================================================= anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter ================================================================================================= anon: 例子/admins/**=anon 没有参数，表示可以匿名使用。 authc: 例如/admins/user/**=authc表示需要认证(登录)才能使用，没有参数 roles: 例子/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号， 并且参数之间用逗号分割，当有多个参数时，例如admins/user/**=roles[\"admin,guest\"], 每个参数通过才算通过，相当于hasAllRoles()方法。 perms: 例子/admins/user/**=perms[user:add:*],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割， 例如/admins/user/**=perms[\"user:add:*,user:modify:*\"]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 rest: 例子/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user:method]， 其中method为post，get，delete等。 port: 例子/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString, 其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。 authcBasic: 例如/admins/user/**=authcBasic没有参数表示httpBasic认证 ssl: 例子/admins/user/**=ssl没有参数，表示安全的url请求，协议为https user: 例如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查 注: anon，authcBasic，auchc，user是认证过滤器，perms，roles，ssl，rest，port是授权过滤器 ================================================================================================= --&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /static/**=anon &lt;!-- 验证码，可匿名访问 --&gt; /validatecode.jsp = anon /manage/toLogin=anon &lt;!-- 请求 logout地址，shiro去清除session --&gt; /logout = logout &lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt; &lt;!-- /items/queryItems.action = perms[item:query] /items/editItems.action = perms[item:edit] --&gt; &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; &lt;!-- /index.jsp = user /welcome.jsp = user --&gt; &lt;!-- /** = authc 所有url都必须认证通过才可以访问 --&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--安全管理器 --&gt; &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;!--设置自定义Realm --&gt; &lt;property name=\"realm\" ref=\"customRealm\" /&gt; &lt;!--将缓存管理器，交给安全管理器 --&gt; &lt;!-- &lt;property name=\"cacheManager\" ref=\"shiroEhcacheManager\" /&gt; --&gt; &lt;!-- 注入session管理器 --&gt; &lt;property name=\"sessionManager\" ref=\"sessionManager\" /&gt; &lt;!-- 记住我，计入cookie --&gt; &lt;property name=\"rememberMeManager\" ref=\"rememberMeManager\" /&gt; &lt;/bean&gt; &lt;!-- 自定义的Realm --&gt; &lt;bean id=\"customRealm\" class=\"com.lapland.core.shiro.CustomRealm\"&gt; &lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt; &lt;property name=\"credentialsMatcher\" ref=\"credentialsMatcher\" /&gt; &lt;/bean&gt; &lt;!-- 凭证匹配器 --&gt; &lt;bean id=\"credentialsMatcher\" class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"&gt; &lt;property name=\"hashAlgorithmName\" value=\"md5\" /&gt; &lt;property name=\"hashIterations\" value=\"1\" /&gt; &lt;/bean&gt; &lt;!-- 缓存管理器 --&gt; &lt;bean id=\"shiroEhcacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt; &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:shiro/ehcache-shiro.xml\" /&gt; &lt;/bean&gt; &lt;!-- 会话管理器 --&gt; &lt;bean id=\"sessionManager\" class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\"&gt; &lt;!-- session的失效时长，单位毫秒 --&gt; &lt;property name=\"globalSessionTimeout\" value=\"600000\" /&gt; &lt;!-- 删除失效的session --&gt; &lt;property name=\"deleteInvalidSessions\" value=\"true\" /&gt; &lt;/bean&gt; &lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt; &lt;bean id=\"rememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\"&gt; &lt;property name=\"cookie\" ref=\"rememberMeCookie\" /&gt; &lt;/bean&gt; &lt;!-- 记住我cookie --&gt; &lt;bean id=\"rememberMeCookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\"&gt; &lt;!-- rememberMe是cookie的名字 --&gt; &lt;constructor-arg value=\"rememberMe\" /&gt; &lt;!-- 记住我cookie生效时间30天 --&gt; &lt;property name=\"maxAge\" value=\"2592000\" /&gt; &lt;/bean&gt; &lt;!-- 自定义form认证过滤器 --&gt; &lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过滤器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt; &lt;bean id=\"formAuthenticationFilter\" class=\"com.lapland.core.shiro.CustomFormAuthenticationFilter\"&gt; &lt;!-- 表单中账号的input名称 --&gt; &lt;property name=\"usernameParam\" value=\"username\" /&gt; &lt;!-- 表单中密码的input名称 --&gt; &lt;property name=\"passwordParam\" value=\"password\" /&gt; &lt;!-- 记住我input的名称 --&gt; &lt;property name=\"rememberMeParam\" value=\"rememberMe\" /&gt; &lt;/bean&gt; &lt;!-- 在方法中 注入 securityManager，进行代理控制 --&gt; &lt;bean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"&gt; &lt;property name=\"staticMethod\" value=\"org.apache.shiro.SecurityUtils.setSecurityManager\" /&gt; &lt;property name=\"arguments\" ref=\"securityManager\" /&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" /&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\" /&gt; &lt;!-- 启用shiro授权注解拦截方式 --&gt; &lt;bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 五、拓展阅读六、参考资料 细说shiro 七、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/浅谈权限管理","date":"2019-03-12T06:57:56.512Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/浅谈权限管理/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/浅谈权限管理/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 三、RBAC(Role-Based Access Control，基于角色的权限管理)。RBAC(Resource-Based Access Control，基于资源的权限管理)。 是的，一个人是可以有多个角色。对于功能权限（比如查询权限，修改权限等这些），用角色就够了。 但是对于数据权限，比如同一张表的 A数据，B数据，用户X有查，删的权限；A数据，C数据，用户Y有查的权限；B数据, C数据，用户Z有删除，修改的权限等等 这样的话用角色来区分不同类的权限，就会导致角色非常多。管理角色本身就很费劲 粗粒度和细粒度权限粗粒度权限管理，对资源类型的权限管理。资源类型比如：菜单、url连接、用户添加页面、用户信息、类方法、页面中按钮。粗粒度权限管理比如：超级管理员可以访问户添加页面、用户信息等全部页面。部门管理员可以访问用户信息页面包括 页面中所有按钮。 细粒度权限管理，对资源实例的权限管理。资源实例就资源类型的具体化，比如：用户id为001的修改连接，1110班的用户信息、行政部的员工。细粒度权限管理就是数据级别的权限管理。细粒度权限管理比如：部门经理只可以访问本部门的员工信息，用户只可以看到自己的菜单，大区经理只能查看本辖区的销售订单。。 粗粒度和细粒度例子：系统有一个用户列表查询页面，对用户列表查询分权限，如果粗颗粒管理，张三和李四都有用户列表查询的权限，张三和李四都可以访问用户列表查询。 进一步进行细颗粒管理，张三（行政部）和李四(开发部)只可以查询自己本部门的用户信息。张三只能查看行政部 的用户信息，李四只能查看开发部门的用户信息。细粒度权限管理就是数据级别的权限管理。 如何实现粗粒度和细粒度权限管理如何实现粗粒度权限管理？粗粒度权限管理比较容易将权限管理的代码抽取出来在系统架构级别统一处理。比如：通过springmvc的拦截器实现授权。如何实现细粒度权限管理？对细粒度权限管理在数据级别是没有共性可言，针对细粒度权限管理就是系统业务逻辑的一部分，如果在业务层去处理相对比较简单，如果将细粒度权限管理统一在系统架构级别去抽取，比较困难，即使抽取的功能可能也存在扩展不强。建议细粒度权限管理在业务层去控制。比如：部门经理只查询本部门员工信息，在service接口提供一个部门id的参数，controller中根据当前用户的信息得到该 用户属于哪个部门，调用service时将部门id传入service，实现该用户只查询本部门的员工。 基于url拦截的方式实现基于url拦截的方式实现在实际开发中比较常用的一种方式。对于web系统，通过filter过虑器实现url拦截，也可以springmvc的拦截器实现基于url的拦截。 使用权限管理框架实现对于粗粒度权限管理，建议使用优秀权限管理框架来实现，节省开发成功，提高开发效率。shiro就是一个优秀权限管理框架。 基于角色的权限管理基于资源的权限管理拓展阅读参考资料结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/单点登录CAS","date":"2019-03-12T06:57:56.512Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/单点登录CAS/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/单点登录CAS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/前后端分离模式下的权限设计方案","date":"2019-03-12T06:57:56.508Z","updated":"2018-12-25T12:54:52.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/前后端分离模式下的权限设计方案/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/权限控制/前后端分离模式下的权限设计方案/","excerpt":"","text":"Andrisod和IOS天生就是前后端分离的，一些Web项目为了更好的用户体验或优化设计流程，也选择掐后端分离模式。 前后端的交互实质上抽象为数据操作的交互。参考Postman交互过程 权限控制是控制登录用户对于系统资源的访问。 前后端分离模式下，所有的交互场景都变成了数据，传统业务系统中的权限控制方案在前端已经不再适用 前后端各自在系统中的职责。 服务端：提供数据接口。前端：路由控制、页面渲染。 mock数据与前后端接口联调 使用MOCK.js实现前后端分离，实现数据交互功能","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/使用Swagger或Postman接口文档管理","date":"2019-03-12T06:57:56.500Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/使用Swagger或Postman接口文档管理/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/使用Swagger或Postman接口文档管理/","excerpt":"","text":"[TOC] 一、前言基于公司前后端分离项目的展开，后端开发为了方便的生成、提供和管理接口文档，与前端各团队（IOS开发、Android开发、Web开发等）有效协同。减少与其他团队沟通成本。故制定此接口文档管理方案，方便团队学习和使用。 本文通过搭建一个Maven+SpringMVC+Swagger+Swagger-UI的示例，介绍了Swagger插件的整合步骤和使用方法。前端团队则使用Swagger-UI查看，使用Postman测试接口文档。 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新 。接口的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。 Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。 测试环境：JDK 1.8 + Maven 3.5.1 + Tomcat 7 + IDEA 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.06.22 1.0 ZZ 初稿 三、SSM整合Swagger步骤3.1、搭建Maven管理的SSM项目 pom.xml文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xxx.tutorial&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-demo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springfox-swagger-demo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.framework.version&gt;4.3.6.RELEASE&lt;/spring.framework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入Spring依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springfox-swagger-demo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 3.2、整合Swagger3.21、添加Swagger2依赖1234567891011121314151617181920212223&lt;!-- Swagger2的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt;&lt;/dependency&gt; 3.22、创建Swagger2配置类12345678910111213141516171819202122232425262728293031323334package com.common;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2@ComponentScan(basePackages = &#123;\"com.*.controller\"&#125;)@EnableWebMvcpublic class SwaggerConfig extends WebMvcConfigurationSupport &#123; @Bean public Docket customDocket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"演示项目\") .description(\"前后端对接API文档\") .version(\"1.0\") .build(); &#125;&#125; 3.23、注入Swagger2配置类Bean ApplicationContext-mybatis.xml 1&lt;bean class=\"com.common.SwaggerConfig\" id=\"SwaggerConfig\"/&gt; 3.3 整合Swagger-ui3.31 添加Swagger-ui依赖12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 查看JAR包不难发现，swagger-ui中使用的静态资源文件（如 swagger-ui.html ）已被打包在spingfox-swagger-ui-2.7.0.jar中的/META-INF/resources/下 3.32 配置对这些静态资源的访问 spring-mvc.xml 123&lt;mvc:resources mapping=\"swagger-ui.html\" location=\"classpath:/META-INF/resources/\" /&gt;&lt;mvc:resources mapping=\"/webjars/**\" location=\"classpath:/META-INF/resources/webjars/\" /&gt; 3.4 测试经过上述几个步骤，就已经可以实现接口文档化了。Swagger通过扫描com.*.controller生成接口文档。通过如下的地址访问： 1http://localhost:8080/项目名/swagger-ui.html 然而API文档还比较粗糙，还需要添加方法描述、参数等信息。 四、Swagge注解说明4.1、API常用注解 作用范围 API 使用位置 对象属性 @ApiModelProperty 用在出入参数对象的字段上 协议集描述 @Api 用于controller类上 协议描述 @ApiOperation 用在controller的方法上 Response集 @ApiResponses 用在controller的方法上 Response @ApiResponse 用在 @ApiResponses里边 非对象参数集 @ApiImplicitParams 用在controller的方法上 非对象参数描述 @ApiImplicitParam 用在@ApiImplicitParams的方法里边 描述返回对象的意义 @ApiModel 用在返回对象类上 4.11、@ApiImplicitParam 属性 取值 作用 paramType 查询参数类型 path 以地址的形式提交数据 query 直接跟参数完成自动映射赋值 body 以json的形式提交 仅支持POST header 参数在request headers 里边提交 form 以form表单的形式提交 仅支持POST dataType 参数的数据类型 只作为标志说明，并没有实际验证 Long String name 接收参数名 value 接收参数的意义描述 required 参数是否必填 true 必填 false 非必填 defaultValue 默认值 待补充实例… 五、接口文档的编写实例5.1 controller接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.restaApi.controller;import com.common.ListResponse;import com.common.SingleResponse;import com.restApi.model.User;import com.restApi.service.UserService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.*;@Api(description = \"用户信息查询\")@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired UserService userService; @ApiOperation(value = \"获取用户列表\", notes = \"\") @RequestMapping(value = \"\", method = RequestMethod.GET) public ListResponse&lt;User&gt; getAllUsersList() &#123; ListResponse&lt;User&gt; users = userService.selectUserAll(); return users; &#125; @ApiOperation(value=\"根据ID查询用户\", notes=\"根据url的id来获取用户详细信息\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public SingleResponse getUserById(@PathVariable(\"id\") long id) &#123; SingleResponse user = userService.selectUserById(id); return user; &#125; @ApiOperation(value = \"创建用户\", notes = \"根据User对象创建用户\") @RequestMapping(value = \"\", method = RequestMethod.POST) public void createUser(@RequestBody User user) &#123; userService.saveUser(user); &#125; @ApiOperation(value=\"根据ID更新用户\", notes=\"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息\") @ApiImplicitParams(&#123; @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\"), @ApiImplicitParam(name = \"user\", value = \"用户详细实体user\", required = true, dataType = \"User\") &#125;) @RequestMapping(value = \"\", method = RequestMethod.PUT) public void updateUserById(@RequestBody User user) &#123; SingleResponse result = userService.selectUserById(user.getId()); User SingleUser = (User) result.getData(); if (SingleUser != null) &#123; SingleUser.setName(user.getName()); SingleUser.setAge(user.getAge()); SingleUser.setSalary(user.getSalary()); userService.updateUserById(SingleUser); &#125; &#125; @ApiOperation(value=\"删除用户\", notes=\"根据url的id来指定删除对象\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.DELETE) public void deleteUserById(@PathVariable(\"id\") int id) &#123; userService.deleteUserById(id); &#125; @ApiOperation(value=\"删除所有用户\", notes=\"删除所有用户\") @RequestMapping(value = \"\", method = RequestMethod.DELETE) public void deleteAllUsers() &#123; userService.deleteUserAll(); &#125;&#125; 5.2 实体类12345678910111213141516171819202122232425262728package com.restApi.model;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;/** * @ApiModel 和 @ApiModelProperty 用于在通过对象接收参数时在API文档中显示字段的说明 * @DateTimeFormat 和 @JsonFormat 用于在接收和返回日期格式时将其格式化 * @author zz * @date 下午5:34 18-6-22 */@Data@ApiModel(value =\"User\")public class User &#123; @ApiModelProperty(value = \"用户Id\") private long id; @ApiModelProperty(value = \"姓名\", required = true) private String name; @ApiModelProperty(value = \"年龄\", required = true) private int age; @ApiModelProperty(value = \"工资\", required = true) private double salary; 六、完成效果 七、Swagger-UI 接口测试略 八、Postman 接口测试 Postman下载 Postman使用详解 [x] postman的使用方法详解 [x] Postman API 中文白皮书文档 九、参考资料 [x] Swagger官网 [x] 一步步完成Maven+SpringMVC+SpringFox+Swagger整合示例 [x] SpringMVC集成Swagger插件以及Swagger注解的简单使用 [x] swagger注释API详细说明和示例 swagger注释API详细说明 [x] swagger常用注解说明 [x] 豆瓣API接口文档 十、结语 本文为API接口设计指南的拓展文章。经测试评定，对外接口文档使用Swagger插件，web页面打开，所有接口一目了然，有简单测试功能，但不能保存测试数据。对内接口对接使用Postman，可保存交换测试数据。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/HttpClint接口调用","date":"2019-03-12T06:57:56.492Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/HttpClint接口调用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/HttpClint接口调用/","excerpt":"","text":"[TOC] 一、前言HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.05 1.0 ZZ 初稿 三、实例 Call_External_Data.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** * @author root * @date 14:10 2018/1/22 * @description HttpCline 接口请求工具类-2 */public class Call_External_Data &#123; /** logger日志 */ private final static Logger LOGGER = LoggerFactory.getLogger(Call_External_Data.class); /** * @param httpUrl 接口地址 * @return java.lang.String 返回json字符串 * @description GET请求 */ public static String doGet(String httpUrl) &#123; HttpGet httpGet = new HttpGet(httpUrl); return getJSONString(httpGet); &#125; /** * @param httpUrl 接口地址 * @param json json格式的入参 * @return com.alibaba.fastjson.JSONObject * @description POST请求 */ public static String doPost(String httpUrl, String json) &#123; HttpPost httpPost = new HttpPost(httpUrl); try &#123; StringEntity stringEntity = new StringEntity(json); stringEntity.setContentEncoding(\"UTF-8\"); stringEntity.setContentType(\"application/json\"); // 给http请求设置请求体 httpPost.setEntity(stringEntity); &#125; catch (UnsupportedEncodingException e) &#123; LOGGER.error(\"入参格式解析失败，\" + \"错误类型：\" + e.getMessage() + e); &#125; return getJSONString(httpPost); &#125; /** * @param HttpRequest 抽象父类做形参 * @return java.lang.String * @description 解析http请求，返回Json字符串 */ private static String getJSONString(HttpRequestBase HttpRequest) &#123; CloseableHttpClient httpClient = null; CloseableHttpResponse response = null; String responseContent = null; // 0、请求参数 RequestConfig requestConfig = RequestConfig.custom() // 设置连接超时时间 .setConnectTimeout(5000) // 设置请求超时时间 .setConnectionRequestTimeout(5000) // 设置Socket超时时间 .setSocketTimeout(5000) // 默认允许自动重定向 .setRedirectsEnabled(true) .build(); try &#123; // 1、创建httpClient httpClient = HttpClients.createDefault(); // 2、给http请求设置请求参数 HttpRequest.setConfig(requestConfig); // 3.1、解析http请求，返回HttpResponse response = httpClient.execute(HttpRequest); // 3.2、通过HttpResponse，获取HttpEntity if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; HttpEntity entity = response.getEntity(); // 3.3、转换成Json字符串格式 responseContent = EntityUtils.toString(entity, \"UTF-8\"); &#125; else &#123; LOGGER.error(\"外部接口调用失败，\" + \"返回码：\" + response.getStatusLine().getStatusCode()); &#125; &#125; catch (Exception e) &#123; LOGGER.error(\"外部接口调用失败，\" + \"错误类型：\" + e.getMessage() + e); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; if (httpClient != null) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; LOGGER.error(\"输入输出流关闭错误，错误类型：\" + e.getMessage() + e); &#125; &#125; return responseContent; &#125; @Test public void testGetDemo() &#123; String responseContent1 = doGet(\"http://localhost:8888/outdata/scenicAreaRealTimeFootfall.json\"); System.out.println(responseContent1); String responseContent2 = doGet(\"http://localhost:8888/outdata/currentPassengerFlow.json\"); System.out.println(responseContent2); &#125; @Test public void testPostDemo() &#123; Calendar calendar = Calendar.getInstance(); // 初始化为当年的一月份 calendar.set(Calendar.MONTH, 0); calendar.add(Calendar.YEAR, -1); String jsonRequestBody = \"&#123;\\n\" + \" \\\"reqcode\\\": \\\"1007\\\",\\n\" + \" \\\"tr_date\\\": \\\"201707\\\",\\n\" + \" \\\"number\\\": \\\"07\\\",\\n\" + \" \\\"acc_kind\\\": \\\"06\\\",\\n\" + \" \\\"oper_id\\\": \\\"admin\\\",\\n\" + \" \\\"org_id\\\": \\\"1001\\\",\\n\" + \" \\\"operator_id\\\": \\\"admin\\\",\\n\" + \" \\\"branch_id\\\": \\\"10010001\\\",\\n\" + \" \\\"key\\\": \\\"0000\\\",\\n\" + \" \\\"sign\\\": \\\"0000\\\"\\n\" + \"&#125;\"; JSONObject jsonObject = JSON.parseObject(jsonRequestBody); for (int index = 1; index &lt;= 12; index++) &#123; if (1 != index) &#123; calendar.add(Calendar.MONTH, 1); &#125; Date date = calendar.getTime(); SimpleDateFormat simpleDateFormatMonth = new SimpleDateFormat(\"yyyyMM\"); String month = simpleDateFormatMonth.format(date); System.out.println(month); // 修改 tr_date的属性为 lastMonth jsonObject.put(\"tr_date\", month); jsonRequestBody = jsonObject.toJSONString(); String responseContent = doPost(\"http://123.153.1.135/json/JSONServlet\", jsonRequestBody); &#125; &#125;&#125; CallExternalData.java 参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author root * @date 20:32 2018/1/22 * @description 接口请求工具类-2 */public class CallExternalData &#123; private final static Logger LOGGER = LoggerFactory.getLogger(CallExternalData.class); private static String getJSONString(String path) &#123; StringBuffer document = null; BufferedReader reader = null; String line = null; try &#123; URL url = new URL(path); document = new StringBuffer(); URLConnection conn = url.openConnection(); reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\")); while ((line = reader.readLine()) != null) &#123; document.append(line); &#125; &#125; catch (Exception e) &#123; LOGGER.error(\"外部接口请求失败，\" + \"错误类型：\" + e); &#125; finally &#123; try &#123; reader.close(); &#125; catch (Exception e) &#123; LOGGER.error(\"外部接口请求IO流关闭失败，错误类型：\" + e); &#125; &#125; if (null != document) &#123; String json = String.valueOf(document); return json; &#125; return null; &#125; /** * @return java.util.List&lt;com.anji.pojo.Scenicarearealtimefootfall&gt; * @description 智慧旅游-各景区实时客流量 */ public static List&lt;Scenicarearealtimefootfall&gt; scenicAreaData() &#123; //String jsonStr = getJSONString(\"http://localhost:8888/outdata/scenicAreaRealTimeFootfall.json\"); String jsonStr = getJSONString(\"http://172.26.16.30:8180/interfaces/scenicAreaRealTimeFootfall\"); JSONObject jsonObject = JSON.parseObject(jsonStr); String arrStr = String.valueOf(jsonObject.getJSONArray(\"area_ten\")); List&lt;Scenicarearealtimefootfall&gt; list = JSON.parseArray(arrStr, Scenicarearealtimefootfall.class); return list; &#125;&#125; 四、参考资料 HttpClient学习整理 五、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]API接口设计指南","date":"2019-03-12T06:57:56.484Z","updated":"2019-01-01T14:42:03.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]API接口设计指南/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]API接口设计指南/","excerpt":"","text":"[TOC] 一、前言公司目前的产品的软件架构是JSP+SSM+Tomcat，前后端代码高度耦合。前端设计好HTML静态页面，后端转换成JSP，JSP文件中大量嵌入EL及JSTL表达式，甚至会涉及到CSS及JS文件的修改。不仅后端会做出很多不必要的工作，也让前端工程师需要更新修改时，望码兴叹，无从下手。 前段时间，公司曾尝试运用AJAX+JSON形式的HTTP API 接口进行前后端交互，抛弃了JSP模式，从而初步实现了前后端的解耦。然而，由于没有规范性文件的指导，接口设计及接口文档的设计难免有一定的随意性。存在潜在隐患。 为了解决公司接口设计及接口文档编写的规范性问题，节约前后端及模块间接口调用的协调成本，以及为后续的可能进行的前后端分离工作做准备。估拟定此API接口设计指南，作为公司接口设计及接口文档编写的指导性文件。 本文会按照HTTP API和RESTful API两个分支编写，以适应公司产品技术架构演变的阶段性需求。正常情况下按照项目的实际情况选择其一分支即可。数据交换格式采用JSON。文章内容包括命名约定、数据交换格式约定、安全机制、以及实例讲解等方面。 参考代码请移步前后端分离架构模式的实践（附完整Demo - ApiDemo_Yshow）。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.12.18 1.0 ZZ 初稿 2 2017.12.31 1.1 ZZ 修改完善 3 2018.05.01 1.2 ZZ 补充Demo代码 4 2018.07.03 1.3 ZZ 补充安全机制和接口测试、接口文档 4 2018.12.31 1.4 ZZ 修改返回码设计部分 三、API接口设计的约定3.1、URI设计及命名的约定URI的设计应该遵循可寻址性原则，具有自描述性。在 HTTP API中URI代表一种动作，在RESTful架构风格中URI代表一种资源。 3.11、HTTP API123456/getAllStudents： 查询所有学生/getStudentById： 根据ID查询某个学生/createNewStudent： 新增一个学生/deleteAllStudents： 删除所有学生/deleteStudentById： 根据ID删除某个学生/updateStudentById： 根据ID修改某个学生的信息 3.111、使用_或-连词符来让URI可读性更好，也对SEO更友好如下例所示，URL不须遵循驼峰命名法，爬虫并不认为digitalCameraBattery是一个可以理解的单词，所以用digital-camera-battery更直观，对SEO更友好。并且建议URL全部小写。 12反例：locahost:8080//www.xxx.com/digitalCameraBattery正例：locahost:8080//www.xxx.com/digital-camera-battery 建议：下划线表示单词的连续关系，中划线表示上下级关系。 3.112、使用/来表示资源的层级关系目录层次不要太深，建议不超过三层，并按降级排序。 1正例：locahost:8080//www.xxx.com/classes/id/students/id 3.113、使用?用来过滤资源 下面是一些常见的参数： 12345?limit=10 指定返回记录的数量?offset=10 指定返回记录的开始位置。?page_number=2&amp;page_size=100 指定第几页，以及每页的记录数。?sortby=name&amp;order=asc 指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1 指定筛选条件 建议URL的参数不超过3个。参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/id/animals 与 GET /animals?zoo_id=id 的含义是相同的。 3.114、使用,或;可以用来表示同级资源的关系如下例所示比较某个文件在随意两次提交记录之间的差异。 1/git/git /block-sha1/compare/e3af72cd;bd63e6f4 3.12、RESTful API 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 1234567GET /classes/： 查询所有班级POST /classes/： 新增一个班级GET /classes/id： 根据ID查询某个班级PUT /classes/id： 根据ID修改某个班级的信息（提交全部信息）DELETE /classes/id： 根据ID删除某个班级GET /classes/id/students/： 根据ID查询某个指定班级的所有学生DELETE /classes/id/students/id： 根据ID查询某个指定班级的某个指定学生 3.2、数据交换格式约定3.21、入参3.211、HTTP API GET请求 URL参数 POST请求 表单提交 JSON提交 XML提交 3.212、RESTful API GET请求 URL参数 POST请求 表单提交 JSON提交 XML提交 PUT请求 表单提交 JSON提交 XML提交 DELETE请求 URL参数 [x] 参考：Postman使用详解 - 请求部分 [x] 参考：postman的使用方法详解 - 请求部分 3.22、出参3.221、HTTP API JSON返回格式遵循如下约定： 1234567&#123; \"code\": // 返回码 \"message\": // 接口返回描述 \"time\": // 时间戳 \"data\":&#123; // 服务端实际返回的数据 &#125;&#125; 请求接口成功的例子 123456789101112131415161718192021&#123; \"code\": \"200\", \"msg\": \"操作成功，数据正常返回\", \"time\": 1513308254828, \"data\": [ &#123; \"id\": 2, \"name\": \"江南\", \"sex\": \"男\", \"age\": 21, \"classes\": \"173521班\" &#125;, &#123; \"id\": 5, \"name\": \"竹海\", \"sex\": \"女\", \"age\": 21, \"classes\": \"173521班\" &#125; ]&#125; 12345&#123; \"code\": \"204\", \"msg\": \"操作成功，无数据返回\", \"time\": 1513308254828&#125; 请求接口失败的例子 12345&#123; \"code\": \"404\", \"msg\": \"未找到请求接口或页面\" \"time\": 1513308254828&#125; 12345&#123; \"code\": \"10999\", \"msg\": \"未知异常，请联系管理员\" \"time\": 1513308254828&#125;1 3.222、RESTful API 同HTTP API 拓展阅读：关于设计API添加时间戳的目的? 3.3、Headers设置3.31、HTTP API3.32、RESTful API Accept 服务器需要返回什么样的content。如果客户端要求返回”application/xml”，而服务器端只能返回”application/json”，那么最好返回status code 406 not acceptable（RFC2616），当然，返回application/json也并不违背RFC的定义。一个合格的REST API需要根据Accept头来灵活返回合适的数据。 If-Modified-Since/If-None-Match 如果客户端提供某个条件，那么当这条件满足时，才返回数据，否则返回304 not modified。比如客户端已经缓存了某个数据，它只是想看看有没有新的数据时，会用这两个header之一，服务器如果不理不睬，依旧做足全套功课，返回200 ok，那就既不专业，也不高效了。 If-Match 在对某个资源做PUT/PATCH/DELETE操作时，服务器应该要求客户端提供If-Match头，只有客户端提供的Etag与服务器对应资源的Etag一致，才进行操作，否则返回412 precondition failed。这个头非常重要。 3.4、版本设计（暂未实行）3.41、HTTP API 建议在URI或ResponseHeaders中来做标示，返回ResponseBody中不做标记。 1https://api.example.com/v1/classes/id 3.42、RESTful API 同HTTP API 3.5、返回码设计3.51、HTTP API 需要在文档中设计一份返回码和错误含义的列表。 参考：返回码信息字典表 3.52、RESTful API 建议RESTful API一律使用HTTP的状态码作为返回码。 3.521、常见状态码 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词） 1xx：信息，请求已被接受，需要继续处理。2xx：成功，请求已成功被服务器接收、理解、并接受。3xx：重定向，需要客户端采取进一步的操作才能完成请求。4xx：客户端错误，请求包含语法错误或请求无法实现。该操作是幂等的5xx：服务器错误，服务器在处理请求的过程中有错误或者异常状态发生。 12345678910111213141516171819200：OK - [GET] 服务器成功返回用户请求的数据，该操作是幂等的。201：Created - [POST/PUT/PATCH] 用户新建或修改数据成功。202：Accepted - [*] 表示一个请求已经进入后台排队（异步任务）。204：No Content - [DELETE] 用户删除数据成功，无内容返回。206：Partial Content - [GET] 请求成功，只返回一部分内容。400：Bad Request - [POST/PUT/PATCH] 用户发出的请求有错误，该操作是幂等的。401：Unauthorized - [*] 表示用户未认证（令牌、用户名、密码错误）。403：Forbidden - [*] 表示用户无权限访问该资源，请求失败。404：Not Found - [*] 请求的资源不存在，该操作是幂等的。405：Method Not Allowed - [*] 请求方法不允许。406：Not Acceptable - [GET] 表述格式不正确。410：Gone - [GET] 用户请求的资源被永久删除，请求失败。422：Unprocesable entity - [POST/PUT/PATCH] 不可处理实体。429：Too Many Requests - [*] 因为访问频繁，你已经被限制访问，稍后重试。500：INTERNAL SERVER ERROR - [*] 服务端错误。502：Bad Gateway - [*] 网关错误504：Gateway Timeout - [*] 网关超时 3.522、返回码涉及到两个有争议的问题:1、返回码是使用HTTP状态码还是返回200，在msg中描述状态。 观点一、返回HTTP状态码 理由：通过响应头Header返回HttpCode更符合RESTful风格。 理由：HttpCode对记录日志，异常处理，状态监控更友好。 观点二、系统异常通过HttpCode返回，业务问题通过StatusCode中的msg描述返回 理由：Body返回StatusCode及msg对问题的描述更灵活，对前端友好。 理由：区分系统异常和业务问题（业务逻辑的一部分，并非异常）。 理由：Body返回StatusCode与Header返回HttpCode重复。 结论：支持观点二。 2、业务方法是通过抛出异常还是通过返回码的方式反馈信息给前端。 观点一、通过返回码：正常的业务流程不应使用异常来处理。观点二、抛出异常：对错误的检测是强制的，代码更加整洁。 结论： 支持 @小眼睛老鼠 的观点 两个问题的统一建议处理方式： 系统异常统一通过吧bllexception拦截器处理（转换成msg返回）。业务异常定义apiexception拦截器处理common异常，其他通过自定义StatusCode返回前端。 HTTP response code (RFC 7231) 关于 RESTful API 中 HTTP 状态码的定义的疑问？ API 使用 HTTP 状态码还是全部返回 200 关于bll业务返回状态码还是要抛出一个异常 关于bll业务返回状态码还是要抛出一个异常 异常(exception)和执行失败有什么区别？ 3.7、安全机制 制定API的安全机制，主要就是为了解决这两个问题： 其一，保证API的调用者是经过自己授权的； 其二，保证数据传输过程中的安全（一致性、机密性、可用性）； 此外，暴力破解、SQL注入、伪造请求和数据、重复提交等也要考虑。 3.71、HTTP API3.711、token Shiro实现APP、Web统一登录认证和权限管理 3.712、加签、验签（推荐）接口双方为了确保数据参数在传输过程中未经过篡改，都需要对接口数据进行加签，然后在接口服务器端对接口参数进行验签，确保两个签名是一样的，验签通过之后再进行业务逻辑处理。 API接口请求加签算法： 12345678910111213141516171、将AppId、Timestamp、Token(客户端保存)，按照参数名在英文字典中的顺序排序，然后重新拼成一个标准的query string。2、将上一步得到的query string，按照UTF-8格式转换成字节数组。3、以SHA1/MD5(32)算法，对query string字节数组计算出一个签名字节数组。（默认为SHA1加密，开通MD5加密请联系项目经理）4、将签名字节数组，转换为十六进制的字符串。将最后得到的字符串作为请求的sign参数，将sign字段与其他参数一同放在请求中发送给服务。例如：- 将得到的AppId和Token以及时间戳拼接成QueryString串：AppId=EZP&amp;Timestamp=20150701093010&amp;Token=9cd8c0ed38a9e113。- 做SHA1结果为（使用大写）：sign = 657D0E34AD7B342F888CA3856F207F35CF2622A8。- 做MD5结果为（使用大写）：sign = EEA423559697D74A5159678797B953B8。- 将SHA1/MD5结果作为Sign的请求一并提交。 API接口响应验签算法： 1234567891、将接收到的数据中的Timestamp、AppId、Token(客户端保存)，按照参数名在英文字典中的顺序排序，然后重新拼成一个标准的query string。2、将上一步得到的query string，按照UTF-8格式转换成字节数组。3、将sign字段的值，从十六进制字符串转换成字节数组。4、以SHA1算法，验证query string的签名（使用前面两步所生成的字节数组）。5、若验证不通过，应简单忽略该请求，不做任何处理。若验证通过，执行相应的业务处理。(说明：对于返回status=false的不应验证) 3.713、数字签名（推荐） [x] 图片理解数字签名和验签过程 [x] 签名，验签的理解 [x] Java使用数字证书加密通信（加解密/加签验签） 3.714、短信验证 妙滴科技 - 开发者中心 3.715、二维码验证 二维码的生成细节和原理 待补充 3.72、RESTful API 同 HTTP API。 四、API接口设计实例4.1、HTTP API实例 参考：码云 - API_Manager 4.2、Restful API实例 同 HTTP API。 五、API接口开发注意事项5.1、RFC一致符合HTTP/1.1（不久的将来，要符合HTTP/2.0）的RFC，保证接口的一致性。这里主要讲输入的method/headers和输出的status code。 5.2、Json接口请求中的跨域问题 参考：跨域问题的几种解决方法.md 六、接口测试与接口文档编写接口文档要清晰、明了，包含多少个接口，每个接口的地址、参数、请求方式、数据交换格式、参数是否必填、编码格式UTF8，返回值等都要写清楚。 双方约定好了接口URL、业务参数、固定参数、签名以及返回数据格式。 使用Swagger或Postman接口文档管理.md 七、接口的调用 前端一般使用ajax异步调用，后端可以使用的方法比较多，本文介绍三种： 7.1、HttpClient实现 （推荐） HttpClint接口调用实例.md 7.2、HttpURLConnection实现 略 7.3、Spring的RestTemplate 略 八、相关术语 资源 任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体，也可以只是一个抽象概念。 HTTP API 本文中HTTP API是指不符合RESTful 风格的一般接口。 返回码与状态码 返回码是指API接口返回的信息类型编码，状态码特指符合REF 7231的HTTP状态码。 九、拓展阅读 REST架构风格简介 JSON语法及JSON定义规范化 前后端分离架构模式的实践（附完整Demo） 十、参考资料 JSON HTTP API 设计指南 RESTful API 设计指南 spring-boot 使用httpclient实现http接口调用实例 我所理解的RESTful Web API [设计篇] API接口设计注意问题 URL命名原则 WebSystique 撰写安全合格的REST API 十一、结语学习就是为了应用，应用就需要应用场景，所以文章的编写以公司的实际存在的问题为场景，提出解决方案。虽然不一定会被落实，但是从问题的提出和思考解决过程中，锻炼了自己的学习能力和解决问题的能力。并且我认为，寻找答案，解决问题过程中所学习到的知识，往往比结果更重要。 其次，由于自己经验不足，思考的深度和广度也有限，文章难免会有一些纰漏之处。本文会不断完善，也欢迎各位道友提出批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]前后端分离架构模式的实践（附完整Demo）","date":"2019-03-12T06:57:56.472Z","updated":"2019-01-01T07:37:28.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]前后端分离架构模式的实践（附完整Demo）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布]前后端分离架构模式的实践（附完整Demo）/","excerpt":"","text":"[TOC] 一、前言 本文是浅谈REST架构风格和API接口设计指南的总结实践性文章。着重介绍前后端分离项目所会涉及到和所须注意的内容。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.12.22 1.0 ZZ 初稿 三、概念解析3.1、占位异常是程序在运行时出现的不正常情况。 四、架构设计五、前后分离需要注意的问题5.1、统一响应结构5.1、格式转换及对象序列化zongjie5.1、处理异常行为5.1、支持参数验证5.1、解决跨域问题 详见：JavaScript 跨域问题的几种解决方法 5.1、提供安全机制前端处理安全不是为了安全，而是为了用户体验。 六、Mock六、相关术语七、拓展阅读 浅谈REST架构风格 [x] API接口设计指南 [x] 前后端分离项目，你们是怎么控制权限的？ 前后端分离 session问题 如何保存用户的登录状态，如何进行权限检验，如何保证数据的安全性？ 前后端分离的系统 状态一般保存在客户端， 不管是session 还是jwt都是将数据保存在本地， 然后服务器通过这些token验证是否有效以及过期就行了。 数据的安全性看什么级别了， 一般相应的包括权限， 数据加密等技术 八、参考资料 REST风格框架实战：从MVC到前后端分离(附完整Demo) JavaWeb项目为什么我们要放弃jsp？为什么要前后端解耦？为什么要前后端分离？2.0版，为分布式架构打基础 跨域资源共享 CORS 详解 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布] REST架构风格简介","date":"2019-03-12T06:57:56.468Z","updated":"2018-12-31T07:21:44.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布] REST架构风格简介/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前后端分离与RESTful风格及接口设计/[未发布] REST架构风格简介/","excerpt":"","text":"[TOC] 一、前言REST全称是Representational State Transfer，中文意思是表述状态转移。 它首次出现在Roy Fielding的博士论文“架构风格与基于网络的软件架构设计”中，Roy Fielding同时是也HTTP规范的主要编写者之一。他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。” 虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 REST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful风格。相对于基于SOAP采用的RPC架构是一种面向操作的架构风格，REST则是一种*面向资源的架构风格。 实际应用中的具体表现用一句话来说就是用 URI 来标识唯一的资源，用HTTP请求方法（GET,POST,PUT,DELETE）描述操作。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.12.20 1.0 ZZ 初稿 2 2017.12.20 1.1 ZZ 增加总结 三、概念解析3.1、REST - （资源）表述状态转移要想理解表述状态转移的含义，必须先理解如下概念的含义： 3.11、资源与URI任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体，也可以只是一个抽象概念。要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI。URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源，只能算是资源的一些信息而已。 3.12、统一资源接口RESTful架构应该遵循统一接口原则。接口应该使用标准的HTTP方法如GET，PUT和POST进行资源的访问，并遵循这些方法的语义。 以HTTP/1.1协议为例，HTTP/1.1协议定义了一个操作资源的统一接口，主要包括以下内容： 7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS HTTP头信息（可自定义） HTTP响应状态代码（可自定义） 一套标准的内容协商机制 一套标准的缓存机制 一套标准的客户端身份认证机制 序号 请求方法 URI 含义 描述 1 GET /user/{id} 获取一个用户 安全且幂等 2 POST /user 新增一个用户 不安全且不幂等 3 PUT /user/{id} 修改一个用户 不安全但幂等 4 DELETE /user/{id} 删除一个用户 不安全但幂等 REST还要求，对于资源执行的操作，其操作语义必须由HTTP消息体之前的部分完全表达，不能将操作语义封装在HTTP消息体内部。这样做是为了提高交互的可见性，以便于通信链的中间组件实现缓存、安全审计等等功能。 3.13、资源的表述资源在外界的具体呈现，可以有多种表述形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。资源的表述包括数据和描述数据的元数据。 客户端与服务端通过HTTP内容协商，客户端可以通过Accept头向服务端请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。 像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用是内容协商来区分表述格式。 3.14、状态的转移在REST中，客户端与服务端的交互是无状态通信，状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。 3.15、超文本驱动超文本驱动”又名“将超媒体作为应用状态的引擎”（Hypermedia As The Engine Of Application State，来自Fielding博士论文中的一句话，缩写为HATEOAS）。将Web应用看作是一个由很多状态（应用状态）组成的有限状态机。资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。以超媒体作为引擎，驱动Web应用的状态迁移。 总结：综上所述，表述状态转移可以理解为资源的表述通过超媒体链接进行状态的转移。 四、RESTful的特性 客户-服务器（Client-Server），提供服务的服务器和使用服务的客户分离。 无状态通信（Stateless），客户端与服务端的交互是无状态的，来自客户端每一次请求中必须包含处理该请求所需的一切信息。服务器端不能存储来自某个客户端的某个请求中的信息，并在该客户端的其他请求中使用。换句话说，在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。 可缓存（Cachable），响应内容可以在通信链的某处被缓存，以改善网络效率。服务器必须让客户知道请求是否可以被缓存。（更详细解释请参考 理解本真的REST架构风格 以及 StackOverflow 的这个问题 中对缓存的解释。） 分层系统（Layered System），服务器和客户之间的通信必须被这样标准化：允许服务器和客户之间的中间层（代理，网关等）可以代替服务器对客户的请求进行回应，而且这些对客户来说不需要特别支持。 统一接口（Uniform Interface），RESTful可以通过一套统一的接口为Web，iOS和Android提供服务，具有跨平台性。 支持按需代码（Code-On-Demand，可选），服务器可以提供一些代码或者脚本（Javascrpt，flash，etc）并在客户的运行环境中执行。这条准则是这些准则中唯一不必必须满足的一条。（比如客户可以在客户端下载脚本生成密码访问服务器。） 五、相关术语5.1、幂等简单说来就是一个操作符合幂等性，那么相同的数据和参数下，执行一次或多次产生的效果（副作用）是一样的。（HTTP/1.1定义）GET、PUT、DELETE幂等 5.2、WebWeb为我们提供了一种利用HTTP协议获取和操作网络资源的方式，这些将Web服务器作为宿主的资源不仅仅包含像文字和图片这些传统的信息载体，还包含音频和视频这些多媒体信息。Web的核心主要体现在三个方面，即HTTP、超文本（Hypertext）和超媒体（Hypermedia）[1]，超文本和超媒体规范了网络信息的表现形式，而HTTP则提供了网络访问的标准协议。 5.3、超文本/超媒体（HyperText/HyperMedia）超文本是一份呈现文本内容的电子文档，其核心在于可以利用内嵌的“超链接（Hyperlink）”直接访问引用的另一份文档。超媒体对超文本作了简单的扩展以呈现多媒体内容（比如图片、音频和视频等）。HTML文档是我们常见的最为典型的超文本/超媒体文件。 5.4、媒体类型资源实际上是一种承载着某种信息的数据，相同的信息可以采用不同形态的数据来展现，数据的“形态”主要体现为展示数据所采用的格式，比如一个数据对象可以通过XML格式来表示，也可以通过JSON格式来表示。数据的处理必须依赖于一种已知的格式，所以将Web资源的形态以一种标准化的方式固定下来显得尤为重要，这就是我们接下来着重介绍的媒体类型。 不论是通过HTTP请求从Web服务器上获取资源，还是利用请求向服务器提交资源，响应或者请求的主体（Body）除了包含承载资源本身的数据之外，其报头（Header）部分还应该包含表示数据形态的媒体类型。 常用的媒体类型如下 text/html：HTML格式的文档。 text/xml（application/xml）：XML格式的文本。 text/json（application/json）： JSON格式的文本。 image/gif（image/jpeg、image/png）：图片。 audio/mp4（audio/mpeg、audio/vnd.wave）：音频文件。 video/mp4（video/mpeg、video/quicktime）：视频文件。 六、拓展阅读 API接口设计指南 前后端分离架构模式的实践（附完整Demo） 七、参考资料 RESTful 架构详解 理解本真的REST架构风格 如何给老婆解释什么是Restful 一个有趣的问题——HTTP是“超文本传输协议”还是“超文本转移协议” Architectural Styles and the Design of Network-based Software Architectures 八、结语在实际的项目应用中，RESTful的应用可以会接口接口设计更加整洁，同一资源减少接口重复。是对Http协议的充分利用。 本文主要介绍REST架构风格的设计思想和RESTful所具有的特性。如希望更深入理解RESTful架构风格，请移步“拓展阅读”部分链接，该部分链接文章介绍了RESTful架构风格的具体应用的实例。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前端/产品设计及UI效果图/墨刀- 强大易用的原型设计与协同工具","date":"2019-03-12T06:57:56.456Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/产品设计及UI效果图/墨刀- 强大易用的原型设计与协同工具/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/产品设计及UI效果图/墨刀- 强大易用的原型设计与协同工具/","excerpt":"","text":"-[x] 墨刀- 强大易用的原型设计与协同工具 -[x] Mockplus（摩客）更快、更简单的原型设计","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前端/CSS 布局","date":"2019-03-12T06:57:56.452Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/CSS 布局/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/CSS 布局/","excerpt":"","text":"display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 浮动： 行内元素浮动之后会变成块级元素 相对定位和绝对定位 position: relative;相对定位：相对定位是“相对于”元素（本身）在文档流中的初始位置；position: absolute;绝对定位是“相对于”距离它最近的已定位祖先元素（即设置了position样式属性的祖先元素），如果不存在已定位的祖先元素，那么相对于初始包含块（即浏览器）。 对普通文档流的影响 在使用相对定位是，无论是否移动，元素仍然占据原来的空间。而与之相反，绝对定位使元素的位置与文档流无关，因此不占据空间。普通文档流中其它元素的布局就像绝对定位的元素不存在时一样。 position:absolute，float会隐式地改变display的类型（display：none除外）。即是当元素设置position:absolute、float:left、float:right中任意一个时，都会让元素以display:inline-block的方式显示（特点是：可以设置长宽，默认宽度不占满父元素）。这时，即使故意设置display:inline; display:block都是无效的。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/前端/Html引入公共页面的几种方法","date":"2019-03-12T06:57:56.452Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/Html引入公共页面的几种方法/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/前端/Html引入公共页面的几种方法/","excerpt":"","text":"[TOC] 一、前言以前我们在引用公共页面是使用JSP的include()方法，后来前后端分离，不在使用JSP，故需要寻找Html的引用公共页面的方法。参考诸多博文，现总结如下，以作备忘。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.03.29 1.0 ZZ 初稿 2 2018.06.8 1.1 ZZ Html引入公共JS/CSS的方法 三、常用的方法3.1、jQuery的load()调用（推荐）1234567891011121314151617181920&lt;html&gt; &lt;body id=“bg”&gt; &lt;!--首部子页面--&gt; &lt;header class=\"header\"&gt;&lt;/header&gt; &lt;!--主框架--&gt; &lt;div id=\"mainbody\"&gt;Test...&lt;/div&gt; &lt;!--底部子页面--&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt; &lt;/body&gt; &lt;!--js引用--&gt; &lt;script type=\"text/javascript\" src=\"../../style/js/jquery.js\"&gt;&lt;/script&gt; &lt;!--加载子页面--&gt; &lt;script&gt; $(document).ready(function () &#123; $(\".header\").load(\"common/header.html\"); $(\".footer\").load(\"common/footer.html\"); &#125;); &lt;/script&gt;&lt;/html&gt; 3.2、JS调用方法（推荐）123function load_home() &#123; document.getElementById(\"viewDiv\").innerHTML = '&lt;object type=\"text/html\" data=\"new.html\" width=\"100%\" height=\"100%\"&gt;&lt;/object&gt;'; &#125; 3.3、iframe 嵌套（不推荐） 本页面调用iframe 12345&lt;html&gt; &lt;div &gt; &lt;iframe src=\"new.html\" width=\"100%\" height=\"100%\" frameborder=\"0\"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/html&gt; 或其他页面调用123456&lt;html&gt; // 被调用页面 &lt;div&gt; &lt;iframe src=\"\" width=\"\" height=\"\" name=\"iframe\" scrolling=\"no\"&gt;&lt;/iframe&gt; &lt;div&gt;&lt;/html&gt; 1234567891011121314151617// 调用页面&lt;html&gt; // html 调用 &lt;div&gt; &lt;a href=\"../etl/setting-Monitor.html\" target=\"iframe\"&gt;监控信号配置&lt;/a&gt; &lt;/div&gt; // htm 调用 &lt;div&gt; &lt;a onclick=\"window.open('fatherPage.action?iframesrc=childPage.action',target = '_self');\"&gt; &lt;/div&gt; // JS 调用 &lt;script&gt; window.onload = function () &#123; window.open('nav.action?iframesrc=tour.action', target = '_top'); &#125;; &lt;/script&gt;&lt;/html&gt; 拓展阅读：document.ready()与window.load()的区别 3.4、Html子页面转换为JS，引用该JS123456789101112131415161718document.writeln(&quot;&lt;!DOCTYPE html&gt;&quot;);document.writeln(&quot;&lt;head&gt;&quot;);document.writeln(&quot;&lt;style&gt;&quot;);document.writeln(&quot;&lt;/style&gt;&quot;);document.writeln(&quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt;&quot;);document.writeln(&quot;&lt;title&gt;&lt;/title&gt;&quot;);document.writeln(&quot; &lt;link href=\\&apos;head.css\\&apos; rel=\\&quot;stylesheet\\&quot; type=\\&quot;text/css\\&quot; /&gt;&quot;);document.writeln(&quot;&lt;/head&gt;&quot;);document.writeln(&quot;&lt;body &gt;&quot;);document.writeln(&quot; &lt;div class=\\&apos;miaov_head\\&apos;&gt;&quot;);document.writeln(&quot; &lt;ul&gt;&quot;);document.writeln(&quot; &lt;li&gt;&lt;a href=\\&quot;&quot;&gt;Test...&lt;/a&gt;&lt;/li&gt;&quot;);document.writeln(&quot; &lt;/ul&gt;&quot;);document.writeln(&quot;&lt;/div&gt;&quot;);document.writeln(&quot; &quot;);document.writeln(&quot;&lt;/body&gt;&quot;);document.writeln(&quot;&lt;/html&gt;&quot;);document.writeln(&quot;&quot;); 转换工具 - 链接 3.5、shtml文件使用ssi技术页面生成shtml文件，只用在头部文件位置加入，然后修改的时候只要修改header.htm文件就可以了。使用shtml的好处是对搜索引擎比较友好，需要处理的文件在服务器端完成的， 不会加重访问者的浏览器负担。 3.6、本地合并即将HTML硬拆成头、尾、内容三个部分的文件，在预览或者发布之前用脚本手工合并。没有后台的时候使用效果不错。 3.7、web服务器（比如IIS）中设定包含（不推荐） 略 3.8、后台模板引擎处理 - 字符串拼接（不推荐） 略 3.9、用图片、flash等外部资源做（不推荐） 略 3.10、angular js里的的使用（不推荐） 略 四、拓展阅读4.1、JSP引入公共JS/CSS的方法 子页面 12345678910&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;script&gt; var DBServiceURI = \"http://192.168.2.10:8080/AnjiOnlineDatabank/\";&lt;/script&gt; 引用页面 1&lt;%@ include file=\"/WEB-INF/jsp/common/commons.jspf\" %&gt; 4.2、Html引入公共JS/CSS的方法 子页面 12&lt;!-- 前端开发框架 --&gt;document.write('&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../../style/components/Extjs/css/bootstrap.min.css\"&gt;&lt;/link&gt; '); 和 12&lt;!-- jquery --&gt;document.write('&lt;script type=\"text/javascript\" src=\"../../style/components/jquery-easyui-1.4.4/jquery.min.js\"&gt;&lt;/script&gt; '); 引用页面1234&lt;!--css引用--&gt;&lt;script type=\"text/javascript\" src=\"../../style/css/common_css.js\"&gt;&lt;/script&gt;&lt;!--js引用--&gt;&lt;script type=\"text/javascript\" src=\"../../style/js/common_js.js\"&gt;&lt;/script&gt; 五、参考资料 为什么前端尽量少用iframe？ html静态页面引入公共html页面 HTML网页下，在div标签中嵌套其他html页面 如何在HTML不同的页面中，共用头部与尾部？ 六、结语 未完待续，待补充 （单页面 组件化内容） + （静态化和伪静态）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 中获取Session的几种方法","date":"2019-03-12T06:57:56.448Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 中获取Session的几种方法/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 中获取Session的几种方法/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 1、将HttpSession作为Spring MVC 的方法参数传入，直接获取12public void getSessionAction(HttpSession session)&#123;&#125; 2、将HttpServletRequest作为Spring MVC 的方法参数，间接获取123public void getSessionAction(HttpServletRequest request)&#123; HttpSession session = request.getSession();&#125; 3、通过@Autowired HttpServletRequest request 获取12@Autowiredprivate HttpServletRequest request; 赠送一个如何在Struts2中获取request对象1HttpServletRequest request = ServletActionContext.getRequest();","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 返回类型","date":"2019-03-12T06:57:56.448Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 返回类型/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 返回类型/","excerpt":"","text":"[TOC] 一、前言SpringMVC处理方法支持如下的返回方式：ModelAndView， Model，ModelMap，Map，View，String，void。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、实例解析1、ModelAndView 示例一： 123456789@RequestMapping(value = &quot;/demo1&quot;,method = RequestMethod.GET)public ModelAndView testMethod1(String param)&#123; // 构建ModelAndView实例，并设置跳转地址 ModelAndView mav = new ModelAndView(&quot;user/mav&quot;); // 将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型 mav.addObject(&quot;key&quot;,param); // 返回ModelAndView对象view return mav;&#125; 示例二： 12345678910111213@RequestMapping(value = &quot;/demo2&quot;,method = RequestMethod.GET) public ModelAndView testMethod2(@RequestParam(&quot;ip&quot;) String ip, Model model)&#123; ModelAndView mav = new ModelAndView(); model.addAttribute(&quot;ip&quot;, ip); mav.addObject(model); mav.setViewName(&quot;user/mav&quot;); return mav; &#125;@RequestMapping(value = &quot;/demo3&quot;,method = RequestMethod.GET)public ModelAndView testMethod3()&#123; return new ModelAndView(&quot;user/mav&quot;,&quot;key&quot;,new String(&quot;makeHappy&quot;));&#125; 2、Model1234567@RequestMapping(value = &quot;/demo4&quot;,method = RequestMethod.GET)public String testMethod4(Model model, HttpSession session,)&#123; model.addAttribute(&quot;colModel&quot;, colModel); model.addAttribute(&quot;colNames&quot;, colNames); model.addAttribute(&quot;buttonName&quot;, buttonName); return &quot;test/test&quot;;&#125; 3、ModelMap12345@RequestMapping(value = &quot;/demo5&quot;,method = RequestMethod.GET)public String testMethod5(String someparam,ModelMap model)&#123; model.addAttribute(&quot;key&quot;,someparam); return &quot;test/test&quot;;&#125; 4、MapModel 是一个接口， 其实现类为ExtendedModelMap，继承了ModelMap类。 12345678@RequestMapping(value = &quot;/demo6&quot;,method = RequestMethod.GET)public String testMethod6(Model model)&#123; model.addAttribute(&quot;colModel&quot;, colModel); model.addAttribute(&quot;colNames&quot;, colNames); model.addAttribute(&quot;buttonName&quot;, buttonName); return &quot;test/test&quot;;&#125; 5、view View 可以返回pdf excel等。 6、StringString 指定返回的视图页面名称，返回地址URL= prefix前缀+视图名称 +suffix后缀组成。注意：如果方法声明了注解@ResponseBody ，则会直接将返回值输出到页面。 1234@RequestMapping(value = &quot;/demo7&quot;,method = RequestMethod.GET)public String testMethod7()&#123; return&quot;test/test&quot;;&#125; 7、void 如果返回值为空，则响应的视图页面对应为访问地址 123@RequestMapping(value = &quot;/demo8&quot;,method = RequestMethod.GET)public void testMethod8()&#123;&#125; 此例对应的逻辑视图名为”demo8”。 三、结语 1、使用 String 作为请求处理方法的返回值类型是比较通用的方法，这样返回的逻辑视图名不会和请求 URL 绑定，具有很大的灵活性，而模型数据又可以通过 ModelMap 控制。 2、使用void，ModelMap，Model时，返回对应的逻辑视图名称真实url为：prefix前缀+视图名称 +suffix后缀组成。 3、使用String,ModelAndView返回视图名称可以不受请求的url绑定，ModelAndView可以设置返回的视图名称。 四、参考资料 spring学习之springMVC 返回类型选择 以及 SpringMVC中model,modelMap.request,session取值顺序 五、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC  注解解析","date":"2019-03-12T06:57:56.440Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC  注解解析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC  注解解析/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、注解解析1、映射解析1.1、@RequestMapping@RequestMapping是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 12345678910111213@Controller@RequestMapping(value=&quot;/book&quot;)public class BookController &#123; @RequestMapping(value=&quot;/title&quot;) public String getTitle()&#123; return &quot;title&quot;; &#125; @RequestMapping(value=&quot;/content&quot;) public String getContent()&#123; return &quot;content&quot;; &#125;&#125; @RequestMapping的value值前后是否有“/”对请求的路径没有影响，即value=”book”、”/book”、”/book/“其效果是一样的。 1.11、RequestMapping的属性 value：指定请求的实际url，地址映射规则如下： 普通URL路径映射 @RequestMapping(value=”/test1”) @RequestMapping(“/test1”) URI模板模式映射 @RequestMapping(value=”/users/{userId}”) @RequestMapping(value=”/users/{userId}/create”) @RequestMapping(value=”/users/{userId}/topics/{topicId}”) Ant风格的URL路径映射 @RequestMapping(value=”/product?”) @RequestMapping(value=”/product*”) @RequestMapping(value=”/products/**/{productId}”) 正则表达式风格的URL路径映射 @RequestMapping(value=”/products/{categoryCode:\\d+}-{pageNumber:\\d+}”) 组合使用是“或”的关系 @RequestMapping(value={“/test1”, “/user/create”}) method请求方法映射限定，GET、POST、PUT、DELETE等。 展示表单一般为GET请求方法；提交表单一般为POST请求方法。有时候我们需要某种方式来告诉相应的功能处理方法只处理某种请求。 一般浏览器只支持GET、POST请求方法。请求方法的详细使用请参考RESTful架构风格。 @RequestMapping(value=”/get/{bookid}”,method=RequestMethod.GET) @RequestMapping(value=”/get/{bookid}”,method={RequestMethod.GET,RequestMethod.POST}) params：指定request中必须包含某些参数值是，才让该方法处理。 请求数据中有指定参数名 @RequestMapping(params=”create”, method=RequestMethod.GET) 请求数据中没有指定参数名 @RequestMapping(params=”!create”, method=RequestMethod.GET) 请求数据中指定参数名=值 @RequestMapping(params=”submitFlag=create”, method=RequestMethod.GET) 请求数据中指定参数名!=值 @RequestMapping(params=”submitFlag!=create”, method=RequestMethod.GET) 组合使用是“且”的关系 @RequestMapping(params={“test1”, “test2=create”}) headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。 @RequestMapping(value=”/header/test1”, headers = “Accept”) @RequestMapping(value=”/header/test4”, headers = “Accept=application/json”) @RequestMapping(value=”/header/test5”, headers = “Accept=text/*”) produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。 如produces=”text/plain;charset=UTF-8” 2、数据绑定2.1、@RequestParam @RequestParam用于将请求参数区数据映射到功能处理方法的参数上。 举个例子： 请求url = “${baseurl}requestparam1?id=101” public String demo1(@RequestParam Integer id) public String demo2(@RequestParam(value=”id”,required=false) int id) public String demo3(@RequestParam(value=”role”) String[] roleList) @RequestParam参数说明： value：参数名字。 required：是否必须，默认是true。 defaultValue：默认值。 2.2、@PathVariable 举个例子 请求url = “${baseurl}users/123/topics/456”1234@RequestMapping(value=\"/users/&#123;userId&#125;/topics/&#123;topicId&#125;\") public String test( @PathVariable(value=\"userId\") int userId, @PathVariable(value=\"topicId\") int topicId) &#123;&#125; 2.3、@ModelAttributeModelAttribute可以应用在方法参数上或方法上，它的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会首先调用该方法。 2.31、@ModelAttribute注释一个方法 controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import demo.model.User;import demo.service.IUserService;@Controller@RequestMapping(value=\"/test\")public class TestController &#123; @Autowired private IUserService userService; /** * 1.@ModelAttribute注释void返回值的方法 */ @ModelAttribute public void populateModel(@RequestParam String abc, Model model) &#123; model.addAttribute(\"attributeName\", abc); &#125; /** * 2.@ModelAttribute注释返回具体类的方法 */ @ModelAttribute public User getUserInfo(String id)&#123; if(id!=null &amp;&amp; !id.equals(\"\"))&#123; return userService.getUserInfo(id); &#125; return null; &#125; /** * 3.@ModelAttribute(value=\"\")注释返回具体类的方法 */ @ModelAttribute(\"str\") public String getParam(@RequestParam String param) &#123; return param; &#125; @RequestMapping(value = \"/helloWorld\") public String helloWorld() &#123; return \"test/helloWorld\"; &#125;&#125; Jsp前台取值 123456789101112131415161718192021222324&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;helloWorld&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 1.The attributeValue is: $&#123;attributeName&#125; &lt;br/&gt;&lt;br/&gt; 2.用户信息：&lt;br/&gt; 姓名：$&#123;user.user_name&#125;&lt;br/&gt; 年龄：$&#123;user.user_age&#125;&lt;br/&gt; 邮箱：$&#123;user.user_email&#125;&lt;br/&gt;&lt;br/&gt; 3.The param is: $&#123;str&#125; &lt;/body&gt;&lt;/html&gt; 2.32 @ModelAttribute注释一个方法的参数当@ModelAttribute注解用于方法参数时，它有了双重功能，即“存/取”。首先，它从模型中取出数据并赋予对应的参数，如果模型中尚不存在，则实例化一个，并存放于模型中；其次，一旦模型中已存在此数据对象，接下来一个很重要的步骤便是将请求参数绑定到此对象上（请求参数名映射对象属性名），这是Spring MVC提供的一个非常便利的机制–数据绑定。 举个例子 请求url = “${baseurl}users?loginName=myLoginName”12345@RequestMapping(value = \"/login.htm\", method = RequestMethod.GET)public String doLogin(@ModelAttribute(\"baseMember\") BaseMember member) &#123; member.setLoginName(\"loginName\"); return \"home\";&#125; 2.4、@SessionAttributes在默认情况下，ModelMap中的属性作用域是request级别，也就是说，当本次请求结束后，ModelMap 中的属性将销毁。如果希望在多个请求中共享ModelMap中的属性，必须将其属性转存到session 中，这样 ModelMap 的属性才可以被跨请求访问。 Controller 1234567891011121314151617181920212223242526272829303132333435package demo.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;import demo.model.User;@Controller@RequestMapping(value=\"/demo1\")//(1)将ModelMap中属性名为currUser的属性放到Session属性列表中，以便这个属性可以跨请求访问@SessionAttributes(\"currUser\")public class Demo1Controller &#123; @RequestMapping(value=\"/getUser\") public String getUser(ModelMap model)&#123; User user=new User(); user.setUser_name(\"zhangsan\"); user.setUser_age(25); user.setUser_email(\"zhangsan@sina.com\"); //(2)向ModelMap中添加一个属性 model.addAttribute(\"currUser\",user); return \"/demo/user\"; &#125; @RequestMapping(value=\"/getUser1\") public String getUser1(ModelMap model)&#123; User user=(User)model.get(\"currUser\"); System.out.println(user.getUser_name()); System.out.println(user.getUser_age()); System.out.println(user.getUser_email()); return \"demo/user1\"; &#125;&#125; user.jsp页面 123456789101112131415161718192021&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%&gt;&lt;%@ page import=\"demo.model.User\" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;br&gt; &lt;%User user=(User)session.getAttribute(\"currUser\");%&gt; 用户名：&lt;%=user.getUser_name() %&gt;&lt;br/&gt; 年龄：&lt;%=user.getUser_age() %&gt;&lt;br/&gt; 邮箱：&lt;%=user.getUser_email() %&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=\"&lt;%=path %&gt;/demo1/getUser1\"&gt;跳转&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 2.5、@Responsebody与@RequestBody@Responsebody表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。 @RequestBody用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上，再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。 Ajax 1234567891011121314151617181920212223$(\"#btn2\").click(function()&#123; var url='&lt;%=request.getContextPath()%&gt;/User/addUserInfo'; var data=&#123;\"user_name\":$(\"#userName\").val(),\"user_sex\":$(\"#userSex\").val(),\"user_age\":$(\"#userAge\").val(), \"user_email\":$(\"#userEmail\").val(),\"user_telephone\":$(\"#userTelephone\").val(),\"user_education\":$(\"#userEducation\").val(), \"user_title\":$(\"#userTitle\").val()&#125;; $.ajax(&#123; type:'POST', contentType : 'application/json', url:url, dataType:\"json\", data:JSON.stringify(data), async:false, success:function(data)&#123; alert(\"新增成功！\"); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown)&#123; alert(XMLHttpRequest.status); alert(XMLHttpRequest.readyState); alert(textStatus); &#125; &#125;)&#125;) Controller 1234567891011121314@RequestMapping(value=\"/addUserInfo\",method=RequestMethod.POST)@ResponseBody //将请求中的data写入UserModel对象中public String addUserInfo(@RequestBody UserModel user)&#123; System.out.println(\"user_name---------\"+user.getUser_name()); System.out.println(\"user_sex----------\"+user.getUser_sex()); System.out.println(\"user_age----------\"+user.getUser_age()); System.out.println(\"user_email--------\"+user.getUser_email()); System.out.println(\"user_title--------\"+user.getUser_title()); System.out.println(\"user_education----\"+user.getUser_education()); System.out.println(\"user_telephone----\"+user.getUser_telephone()); //不会被解析为跳转路径，而是直接写入HTTP response body中 return \"&#123;&#125;\";&#125; 3、数据类型转换 @InitBinder convert the type “String” to type “date” 4、数据格式化5、数据验证三、参考资料 [x] springmvc 注解总结 [x] 史上最全的SpringMVC学习笔记 [x] produces在@requestMapping中的使用方式和作用 四、结语 此篇仅作为个人笔记供参考使用。博主不拥有版权，亦不涉及版权问题。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 框架概述","date":"2019-03-12T06:57:56.440Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 框架概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringMVC学习笔记系列/SpringMVC 框架概述/","excerpt":"","text":"[TOC] 一、前言Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、SpringMVC工作流程1、SpringMVC的请求流程SpringMVC请求响应流程图 SpringMVC请求响应时序图 SpringMVC请求流程描述： 用户向服务器发送请求，请求被DispatcherServlet前端控制器捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping映射器获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter适配器； 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：HttpMessageConveter：将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息；数据转换：对请求消息进行数据转换。如String转换成Integer、Double等；数据根式化：对请求消息进行数据格式化：如将字符串转换成格式化数字或格式化日期等；数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver视图解析器； ViewResolver视图解析器结合Model和View，来渲染视图； 前端控制器向用户响应渲染结果。 三、SpringMVC 容器的初始化配置 web.xml 1234567891011121314151617181920&lt;!-- springMvc前端控制器，在分发其它的控制器前都要经过这个控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 屏蔽springmvc自动注册的异常处理器 --&gt; &lt;init-param&gt; &lt;param-name&gt;detectAllHandlerExceptionResolvers&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序,随Servletp容器一起启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 四、SpringMVC注解解析 详见：SpringMVC注解解析 五、静态文件的访问12345&lt;!-- 对静态资源文件的访问 方案一 --&gt; &lt;mvc:default-servlet-handler/&gt; 或&lt;!-- 对静态资源文件的访问 方案二 --&gt;&lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" /&gt; 五、转发与重定向5.1、重定向 可以通过redirect/forward:url方式转到另一个Action进行连续的处理。 可以通过redirect:url 防止表单重复提交。 5.2、带参数重定向五、ajax请求的处理五、SpringMVC拦截器 自定义一个拦截器，要实现HandlerInterceptor接口 六、SpringMVC全局异常处理七、SpringMVC上传图片八、日期转换器和编码过滤器 日期转换器 12 编码过滤器（web.xml） 12345678910111213&lt;!-- 编码过滤器，解决POST提交中文乱码问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 九、mvc:annotation-driven/的作用&lt;mvc:annotation-driven /&gt; 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean,是spring MVC为@Controllers分发请求所必须的。并提供了：数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持，@Valid支持，读写XML的支持（JAXB），读写JSON的支持（Jackson）。 context:annotation-config declares support for general annotations such as @Required, @Autowired, @PostConstruct, and so on.&lt;mvc:annotation-driven /&gt; is actually rather pointless. It declares explicit support for annotation-driven MVC controllers (i.e.@RequestMapping, @Controller, etc), even though support for those is the default behaviour.My advice is to always declare context:annotation-config, but don’t bother with &lt;mvc:annotation-driven /&gt; unless you want JSON support via Jackson. &lt;mvc:annotation-driven /&gt;实际做了以下工作：（不包括添加自己定义的拦截器） 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 注解请求映射 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\"&gt; &lt;property name=\"interceptors\"&gt; &lt;list&gt; &lt;!-- 日志拦截器，自定义 --&gt; &lt;ref bean=\"logNDCInteceptor\" /&gt; &lt;!-- RequestHelper拦截器，自定义 --&gt; &lt;ref bean=\"myRequestHelperInteceptor\" /&gt; &lt;!-- 权限拦截器，自定义 --&gt; &lt;ref bean=\"myPermissionsInteceptor\" /&gt; &lt;!-- 用户信息拦截器，自定义 --&gt; &lt;ref bean=\"myUserInfoInteceptor\" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"byteArray_hmc\" /&gt; &lt;ref bean=\"string_hmc\" /&gt; &lt;ref bean=\"resource_hmc\" /&gt; &lt;ref bean=\"source_hmc\" /&gt; &lt;ref bean=\"xmlAwareForm_hmc\" /&gt; &lt;ref bean=\"jaxb2RootElement_hmc\" /&gt; &lt;ref bean=\"jackson_hmc\" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"byteArray_hmc\" class=\"org.springframework.http.converter.ByteArrayHttpMessageConverter\" /&gt;&lt;bean id=\"string_hmc\" class=\"org.springframework.http.converter.StringHttpMessageConverter\" /&gt;&lt;bean id=\"resource_hmc\" class=\"org.springframework.http.converter.ResourceHttpMessageConverter\" /&gt;&lt;bean id=\"source_hmc\" class=\"org.springframework.http.converter.xml.SourceHttpMessageConverter\" /&gt;&lt;bean id=\"xmlAwareForm_hmc\" class=\"org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter\" /&gt;&lt;bean id=\"jaxb2RootElement_hmc\" class=\"org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter\" /&gt;&lt;bean id=\"jackson_hmc\" class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\" /&gt; 十、参考资料 Spring MVC 教程,快速入门,深入分析 十一、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 控制反转IoC","date":"2019-03-12T06:57:56.436Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 控制反转IoC/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 控制反转IoC/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、基本概念 IoC：控制反转（Inversion of Control），将程序中原来构造对象的权限，交给Spring容器来构造，当程序需要对象，从Spring容器获取，解决程序对象紧密耦合问题（工厂+反射+ 配置文件）。 DI：依赖注入，通过配置文件为返回对象提供属性的注入。 三、Spring容器装配Bean（基于xml配置） Spring容器通spring配置文件来管理对象，配置文件可以在src或者 WEB-INF目录下，通常名称applicationContext.xml。 3.1 Bean对象的三种定义方式（applicationContext.xml）3.11 使用类构造器定义对象1&lt;bean id=\"user\" class=\"cn.lapland.bussion.user\" /&gt; 3.12 使用静态工厂的静态方法定义对象1&lt;bean id=\"user\" class=\"cn.lapland.spring.b_instance.BeanFactory\" factory-method=\"getBean\" /&gt; 3.13 使用实例工厂的实例方法定义对象1234&lt;!-- 先实例化工厂 --&gt;&lt;bean id=\"beanFactory\" class=\"cn.lapland.spring.b_instance.BeanFactory\" /&gt;&lt;!-- 再通过工厂对象的实例方法来构造对象 --&gt;&lt;bean id=\"user\" factory-bean=\"beanFactory\" factory-method=\"getBean\" /&gt; 3.2 从Spring容器中获取Bean对象 在程序中通过ApplicationContext接口 获取spring工厂对象 ClassPathXmlApplicationContext 读取src下配置文件 FileSystemXmlApplicationContext 读取WEB-INF下配置文件 一个测试实例 1234567891011121314151617public class loggerAspectTest &#123; TestService testService; @Before public void before() &#123; // 读取多个配置文件的方法 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; \"spring/spring-context.xml\", \"spring/spring-mvc.xml\" &#125;); testService = (TestService) context.getBean(\"testServiceImpl\"); &#125; @Test public void testMethod1() &#123; testService.test(); &#125;&#125; 另一个实例123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123; \"classpath*:spring/spring-context.xml\" &#125;)public class userServiceTest &#123; @Resource private UserService userService; @Test public void testMethod1() &#123; User user = userService.getUser(\"1\"); &#125;&#125; 3.3、Bean的作用域 最常用 singleton 和 prototype 两种 123&lt;!--通过scope属性，指定bean的作用域（默认为Singleton单例，可省 ）--&gt;&lt;bean id=\"user\" class=\"cn.lapland.bussion.user\" scope=\"Singleton\" /&gt;&lt;bean id=\"user\" class=\"cn.lapland.bussion.user\" scope=\"prototype\" /&gt; 3.4、Bean的生命周期 待补充。 3.5、Bean属性依赖注入（DI） Spring 配置文件支持构造参数属性注入和setter方法属性注入 3.51 基于构造参数属性注入 POJO的定义 123456789public class Car &#123; private String name; private double price; public Car(String name, double price) &#123; this.name = name; this.price = price; &#125;&#125; 通过constructor-arg 属性进行构造参数注入 1234&lt;bean id=\"car\" class=\"aboutOther.Car\"&gt; &lt;constructor-arg index=\"0\" type=\"java.lang.String\" value=\"BYD\"/&gt; &lt;constructor-arg index=\"1\" type=\"double\" value=\"1000000\"/&gt;&lt;/bean&gt; 3.52 基于setter方法属性注入 POJO的定义 1234567891011121314151617181920212223public class Car &#123; private String name; private double price; private Wheel wheel; public Car(String name, double price) &#123; this.name = name; this.price = price; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void setWheel(Wheel wheel) &#123; this.wheel = wheel; &#125;&#125; 在配置文件 使用 元素完成setter属性注入 123456789&lt;bean id=\"car\" class=\"com.lapland.bussion.Car\"&gt; &lt;!-- name 属性,value主语参数的值 --&gt; &lt;property name=\"name\" value=\"name\" /&gt; &lt;property name=\"price\" value=\"price\" /&gt; &lt;!-- ref引用另一个 Bean的id --&gt; &lt;property name=\"wheel\" ref=\"wheel\" /&gt;&lt;/bean&gt;&lt;bean id=\"wheel\" class=\"com.lapland.bussion.Wheel\" /&gt; 利用p命名空间，简化setter方法注入配置 1234&lt;beans xmlns:p=\"http://www.springframework.org/schema/p\"&gt; &lt;bean id=\"car\" class=\"com.lapland.bussion.Car\" p:name=\"BYD\" p:price=\"100000\" p:car-ref=\"car\"/&gt;&lt;/beans&gt; 3.53 spEL表达式的注入方式123456789101112public class valueBean &#123; private int id = 100; private String name = \"BYD\"; public int getId() &#123; return id; &#125; public String PickName() &#123; return name; &#125;&#125; 12345678910&lt;bean id=\"wheel\" class=\"com.lapland.bussion.valueBean\" /&gt;&lt;bean id=\"SpELDemo\" class=\"com.lapland.bussion.SpELbean\"&gt; &lt;!-- 调用valueBean的getId()方法 --&gt; &lt;property name=\"eId\" value=\"#&#123;valueBean.id&#125;\" /&gt; &lt;!-- 直接调用valueBean的成员方法 --&gt; &lt;property name=\"name\" value=\"#&#123;valueBean.PickName()&#125;\" /&gt; &lt;!-- #&#123;wheel&#125;效果类似于ref --&gt; &lt;property name=\"wheel\" ref=\"#&#123;wheel&#125;\" /&gt;&lt;/bean&gt; 3.54 集合元素类型属性注入12345678910111213141516171819202122public class collectionDemo &#123; private Set&lt;String&gt; sets; private List&lt;Integer&gt; list; private Properties properties; private Map&lt;String, String&gt; maps; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void setList(List&lt;Integer&gt; list) &#123; this.list = list; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;bean id=\"collectionDemo\" class=\"cn.server.impl.collectionDemo\"&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;12&lt;/value&gt; &lt;value&gt;13&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"property1\"&gt;value1&lt;/prop&gt; &lt;prop key=\"property2\"&gt;value2&lt;/prop&gt; &lt;prop key=\"property3\"&gt;value3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"map1\" value=\"value1\" /&gt; &lt;entry key=\"map2\" value=\"value2\" /&gt; &lt;entry key=\"map3\" value=\"value3\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 四、Spring容器装配Bean（基于注解配置）4.1、使用注解配置Bean 加上注解的类会被Spring容器管理。 @Component - 标注于通用实体类 @Controller - 标注web层组件 - Controller/Action @Service - 标注业务层组件 - Service @Respository- 标注持久层的组件 - DaoImlp 4.2、Bean属性依赖注入（DI）1234567891011@Component(&quot;car&quot;)public class Car &#123; @Value(&quot;100&quot;) private int id; @Value(&quot;BYD&quot;) private String name; //支持 spEL @Value(&quot;#&#123;wheel&#125;&quot;) Private wheel wheel;&#125; 4.3、自动装配注解123456789101112131415161718@Component(&quot;car&quot;)public class Car &#123; @Autowired // 按照类型注入 // 如果要允许null值，可以设置它的required=false // 如果容器中存在两个对象相同类型，@Autowired 无法注入 Private wheel wheel; @Autowired @Qualifier（&quot;wheel&quot;） // 配合Qualifier，指定注入Bean的id Private wheel wheel; // 按照名称注入 @Resource（name=&quot;wheel&quot;） Private wheel wheel;&#125; 4.4、Bean的生命周期待完善。 4.5、Bean的作用域12345@Scope（\"prototype\"）// @Scope（\"Singleton\"）public class Car&#123;&#125; 4.6、applicationContext.xml配置12&lt;!-- 组件扫描,service层自动注入 --&gt;&lt;context:component-scan base-package=\"com.lapland.*.service.impl\" /&gt; 四、参考资料linklink 五、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSH(Spring +Struts2+Hibernate）","date":"2019-03-12T06:57:56.436Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSH(Spring +Struts2+Hibernate）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSH(Spring +Struts2+Hibernate）/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP统一处理异常和日志","date":"2019-03-12T06:57:56.436Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP统一处理异常和日志/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP统一处理异常和日志/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Hibernate学习笔记系列/Hibernate 框架概述","date":"2019-03-12T06:57:56.436Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Hibernate学习笔记系列/Hibernate 框架概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Hibernate学习笔记系列/Hibernate 框架概述/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 面向切面编程AOP","date":"2019-03-12T06:57:56.432Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 面向切面编程AOP/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 面向切面编程AOP/","excerpt":"","text":"[TOC] 一、前言Spring提供了两个核心功能，一个是IoC(控制反转)，另外一个便是AOP(面向切面编程)，IoC有助于层与层之间纵向依赖的解耦，AOP则可以实现横向依赖之间的解耦。本文着重来讲面向切面编程的概念解析，实现原理以及应用实例。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、基本概念1、定义AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种纵向的对象层次关系结构。但OOP并不适合定义横向的关系，例如日志功能。代码往往横向地散布在所有对象层次中，而它又体现出与核心业务代码的无关性，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，权限认证、日志、事务等则是横切关注点。如果我们将横切关注点从业务逻辑代码中划分出来，并封装成为可重用模块。并在运行时，再动态地将横切关注点织入到核心关注点的指定方法、指定位置上。这样则便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 AOP图解 另一张图解 2、AOP术语 增强(Advice) 也就是上面说的日志、性能、安全、事务、异常等横切逻辑功能，是由 aspect 添加到特定的 join point (即满足point cut 规则的 join point) 的一段代码。 增强的五种类型： Before：前置增强，在方法被调用之前调用； After：后置增强，在方法完成后调用增强，无论方法是否执行成功； After-returning：后置返回增强，在方法成功执行之后调用增强； After-throwing：后置异常增强，在方法抛出异常后调用增强； Around：环绕增强，在方法调用前后分别调用增强。 连接点(Joinpoint) 程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。 切点(Pointcut) 在众多连接点中，选择使用增强的位置（通过execution( com.lapland.demo..(..)) 切入点表达式筛选）叫做切点。 切点表达式： 关键字：execution(表达式) 表达式语法： [访问修饰符] 返回值 包名.类名.方法名(参数列表) 全匹配方式： execution(public void cn.itcast.service.impl.UserServiceImpl.saveUser()) 访问修饰符可以不写： execution(void cn.itcast.service.impl.UserServiceImpl.saveUser()) 返回值可以使用通配符：通配符* execution(* cn.itcast.service.impl.UserServiceImpl.saveUser()) 包名可以使用通配符：当使用通配符时，有几级包，写几个* execution(* *.*.*.*.UserServiceImpl.saveUser()) 包名称可以使用..，表明的是当前包及其子包 execution(* cn..UserServiceImpl.saveUser()) 类名可以使用通配符： execution(* cn..*.saveUser()) 方法名可以使用通配符： execution(* cn..*.*()) 参数列表可以指定类型：注意的是，如果是基本类型直接写类型名称，如果是引用类型，需要些包名.类名。lang也必须写。例如：java.lang.String execution(* *..*.*(int)) 参数列表可以使用通配符：注意:不能表示有无参数均可。只能表示参数的数据类型是任意的 execution(* *..*.*(*)) 有无参数均可，可以使用..来表示： execution(* *..*.*(..)) 最简版： execution(* *..*.*(..)) 建议的写法： 切到业务层具体实现类即可： execution(* cn.itcast.service.impl.*.*(..)) 切面(Aspect) 切面由切点和增强（引介）组成，它既包含切点的定义，也包含横切逻辑的定义。只有结合切点和增强两者一起才能确定特定的连接点并实施增强逻辑。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 目标对象(Target) 增强逻辑织入的目标类，也就是主干业务逻辑。自己专注于业务本身的逻辑，横切逻辑则可以使用AOP动态织入到特定的连接点上。 引介(Introduction) 引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 织入(Weaving) 织入是将增强添加对目标类具体连接点上的过程。 AOP的三种织入方式： 编译期织入，这要求使用特殊的Java编译器； 类装载期织入，这要求使用特殊的类装载器； 动态代理织入，在运行期为目标类添加增强生成子类的方式。 Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 代理(Proxy) Spring AOP是通过代理实现的。一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。 AOP代理可以是JDK动态代理或者CGLIB代理。 三、AOP的实现原理 JDK动态代理 前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。 CGLib动态代理 后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。 Spring AOP 框架对 AOP 代理类的处理原则是： 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 四、应用实例1、xml配置方式1234567891011121314151617 &lt;!-- 统一异常处理类 Advice--&gt;&lt;bean id=\"handlerExceptionResolver\" class=\"com.lapland.demo.exception.aop.ExceptionHandler\"&gt;&lt;/bean&gt;&lt;!-- 统一异常处理-切面 --&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"handlerExceptionResolver\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.lapland.demo..*(..))\" /&gt; &lt;aop:before method=\"beforeMethod\" pointcut-ref=\"pointcut\" /&gt; &lt;aop:after method=\"afterMethod\" pointcut-ref=\"pointcut\" /&gt; &lt;!-- returning：代表返回的值 --&gt; &lt;aop:after-returning method=\"AfterReturning\" pointcut-ref=\"pointcut\" returning=\"result\" /&gt; &lt;!-- e:代表着要传递的异常 --&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"pointcut\" throwing=\"e\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1.1、定义 Advice Aspect 123456package org.xdemo.example.springaop.aop; public class LogAop_1 &#123; &#125; 测试类 12345678910@Controller@RequestMapping(\"/aop\")public class SpringController &#123; @Log(name=\"您访问了aop1方法\") @ResponseBody @RequestMapping(value=\"aop1\") public String aop1()&#123; return \"AOP\"; &#125;&#125; 2、annotation注解方式2.1、Maven依赖123456789101112131415161718192021222324&lt;properties&gt; &lt;springframework&gt;4.0.5.RELEASE&lt;/springframework&gt; &lt;aspectj&gt;1.8.5&lt;/aspectj&gt; &lt;servlet&gt;3.1.0&lt;/servlet&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectj&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectj&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、spring-mvc.xml配置1234567 &lt;!-- 最重要::如果放在spring-context.xml中，这里的aop设置将不会生效 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; &lt;!-- 启用MVC注解 --&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 日志注解 --&gt;&lt;bean id=\"LogAspect\" class=\"com.lapland.demo.exception.annotation.LogAspect\" /&gt; 2.3、定义 Aspect annotation 123456789101112package org.xdemo.example.springaop.annotation; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.METHOD &#125;)public @interface Log &#123; String name() default \"\";&#125; Aspect 1234567package org.xdemo.example.springaop.aop; @Aspect @Component public class LogAop_1 &#123; &#125; 测试类 123456789101112@Controller@RequestMapping(\"/aop\")public class SpringController &#123; @Log(name=\"您访问了aop1方法\") @ResponseBody @RequestMapping(value=\"aop1\") public String aop1()&#123; return \"AOP\"; &#125;&#125; 拓展阅读参考资料总结 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/mybatis批量操作","date":"2019-03-12T06:57:56.424Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/mybatis批量操作/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/mybatis批量操作/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.01.24 1.0 ZZ 初稿 三、概念解析3.1、占位1234public interface SynCaseCauseMapper &#123; int updateCaseCauseList(List&lt;SynCaseCause&gt; caseCauseList); int insertCaseCauseList(List&lt;SynCaseCause&gt; caseCauseList);&#125; 1234567891011&lt;update id=\"updateCaseCauseList\" parameterType=\"java.util.List\"&gt; &lt;foreach collection=\"list\" item=\"item\" index=\"index\" open=\"\" close=\"\" separator=\";\"&gt; update syn_case_cause &lt;set&gt; num = #&#123;item.num,jdbcType=INTEGER&#125; &lt;/set&gt; where court_name = #&#123;item.courtName,jdbcType=VARCHAR&#125; and syn_case_cause = #&#123;item.synCaseCause,jdbcType=VARCHAR&#125; and s_year = #&#123;item.sYear,jdbcType=VARCHAR&#125; and s_month = #&#123;item.sMonth,jdbcType=VARCHAR&#125; &lt;/foreach&gt;&lt;/update&gt; 12345678910&lt;insert id=\"insertCaseCauseList\" parameterType=\"java.util.List\"&gt; &lt;foreach collection=\"list\" item=\"item\" index=\"index\" open=\"\" close=\"\" separator=\";\"&gt; insert into syn_case_cause (id, court_name, num, syn_case_cause, s_year, s_month ) values (#&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.courtName,jdbcType=VARCHAR&#125;, #&#123;item.num,jdbcType=INTEGER&#125;, #&#123;item.synCaseCause,jdbcType=VARCHAR&#125;, #&#123;item.sYear,jdbcType=VARCHAR&#125;, #&#123;item.sMonth,jdbcType=VARCHAR&#125; ) &lt;/foreach&gt;&lt;/insert&gt; 六、相关术语七、拓展阅读八、参考资料 mybatis批量操作 mysql 批量更新 update foreach 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 框架概述","date":"2019-03-12T06:57:56.424Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 框架概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 框架概述/","excerpt":"","text":"[TOC] 一、前言Spring是一个非常活跃的开源框架；它是一个基于Core来构架多层JavaEE系统的框架,它的主要目地是简化企业开发。 Spring以一种非侵入式的方式来管理你的代码，Spring提倡”最少侵入”，这也就意味着你可以适当的时候安装或卸载Spring。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、Spring的优点 方便解耦，简化开发（Spring IoC特性） AOP编程的支持 声明式事务的支持 方便程序的测试 方便集成各种优秀框架 （整合Struts2 、 Hibernate 、MyBatis 、Struts1 ） 降低JavaEE API的使用难度 （Spring 提供大量工具类， 简化代码编写 ） 三、基本概念Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 - Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web模块：Web上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 - Spring MVC框架：MVC框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 四、Spring容器的启动过程首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境； 其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取； 再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有springmvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是xmlWebApplicationContext。初始化完毕后，spring以org.springframework.web.servlet.FrameworkServlet.CONTEXT”+Servlet名称为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。 五、Spring的配置5.1、Spring容器的初始化配置 web.xml 12345678910111213&lt;!--Spring上下文配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-context.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring上下文监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 防止spring内存溢出监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;&lt;/listener&gt; 5.2、Spring引入外部属性文件 spring-context.xml 1234&lt;!-- 加载MQ配置文件 --&gt;&lt;context:property-placeholder location=\"classpath:activeMQ.properties\" ignore-unresolvable=\"true\" /&gt;&lt;!-- 加载其他xml文件 --&gt;&lt;import resource=\"classpath:spring/spring-context-mybaits.xml\" /&gt; 5.3、Spring连接池配置 spring-context.xml 1234567891011121314151617181920&lt;!-- 加载JDBC配置文件 --&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\" ignore-unresolvable=\"true\" /&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;!-- 开发阶段建议最大连接数据尽量少，够用即可 --&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\" /&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\" /&gt;&lt;/bean&gt;&lt;!-- 应用：Mybatis会话工厂 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 加载mybatis的配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/mybatis-config.xml\"&gt;&lt;/property&gt;&lt;/bean&gt; 5.4、声明式事务管理的两种配置方法5.41、基于advice实现声明式事务管理 spring-context.xml 1234567891011121314151617181920212223242526&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 配置事务传播特性，基于advice，添加tx名字空间--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"load*\" propagation=\"SUPPORTS\" /&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" /&gt; &lt;tx:method name=\"list*\" propagation=\"SUPPORTS\" /&gt; &lt;tx:method name=\"check*\" propagation=\"SUPPORTS\" /&gt; &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 事务管理-切面 --&gt;&lt;aop:config proxy-target-class=\"true\"&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* lapland.*.service.impl.*.*(..))\" /&gt;&lt;/aop:config&gt; 5.42、注解实现声明式事务管理 spring-context.xml 1234567891011&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 配置事务传播特性，基于advice --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;&lt;!-- 开启事务控制的注解支持 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 六、SpringIoC 控制反转控制反转模式（Inversion of Control也称作依赖性介入）的基本概念是：将程序中原来构造对象的权限，交给IoC容器来构造，当程序需要对象，找IoC容器获取。IoC容器需要为程序提供依赖对象。 详见：Spring 控制反转IoC 七、SpringAOP 面向切面编程面向切面编程，即 AOP，是一种编程技术，它允许程序员对横切关注点或横切典型的职责（例如日志和事务管理）进行模块化。AOP的核心构造是切面，它将那些影响多个类的行为封装到可重用的模块中。 详见：Spring 面向切面编程AOP 八、Spring 基础框架整合SSM 详见：基础框架整合SSH(Spring +Struts2+Hibernate） 详见：Spring 基础框架整合SSM(Spring +SpringMVC+Mybatis） 九、参考资料十、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSM(Spring +SpringMVC+Mybatis）","date":"2019-03-12T06:57:56.424Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSM(Spring +SpringMVC+Mybatis）/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring 基础框架整合SSM(Spring +SpringMVC+Mybatis）/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP增强织入顺序","date":"2019-03-12T06:57:56.424Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP增强织入顺序/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Spring学习笔记系列/Spring AOP增强织入顺序/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Mybatis 框架概述","date":"2019-03-12T06:57:56.412Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Mybatis 框架概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Mybatis 框架概述/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、基本概念五、使用association实现延迟加载六、查询缓存6.1、一级缓存6.2、二级缓存六、实现序列化接口四、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Spring的mapper扫描器配置 及 mapper.xml映射文件语法解析","date":"2019-03-12T06:57:56.408Z","updated":"2019-01-24T16:56:55.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Spring的mapper扫描器配置 及 mapper.xml映射文件语法解析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Mybatis学习笔记系列/Spring的mapper扫描器配置 及 mapper.xml映射文件语法解析/","excerpt":"","text":"[TOC] 一、前言在SSM框架中，mybatis的mapper对象生成，往往是通过Spring的mapper扫描器来完成。只需要在spring配置文件中定义一个mapper扫描器，Spring容器启动时，会自动扫描包中的mapper接口（不须实现类），通过映射文件，生成代理对象。 mapper.xml 是对 mapper.java 接口的实现。他们之间的关联通过mapper.xml 中的 标签中的namespace属性实现绑定 本文主要讲解如何写mapper.xml 映射文件，mapper扫描器配置仅是铺垫。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、mapper扫描器配置 2.1、spring-context-mybaits.xml 123456&lt;!-- mapper扫描器，mapper.xml和mapper接口在同一个目录且同名 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 定义被扫描的mapper所在包路径 --&gt; &lt;property name=\"basePackage\" value=\"com.lapland.*.daoMapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 2.2、mybatis-config.xml 配置typeAliases别名。则在mapper.xml中我们就不用每次配置都写类的全名了，但namespace除外。 1234567&lt;configuration&gt; &lt;typeAliases&gt; &lt;!--alias：别名，type：别名映射的类型 --&gt; &lt;typeAlias type=\"com.domain.Student\" alias=\"Student\"/&gt; &lt;/typeAliases&gt; ...&lt;/configuration&gt; 或12345&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.domain\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 2.3、StudentMapper.java 接口 123public interface StudentMapper &#123; Student selectById(Integer id);&#125; 2.4、StudentMapper.xml 映射文件 1234567&lt;mapper namespace=\"com.domain.StudentMapper \"&gt; &lt;select id=\"selectById\" parameterType=\"int\" resultType=\"student\"&gt; select * from student where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 三、mapper.xml语法解析mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。 3.1、一个实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;mapper namespace=\"com.lapland.bussion.daoMapper.UserMapper\"&gt; &lt;!-- 映射管理器 --&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.lapland.bussion.model.User\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"user_name\" jdbcType=\"VARCHAR\" property=\"userName\" /&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" /&gt; &lt;result column=\"age\" jdbcType=\"INTEGER\" property=\"age\" /&gt; &lt;/resultMap&gt; &lt;!-- 定义可重用的Sql片段，用include引用 --&gt; &lt;sql id=\"Base_Column_List\"&gt; id, user_name, password, age &lt;/sql&gt; &lt;!-- 映射查询语句 --&gt; &lt;select id=\"selectByPrimaryKey\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from t_user where user_name like '%$&#123;userName&#125;%' &lt;/select&gt; &lt;!-- 映射删除语句 --&gt; &lt;delete id=\"deleteByPrimaryKey\" parameterType=\"java.lang.String\"&gt; delete from t_user where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/delete&gt; &lt;!-- 映射插入语句 --&gt; &lt;insert id=\"insert\" parameterType=\"com.lapland.bussion.model.User\"&gt; insert into t_user (id, user_name, password, age) values (#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 映射更新语句 --&gt; &lt;update id=\"updateByPrimaryKey\" parameterType=\"com.lapland.bussion.model.User\"&gt; update t_user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, age = #&#123;age,jdbcType=INTEGER&#125; where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/update&gt;&lt;/mapper&gt; 3.2、属性解析 namespace:表示mapper接口的全限定名; id：表示statement的唯一标识，也是接口的方法名，必须一致才能找到； parameterType ：定义入参，类型要与对应的接口方法的类型一致（可选）； parameterMap：定义多个入参，调用已定义的映射管理器的id值； resultType：定义返回类型，匹配普通java类型或自定义的pojo。若不指定，为默认类型； resultMap：定义返回类型，调用已定义的映射管理器的id值. 3.21、#{}与${}的区别 #{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?。使用占位符#{}可以有效防止sql注入。 ${}和#{}不同，通过${}可以将parameterType传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值。 3.22、resultType与resultMap的区别 resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系。 parameterType/parameterMap类似。 3.3、常用的动态语句标签3.31 if 如果输入参数不为空才进行查询条件拼接 1234567891011&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=\"findUserList\" parameterType=\"user\" resultType=\"user\"&gt; select * from user where 1=1 &lt;if test=\"id!=null and id!=''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; 3.32 Where 如果输入参数不为空才进行查询条件拼接 1234567891011&lt;select id=\"findUserList\" parameterType=\"user\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"id!=null and id!=''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.33 foreach 数组 12345&lt;if test=\"ids!=null and ids.size&gt;0\"&gt; &lt;foreach collection=\"ids\" open=\" and (\" close=\")\" item=\"id\" separator=\",\" &gt; id = #&#123;id&#125; &lt;/foreach&gt;&lt;/if&gt; 传递单个List 1234567891011&lt;select id=\"selectUserByList\" parameterType=\"java.util.List\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;!-- 传递List，List中是pojo --&gt; &lt;if test=\"list!=null\"&gt; &lt;foreach collection=\"list\" item=\"item\" open=\"and id in(\"separator=\",\"close=\")\"&gt; #&#123;item.id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 传递单个数组（数组中是POJO） 123456789101112&lt;!-- 传递数组综合查询用户信息 --&gt;&lt;select id=\"selectUserByArray\" parameterType=\"Object[]\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;!-- 传递数组 --&gt; &lt;if test=\"array!=null\"&gt; &lt;foreach collection=\"array\" index=\"index\" item=\"item\" open=\"and id in(\"separator=\",\"close=\")\"&gt; #&#123;item.id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 传递单个数组（数组中是简单类型） 123456789101112&lt;!-- 传递数组综合查询用户信息 --&gt;&lt;select id=\"selectUserByArray\" parameterType=\"Object[]\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;!-- 传递数组 --&gt; &lt;if test=\"array!=null\"&gt; &lt;foreach collection=\"array\" index=\"index\" item=\"item\" open=\"and id in(\"separator=\",\"close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签解析 collection:数组类型，array、list。 index：为数组的下标。 item：为数组每个元素的名称，名称随意定义 open：循环开始 close：循环结束 separator：中间分隔输出 3.34 set123456789101112&lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"pojo.Orderitem\" &gt; update orderitem &lt;set &gt; &lt;if test=\"productId != null\" &gt; product_id = #&#123;productId,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"count != null\" &gt; count = #&#123;count,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;/set&gt; where orderitem_id = #&#123;orderitemId,jdbcType=VARCHAR&#125; &lt;/update&gt; 3.35 choose / when / otherwise1234567891011121314151617181920212223&lt;!-- 查询学生list，like姓名、或=性别、或=生日、或=班级，使用choose --&gt;&lt;select id=\"getStudentListChooseEntity\" parameterType=\"StudentEntity\" resultMap=\"studentResultMap\"&gt; SELECT * from STUDENT_TBL ST &lt;where&gt; &lt;choose&gt; &lt;when test=\"studentName!=null and studentName!='' \"&gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT('%', #&#123;studentName&#125;),'%') &lt;/when&gt; &lt;when test=\"studentSex!= null and studentSex!= '' \"&gt; AND ST.STUDENT_SEX = #&#123;studentSex&#125; &lt;/when&gt; &lt;when test=\"studentBirthday!=null\"&gt; AND ST.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125; &lt;/when&gt; &lt;when test=\"classEntity!=null and classEntity.classID !=null and classEntity.classID!='' \"&gt; AND ST.CLASS_ID = #&#123;classEntity.classID&#125; &lt;/when&gt; &lt;otherwise&gt; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 3.36 Map映射 实例 - 1 实例 - 2 四、一对多、多对一、多对多映射关系4.1 顾客和订单的例子: 一个顾客可以有多个订单, 一个订单只对应一个顾客 SQL语句 1234567891011121314151617181920212223242526CREATE DATABASE test;USE test;CREATE TABLE person( personId VARCHAR(36) PRIMARY KEY, personName VARCHAR(64), personAddress VARCHAR(128), personTel VARCHAR(11));CREATE TABLE orders( orderId VARCHAR(36) PRIMARY KEY, orderNumber VARCHAR(20), orderPrice INT, pid VARCHAR(36));INSERT INTO person VALUES('001', 'Jack', 'Wuhan', '1234567');INSERT INTO orders VALUES('O_00001', '00001', 100, '001');INSERT INTO orders VALUES('O_00002', '00002', 200, '001');SELECT p.*, o.*FROM person p JOIN orders o ON (p.personId=o.pid)WHERE p.personId = '001' 顾客实体 123456789public class Person &#123; private String id; private String name; private String address; private String tel; private List&lt;Order&gt; orders;&#125; 订单实体 12345678public class Order &#123; private String id; private String number; private int price; private Person person;&#125; 顾客Mapper 12345678910111213141516&lt;mapper namespace=\"com.lapland.domain.Person\"&gt; &lt;resultMap type=\"Person\" id=\"personBean\"&gt; &lt;id column=\"personId\" property=\"id\"/&gt; &lt;result column=\"personName\" property=\"name\"/&gt; &lt;result column=\"personAddress\" property=\"address\"/&gt; &lt;result column=\"personTel\" property=\"tel\"/&gt; &lt;!-- 一对多的关系 --&gt; &lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt; &lt;collection property=\"orders\" ofType=\"Order\"&gt; &lt;id column=\"orderId\" property=\"id\"/&gt; &lt;result column=\"orderNumber\" property=\"number\"/&gt; &lt;result column=\"orderPrice\" property=\"price\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 订单Mapper 12345678910111213141516&lt;mapper namespace=\"com.lapland.domain.Order\"&gt; &lt;resultMap type=\"Order\" id=\"orderBean\"&gt; &lt;id column=\"orderId\" property=\"id\"/&gt; &lt;result column=\"orderNumber\" property=\"number\"/&gt; &lt;result column=\"orderPrice\" property=\"price\"/&gt; &lt;!-- 多对一的关系 --&gt; &lt;!-- property: 指的是属性的值, javaType：指的是属性的类型--&gt; &lt;association property=\"person\" javaType=\"Person\"&gt; &lt;id column=\"personId\" property=\"id\"/&gt; &lt;result column=\"personName\" property=\"name\"/&gt; &lt;result column=\"personAddress\" property=\"address\"/&gt; &lt;result column=\"personTel\" property=\"tel\"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 五、参考资料 Mybatis 框架使用的最核心内容（二）：mapper.xml中常用的标签详解 Mybatis框架学习（二）—DAO开发方式和Mapper代理的开发方式 六、结语 未完待续…","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Struts2学习笔记系列/Struts2 框架概述","date":"2019-03-12T06:57:56.388Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Struts2学习笔记系列/Struts2 框架概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/Struts2学习笔记系列/Struts2 框架概述/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、Struts2工作流程1、Struts2的请求流程Struts2请求响应流程图 Struts2请求响应时序图 Struts2请求流程描述： 1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求；2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMeshPlugin）；3、接着StrutsPrepareAndExecuteFilter被调用，StrutsPrepareAndExecuteFilter询问ActionMapper来决定这个请求是否需要调用某个Action；4、如果ActionMapper决定需要调用某个Action，StrutsPrepareAndExecuteFilter把请求的处理交给ActionProxy；5、ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类；6、ActionProxy创建一个ActionInvocation的实例；7、ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。8、一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2框架中继承的标签。在这个过程中需要涉及到ActionMapper。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringBoot学习笔记系列/Spring boot接受json赋值给java对象","date":"2019-03-12T06:57:56.384Z","updated":"2018-12-17T01:22:19.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringBoot学习笔记系列/Spring boot接受json赋值给java对象/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/Web框架/SpringBoot学习笔记系列/Spring boot接受json赋值给java对象/","excerpt":"","text":"[x] Spring boot接受json赋值给java对象 [x] controller接收json方式 [x] Spring框架 之@Valid注解的使用（嵌套类型的效验）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/浅谈Ajax请求","date":"2019-03-12T06:57:56.376Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/浅谈Ajax请求/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/浅谈Ajax请求/","excerpt":"","text":"Jquery的Ajax中contentType和dataType的区别","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/数据字典表设计 & 加载配置文件的几种方法","date":"2019-03-12T06:57:56.372Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/数据字典表设计 & 加载配置文件的几种方法/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/数据字典表设计 & 加载配置文件的几种方法/","excerpt":"","text":"[TOC] 一、前言一些固定的常量、配置项被定义到数据字典表中，方便系统维护，由超级管理员进行维护，如果用户需求要增加变更配置项，只需要修改数据字典表记录即可，不需要修改代码。例如数据下拉框数据填充和国际化处理。 Java 定义配置常量的几种方法： 1、枚举类2、全局常量3、config.properties / config.xml配置文件4、数据库表 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.17 1.0 ZZ 初稿 2 2018.07.20 1.0 ZZ Java工程读取resources中资源文件路径问题 三、Java读取配置文件 config.xml 1234567&lt;?xml version = \"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;XML配置文件&lt;/comment&gt; &lt;entry key=\"author\"&gt;且听风吟_z&lt;/entry&gt; &lt;entry key=\"url\"&gt;www.lapland.top&lt;/entry&gt;&lt;/properties&gt; config.properties 12# Otherurl=www.lapland.top EnumConfig 1234567891011121314151617181920212223242526272829package com.lapland.utils.readProperties;/** * 枚举类 * @author zz * @date 上午12:16 18-7-17 */public enum EnumConfig &#123; OPEM(0, \"公开\"), CLOSE(1, \"保密\"); private final int code; private final String desc; EnumConfig(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; public int getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125;&#125; ParsePropertiesUtil 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.lapland.utils.readProperties;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.util.Properties;/** * 读取propertie和xml配置文件工具类 * @author zz * @date 上午1:29 18-7-17 */public class ParsePropertiesUtil &#123; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(ParsePropertiesUtil.class); //private static final String FILE_PATH = \"resources/config.properties\"; private static final String FILE_PATH = \"resources/config.xml\"; private static Properties props; static &#123; props = new Properties(); try &#123; //props.load(new InputStreamReader(ParsePropertiesUtil.class.getClassLoader().getResourceAsStream(FILE_PATH), \"UTF-8\")); props.loadFromXML((ParsePropertiesUtil.class.getClassLoader().getResourceAsStream(FILE_PATH))); &#125; catch (IOException e) &#123; LOGGER.error(\"配置文件读取异常\\n\" + e.getMessage()); &#125; &#125; /** * 通过key获取value * @param key * @return java.lang.String */ public static String getProperty(String key) &#123; String value = props.getProperty(key.trim()); if (StringUtils.isBlank(value)) &#123; return value; &#125; return value.trim(); &#125; /** * 默认值 * @param key * @param defaultValue * @return java.lang.String */ public static String getProperty(String key, String defaultValue) &#123; String value = props.getProperty(key.trim()); if (StringUtils.isBlank(value)) &#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; ReadProperties 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.lapland.tools.readProperties;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 数据字典表设计及读取配置文件的几种方法 * @author zz * @date 下午11:40 18-7-16 */public class ReadProperties_Test &#123; private static final String CODE_TITLE = \"数据字典表设计及读取配置文件的几种方法\"; /** logger日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(ReadProperties_Test.class); /** * 读取全局变量 * @return void */ private void readGlobalVariable() &#123; LOGGER.info(\"标题：\" + CODE_TITLE); &#125; /** * 读取枚举类 * @return void */ private void readEnum() &#123; LOGGER.info(\"密级：\" + EnumConfig.OPEM.getDesc()); &#125; /** * 读取config.XML * @return void */ private void readXML() &#123; LOGGER.info(\"作者：\" + ParsePropertiesUtil.getProperty(\"author\")); &#125; /** * 读取config.Propertie * @return void */ private void readPropertie() &#123; LOGGER.info(\"网址：\" + ParsePropertiesUtil.getProperty(\"url\")); &#125; /** * 读取数据库表 * @return void */ private void readDictionary() &#123; LOGGER.info(\"摘要：\" + \"***********************\"); &#125; /** * 测试类 * @return void */ @Test public void println() &#123; readGlobalVariable(); readEnum(); readXML(); readPropertie(); readDictionary(); &#125;&#125; 3.1、数据库表 字典类型表 dict_type：记录数据字典类型 字段名 描述 typecode 主键 typename 名称 status 状态 字典明细表 dict_info：记录数据字典明细 字段名 描述 id 主键 typecode 外键（类型） dictcode 编码值 info 编码名称 四、Spring读取配置文件12345&lt;!-- 加载jdbc配置文件 --&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\" ignore-unresolvable=\"true\"/&gt;&lt;import resource=\"classpath:spring/spring-context-shiro.xml\" /&gt; 五、拓展阅读代码见：JavaUtils项目 六、参考资料 [x] Java工程读取resources中资源文件路径问题 [x] 数据字典表设计 [ ] 大家在开发中，系统数据字典都是怎么设计的？ [ ] 数据字典范例1.0 [ ] 一种数据字典表的创建方式 九、结语 将频繁使用的数据字典项缓存在内存中，提高检索效率。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/[已发布]浅谈Java异常处理机制及项目中的的规范处理方法","date":"2019-03-12T06:57:56.372Z","updated":"2019-01-01T08:41:35.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/[已发布]浅谈Java异常处理机制及项目中的的规范处理方法/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/[已发布]浅谈Java异常处理机制及项目中的的规范处理方法/","excerpt":"","text":"[TOC] 一、前言本文主要讲述异常处理的机制和原理，以及探讨开发Java程序时，每一层如何进行异常处理？异常何时被抛出？何时被记录？如何记录？记录checked异常还是unChecked异常？异常是否应该呈现到前端页面？如何设计一个异常框架等问题。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 1 2019.01.01 1.1 ZZ 修改描述 二、基本概念异常是程序在运行时出现的不正常情况。是Java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。 异常处理的目的是提高程序的健壮性。你可以在catch和finally代码块中给程序一个修正机会，使得程序不因不可控制的异常而影响程序的流程。同时，通过获取Java异常信息，也为程序的开发维护提供了方便。 Java异常类层次结构图 Java中的异常用对象来处理,并定义java.lang.Throwable作为所有异常的超类。Throwable分成了两个不同的分支，Exception（异常）和 Error（错误）； 其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常。或不受检查异常（非编译异常）和检查异常（或编译异常 Checked Exception）； 异常是针对 方法 来说的，抛出、声明抛出、捕获和处理异常都是在方法中进行的； Java异常处理通过5个关键字try、catch、throw、throws、finally进行管理； Error（错误）：灾难性的致命的错误，是程序无法控制和处理的。 Error类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误、内存溢出。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误、链接错误。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。 Exception（异常）：通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。。 运行时异常和受检查异常 运行时异常 (unChecked异常)： RuntimeException类及其子类都被称为运行时异常。这些异常一般是由程序逻辑错误引起的，属于应该解决的Bug，程序应该从逻辑角度避免这类异常的发生，不推荐try-catch来捕获处理，但是有时候为了增强用户体验，保证Crash次数降到最低，会人为捕捉一些运行时异常。这种异常的特点是Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try-catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过。但在运行时会被系统自动抛出。 非运行时异常 (checked异常)： 除了RuntimeException类及其子类外，其他的Exception类及其子类都属于非运行时异常，从程序语法角度讲是必须进行处理的异常，如果不处理程序就不能编译通过。 异常转型和异常链： 我们做的JEE项目时候，一般会有三层的结构：持久层、逻辑层、展现层。异常也是如此的，当我们各个层之间传递异常，我们就需要先封装，然后传递。 异常链示例 1234catch (SQLException e) &#123; throw new JdbcException(e); &#125; 三、异常处理机制在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。 抛出异常 当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。 该方法的调用者必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，所经方法都层层上抛获取的异常，若最终都没有被处理，将交由虚拟机处理。处理也很简单，就是打印异常消息和堆栈信息，记录日志。 捕捉异常 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，如果出现异常的线程为主线程，则整个程序运行终止；如果非主线程，则终止该线程，其他线程继续运行。 在方法中用try-catch语句捕获并处理异常，catach语句可以有多个，用来匹配处理异常。并且尽量将捕获底层异常类的catch子句放在前面。 异常总是先被抛出，后被捕捉的。 Java规定 对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。RuntimeException由业务逻辑保证。 3.1、抛出异常实例（throws 和 throw）1234567public class Throws &#123; public static void main(String[] args) throws Exception&#123;//抛出异常类 System.out.println(10 / 0); throw new Exception(\"抛出异常对象\"); //System.out.println(\"throw后面的代码不再执行\"); &#125;&#125; 3.2、捕获异常实例（try-catch 和 finally）123456789101112131415161718192021222324252627import java.util.InputMismatchException;import java.util.Scanner;public class TryCatch &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; //可能会发生异常的程序代码 System.out.print(\"请输入一个数字:\"); int a = input.nextInt(); &#125; catch (InputMismatchException e) &#123;// 捕捉异常 System.err.println(\"数据类型不符!\"); e.printStackTrace(); System.err.println(e.getMessage()); // return; 若捕捉到异常会先执行finally, 再return。 &#125; catch (Exception e) &#123;// catch 先写子类，再写父类 System.out.println(\"再捕捉一次!\"); // System.exit(0); &#125; finally &#123;// 除非执行System.exit(0)，否则都会执行 System.out.println(\"finally 被执行!\"); // 应用举例：确保关闭数据库，关闭流 &#125; System.out.println(\"我还是被执行了!\"); // 如果提前return，则不执行了 &#125;&#125; throw 和throws关键字的区别 throw用于抛出异常对象，后面跟的是异常对象；throw用在方法内。 throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在方法方法签名上。 通常情况：方法内容如果有throw，抛出异常对象，并没有进行处理，那么方法上一定要声明，否则编译失败。 四、Java常见异常4.1、Error LinkageError：链接错误; ThreadDeath：线程死锁; OutOfMemoryError：内存溢出; StackOverflowError ：堆栈溢出； NoClassDefFoundError：类定义错误; Virtual MachineError：虚拟机运行错误。 4.2、运行时异常（unChecked异常） SecurityException：安全性异常； NullPointerException：空指针异常； ClassCastException：类型强制转换异常； ClassNotFoundException：找不到类异常； IllegalArgumentException：非法参数异常； NegativeArraySizeException：数组长度为负异常； ArithmeticException：算术条件异常。如：整数除零； ArrayIndexOutOfBoundsException：数组下标越界异常； ArrayStoreException：数组中包含不兼容的值抛出的异常； StringIndexOutOfBoundsException：字符串下标越界异常； ArrayStoreException：向数组中存放与声明类型不兼容对象异常； 4.3、非运行时异常（checked异常） IOException：输入输出流异常； SQLException：数据库操作异常； EOFException：文件已结束异常； TimeoutException：执行超时异常； DataFormatException：数据格式化异常； NoSuchFieldException：没有匹配的属性异常； ClassNotFoundException：没有匹配的类异常； FileNotFoundException：没有匹配的文件异常； NoSuchMethodException：没有匹配的方法异常； 4.4、Throwable类的主要方法 public String getMessage()：返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 public Throwable getCause()：返回一个Throwable 对象代表异常原因。 public String toString()：使用getMessage()的结果返回类的串级名字。 public void printStackTrace()：打印toString()结果和栈层次到System.err，即错误输出流。 public StackTraceElement [] getStackTrace()：返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 public Throwable fillInStackTrace()：用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 五、自定义异常实例 实例一： 12345678910111213141516171819class UserException extends Exception &#123; // 继承父类 public UserException() &#123; super(); &#125; public UserException(String message) &#123; super(message); &#125;&#125;public void activatioin(String code) throws UserException &#123; try &#123; User user = userDao.findByCode(code); if(user == null) throw new UserException(\"无效的激活码！\"); if(user.isStatus()) throw new UserException(\"您已经激活过了\"); userDao.updateStatus(user.getUid(), true); // 修改状态 &#125; catch(SQLException e) &#123; throw new RuntimeException(e); &#125;&#125; 实例二： 12345678910111213141516171819202122232425262728293031323334package Test;import java.lang.Exception;public class TestException &#123; static int quotient(int x, int y) throws MyException &#123; // 定义方法抛出异常 if (y &lt; 0) &#123; // 判断参数是否小于0 throw new MyException(\"除数不能是负数\"); // 异常信息 &#125; return x/y; // 返回值 &#125; public static void main(String args[]) &#123; // 主方法 int a =3; int b =0; try &#123; // try语句包含可能发生异常的语句 int result = quotient(a, b); // 调用方法quotient() &#125; catch (MyException e) &#123; // 处理自定义异常 System.out.println(e.getMessage()); // 输出异常信息 &#125; catch (ArithmeticException e) &#123; // 处理ArithmeticException异常 System.out.println(\"除数不能为0\"); // 输出提示信息 &#125; catch (Exception e) &#123; // 处理其他异常 System.out.println(\"程序发生了其他的异常\"); // 输出提示信息 &#125; &#125;&#125;class MyException extends Exception &#123; // 创建自定义异常类 String message; // 定义String类型变量 public MyException(String ErrorMessagr) &#123; // 父类方法 message = ErrorMessagr; &#125; public String getMessage() &#123; // 覆盖getMessage()方法 return message; &#125;&#125; 六、Java异常处理的原则和技巧 不要把自己能处理的异常抛给别人； catch块尽量保持一个块捕获一类异常； 细化异常的类型，不要不管什么类型的异常都写成Excetpion； 避免过大的try块，不要把不会出现异常的代码放到try块里面； 如果把父类的异常放到前面，后面的catch语句块将得不到执行的机会； 尽量将异常统一抛给上层调用者，由上层调用者统一决定如何进行处理。 不要用try-catch参与控制程序流程，异常控制的根本目的是处理程序的非正常情况; 只要不是retry或者queue的情况，基本上所有的异常都是需要继续向上抛的，最终交给顶层异常处理机制（应用或者容器）。 Java异常处理三原则 具体明确 提早抛出 通过提早抛出异常（又称＂迅速失败＂），异常得以清晰又准确。堆栈信息立即反映出什么出了错（提供了非法参数值），为什么出错（文件名不能为空值），以及哪里出的错（readPreferences()的前部分）。 延迟捕获 异常发生时，不应立即捕获，而是应该考虑当前作用域是否有有能力处理这一异常的能力，如果没有，则应将该异常继续向上抛出，交由更上层的作用域来处理。 如何记录异常(写入日志) 在异常最开始发生的地方进行日志信息记录； 如果捕获到一个异常，但是这个异常是可以处理的。则无须记录异常; 捕获到一个未记录过的异常或外部系统异常时，应该记录异常的详细信息。 记录checked异常还是unChecked异常 如果一个异常是可以恢复的，可以被调用者正确处理的，使用checked异常； 如果一个异常是致命的，不可恢复的。或者调用者去捕获它没有任何益处，使用unChecked异常； 在使用unChecked异常时，必须在在方法声明中详细的说明该方法可能会抛出的unChekced异常。由调用者自己去决定是否捕获unChecked异常； 受检异常尽可能转化为非受检异常。 在类继承的时候，方法覆盖时如何进行异常处理 如果父类的方法声明一个异常，则子类在重时声明的异常范围应该不小于 父类； 如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws； 如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。 七、异常的转换与异常链七、异常统一处理一个好的异常处理框架能为应用程序的异常处理提供统一的日志记录、异常通知、处理视图，把异常处理从程序正常运行逻辑分离出来，提供更加结构化以及可读性的系统架构。另外，一个好的异常处理框架具备可扩展性，很容易根据具体的异常处理需求，扩展出特定的异常处理逻辑。 通常的异常处理模式包括业务委托模式（Business Delegate）、前端控制器模式（Front Controller）、拦截过滤器模式（Intercepting Filter）、AOP 模式、模板方法模式等。 利用spring aop统一处理异常和打日志 八、几点思考8.1、抛出异常的时机？ DAO层不处理任何异常，Service层能在处理的尽早处理，然后通过一个状态码将信息返回给Action层。Action层的逻辑尽量简单些为好，因为Action是接口层，太复杂让人难以一眼看穿接口要提供的功能。 8.2、IOException 为什么被声明为检查型异常？8.3、java为什么引入异常处理机制？七、拓展阅读 浅谈Java项目日志记录和分析(基于log4j介绍) 八、参考资料 异常处理_百度百科 Java EE项目中的异常处理 深入理解java异常处理机制 异常以及异常处理框架探析 Jersey框架的统一异常处理机制 java web项目整体异常处理机制- 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/也谈上下文对象","date":"2019-03-12T06:57:56.356Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/也谈上下文对象/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/也谈上下文对象/","excerpt":"","text":"一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、概念解析Context可以理解为提供信息或功能的容器或环境。容器里的东西是共享的。 Web上下文（ServletContext）目标对象是所有Web应用，Spring 上下文（ApplicationContext）目标对象是单个Web 应用，SpringMVC上下文（WebApplicationContext）目标对象是单个SpringMVC(是spring 上下文的子上下文，继承自 Spring 上下文，能够调用父的东西，反之，不可)。 三、上下文对象解析3.1、Context访问JNDI时候用的Context 3.2、HttpContext1HttpContext context = HttpContext.Current; 3.3、pageContextpageContext是JSP中的内置对象之一。提供了对JSP页面所有的对象及命名空间的访问，这里 Context 看作是一个实现访问 JSP 页面之间的数据共享的容器。 3.4、ServletContext一个Web运用只有一个 ServletContext 实例,它代表当前的web应用。它在Web 容完全启动 Web 项目之前被创建,生命周期伴随整个 Web 运用。 容器中所有的Servlet共享同一个 ServletContext 对象，因此Servlet对象之间可以通过 ServletContext 对象来实现通讯。利用 ServletContext 能够获得Web运用的配置信息。 当在编写一个 Servlet 类的时候, 首先是要去继承一个抽象类 HttpServlet,然后可以直接通过 getServletContext() 方法来获得 ServletContext 对象，这是因为 HttpServlet类中实现了 ServletConfig接口,而 ServletConfig 接口中维护了一个 ServletContext 的对象的引用。 web.xml 1234567891011121314&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:oracle:thin:@localhost:1521:ORC&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;scott&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;tigger&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; ConnectionServlet 12345678910111213public class ConnectionServlet extends HttpServlet &#123; public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123; ServletContext context = getServletContext(); System.out.println(\"***************************************\"); System.out.println(\"URL: \" + context.getAttribute(\"url\")); System.out.println(\"Username: \" + context.getAttribute(\"username\")); System.out.println(\"Password: \" + context.getAttribute(\"password\")); System.out.println(\"***************************************\"); super.service(request, response); &#125;&#125; 3.5、ActionContextActionContext 是当前 Action 执行时的上下文环境, ActionContext 中维护了一些与当前 Action 相关的对象的引用, 如: Parameters (参数), Session (会话), ValueStack (值栈), Locale (本地化信息) 等。 ContextAction 123456789101112131415161718192021222324public class ContextAction extends ActionSupport &#123; private String username; private String password; public String execute()&#123; ActionContext context = ActionContext.getContext(); ValueStack value = context.getValueStack(); value.set(\"username\", username); value.set(\"password\", password); Map&lt;String, Object&gt; session = context.getSession(); session.put(\"url\", \"http://www.lapland.top\"); return SUCCESS; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Jsp取值 123&lt;s:property value=\"username\"/&gt;&lt;BR&gt;&lt;s:property value=\"password\"/&gt;&lt;BR&gt;&lt;s:property value=\"#session.url\"/&gt;&lt;BR&gt; 3.6、ServletActionContextServletActionContext 是 ActionContext 的一个子类。ServletActionContext 从名字上来看，意味着它与 Servlet API 紧密耦合。ServletActionContext 的构造子是私有的，主要是提供了一些静态的方法,可以用来获取：ctionContext，ActionMapping，PageContext， HttpServletRequest，HttpServletResponse，ServletContext，ValueStack，HttpSession 对象的引用。 获取方法 123456789public String execute()&#123; HttpServletRequest request = ServletActionContext.getRequest(); HttpServletResponse response = ServletActionContext.getResponse(); HttpSession session = request.getSession(); ServletContext context = ServletActionContext.getServletContext(); return SUCCESS;&#125; 3.7、ApplicationContextSpring上下文对象。容器调用 web.xml 中配置的 contextLoaderListener，初始化 ApplicationContext 上下文环境（即Spring容器），加载 context-param 指定的配置文件信息到Spring容器中。 配置： 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取方法一： 123// ClassPathXmlApplicationContext --从classpath路径加载配置文件，创建Bean对象ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");ClassName clazz =(ClassName)ctx.getBean(\"beanName\"); 获取方法二： 123// FileSystemXmlApplicationContext --从指定的目录中加载ApplicationContext ctx = new FileSystemXmlApplicationContext(\"src/applicationContext.xml\");ClassName clazz =(ClassName)ctx.getBean(\"beanName\"); 获取方法三： 123ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);ctx.getBean(\"beanId\"); 3.8、WebApplicationContextweb容器在启动时，Spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，也称为父上下文（父容器），在ServletContext中以键值对的形式保存，key是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。 容器初始化web.xml中配置的servlet，为其初始化自己的上下文信息servletContext，并加载其设置的配置信息到该上下文中。将WebApplicationContext设置为它的父容器。 DispatcherServlet是一个Servlet,可以同时配置多个，每个 DispatcherServlet有一个自己的上下文对象（WebApplicationContext），称为子上下文（子容器），子上下文可以访问父上下文中的内容，但父上下文不能访问子上下文中的内容。 它也保存在ServletContext中，key是”org.springframework.web.servlet.FrameworkServlet.CONTEXT”+Servlet名称。 当一个Request对象产生时，会把这个子上下文对象（WebApplicationContext）保存在Request对象中，key是DispatcherServlet.class.getName() + “.CONTEXT”。 容器的获取 1WebApplicationContext wac = (WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); 父子容器关系图 参考：Spring 框架概述 - Spring的启动过程 12 3.9、SessionContext 略 3.10、Android Context 略 3.11、上下文与作用域的区别 参考：spring applicationContext 和webApplicationContext 区别 3.12、上下文与作用域的区别 略 四、参考资料 几个 Context 上下文的区别 spring和springMVC父子容器的原理 Spring父子上下文(WebApplicationContext) 扯谈spring mvc之WebApplicationContext的继承关系 spring中的BeanFactory与ApplicationContext的作用和区别？ 五、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/系统开发手册/系统规格需求说明书","date":"2019-03-12T06:57:56.344Z","updated":"2018-11-29T02:26:13.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/系统开发手册/系统规格需求说明书/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/系统开发手册/系统规格需求说明书/","excerpt":"","text":"[TOC] 一、项目概述二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.11.29 1.0 ZZ 初稿 三、 项目背景四、 用户角色五、 需求分析六、 业务流程七、 业务功能模块八、项目配置情况8.1、人员配置 角色 职责 人员 项目经理 项目整体执行控制 架构师 系统架构搭建 系统集成 技术预研 需求分析 需求调研、需求分析 编写系统需求规格说明书 开发 系统模块开发编码 单元测试 参与系统集成 配合系统测试，修改bug 配合系统产品化工作 编写用户操作手册 测试 编写测试用例 系统集成测试 系统功能测试 系统性能测试 产品化 制作系统安装包 制作系统升级包 运维 系统安装调试 用户培训 后期系统维护 8.2、开发周期 当需求不明确，使用原型模型降低风险。 阶段名称 开始时间 结束时间 工期 需求阶段 开发阶段 测试阶段 部署上线 8.3、开发环境 网络环境 局域网 硬件平台 本地: Web服务器 + 数据库服务器 操作系统平台 Windows 7 数据库平台 MySql Java环境 Jdk1.7 Web服务 Tomcat 7 项目构建 Maven3.2 IDE Eclipse4.3 或 IDEA 版本管理 SVN 8.4、测试环境 网络环境 局域网 + 互联网 硬件平台 本地: Web服务器 + 数据库服务器 操作系统平台 Windows 7 + Linux 数据库平台 MySql + Oracle + MongoDB Java环境 Jdk1.7 Web服务 Tomcat 7 8.5、系统正式运行的环境 网络环境 互联网 硬件平台 Web服务器 x 1 &amp; 数据库服务器 x 1 操作系统平台 Windows 7 &amp; Centos 7 数据库平台 MySql &amp; Oracle10G Java环境 Jdk1.7 Web服务 Tomcat 7 九、系统设计9.1、系统概要设计设计内容：主要系统框架、系统内外部接口内部接口：本平台各各子系统之间的接口，模块之间接口。外部接口：和其它系统的接口。网络部署：成果：“系统概要设计文档” a) 系统模块划分b) 系统架构系统架构图 9.2、系统详细设计成果：“系统详细设计文档”设计内容：类、接口、及方法描述数据库设计 十、参考资料 异常处理_百度百科 十一、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/各种中文乱码问题的解决","date":"2019-03-12T06:57:56.344Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/各种中文乱码问题的解决/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/各种中文乱码问题的解决/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.07.20 1.0 ZZ 初稿 三、概念解析–&gt; 凡是非二进制文件均有编码方式. –&gt; 本地环境简介: 计算机的系统编码:GBK,(cmd--chcp,936为GBK,1252为ANSI) 浏览器编码格式 : GBK TXT文件保存默认格式: ANSI Java的内核和class文件是基于unicode的 System.getProperty(&quot;file.encoding&quot;)--&gt;main()所在的类文件文件的保存编码(一般认为JVM的默认编码) JVM 默认为系统编码方式 –&gt; Java中编码方式的设置: java–&gt; encoding=”utf-8”； html–&gt;charset=utf-8 ,css–&gt; @charset “utf-8”； jsp–&gt;pageEncoding是jsp文件本身的编码 ontentType的charset是指服务器发送给客户端时的内容编码（转码后发送） URIEncoding=”utf-8”是连接编码格式。 –&gt; 常见字符集有：ASCII字符集、ISO-8859-1字符集(兼容ASCII) 、GB2312字符集(兼容ASCII) 、GBK字符集(兼容GB2312)、BIG5字符集、GB18030字符集(兼容GBK)、Unicode(兼容ISO-8859-1)字符集等。 –&gt; 产生乱码的两种原因: 文件存储 Java 把源文件 存储/编译成二进制文件,等到运行时再进行解码运行或显示. 文件传递 Java 文件传递的是二进制文件,故需要发送端把源文进行编码成二进制,然后接收端根据发送端的编码方式进行解码. –&gt; 解决思路: 本地设置的一般是文件的编码方式,接收端文件的编码方式不能对接收的文件进行解码,就会出现乱码 当解码方式不兼容编码方式时,便会显示乱码.(就像高版本word可以打开低版本,反之不行) 根据上述条件分析产生乱码的环节. MyEclipse –&gt; 控制台输入输出乱码 run as configurations –&gt; common –&gt;讲编码改为GBK –&gt; 文件输入输出乱码 MySql 数据库编码方式(设置成UTF-8后),cmd输出乱码 –&gt; CMD 显示输出乱码+————————–+——————————————-+| Variable_name | Value |+————————–+——————————————-+| character_set_client | gbk || character_set_connection | gbk || character_set_database | utf8 || character_set_results | gbk || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | D:\\MySQL\\MySQL Server 5.0\\share\\charsets\\ |+————————–+——————————————-+ 解 : cmd–set names gbk (本地系统编码格式为gbk)或者 cmd - chcp 65001设置cmd编码格式;(不建议,因为虚拟机也得跟着设置) –&gt; 以文件形式导出乱码 TomCat 服务端编码, 编码方式设置成UTF-8后,浏览器端乱码 –&gt; JSP 输出乱码 解: // 乱码原因: tomcat默认以ISO-8859-1的编码方式进行编码,JSP一般设置UTF-8 // method =&quot;post&quot; ,以from表单和 URL表头 的形式传输 request.setCharacterEncoding(&quot;UTF-8&quot;); // 设置接收请求(表单)的解码方式 response.setCharacterEncoding(&quot;UTF-8&quot;); // 设置响应(发送表单)的编码方式,可省,与 page: chatset=&quot;utf-8&quot;相同 String username = request.getParameter(&quot;username&quot;); // method =&quot;get&quot;,以 URL表头 的形式传输 // String username = request.getParameter(&quot;username&quot;); // TomCat默认以ISO-8895-1接收储存 // String un = new String(username.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); // 转码 // method =&quot;get&quot;或者 // conf 配置 --&gt; server.xml // &lt;Connector&gt; 语句中 添加 URIEncoding=&quot;utf-8&quot;针对get,提交路径参数中包含中文 // 注:修改配置后须重启服务 六、相关术语七、拓展阅读八、参考资料 常见乱码问题分析和总结 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC03 Web开发 & Web框架/JavaWeb中的相对路径和绝对路径","date":"2019-03-12T06:57:56.344Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/JavaWeb中的相对路径和绝对路径/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC03 Web开发 & Web框架/JavaWeb中的相对路径和绝对路径/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、基本概念 绝对路径：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径。 相对路径：相对与某个基准目录的路径。例如：”/“代表根目录，”./“ 或不写代表当前目录，”../“代表父级目录。 服务端的根目录：服务端的根目录是你的web应用的地址，即 http://192.168.0.1/webapp/。 客户端的的根目录：客户端的的根目录是服务器根目录，即 http://192.168.0.1/。 三、相对路径会遇到的一些情况 在服务端解析的文件路径会相对于服务端根目录。在客户端解析的文件路径会相对于客户端根目录。 javascript、jquery、html、css等在客户端解析，后台语言在服务器端解析，如php、asp、jsp等。 相对路径会因为服务端解析还是客户端解析而导致不同，因此建议使用绝对路径。 四、绝对路径的定义和使用 定义 - common_tag.jsp 1234567&lt;%// 相对路径, path = \"/SmartCity/\" 服务器才有根路径的概念String path = request.getContextPath()+\"/\";// 绝对路径, basePath=\"http://localhost:8080/SmartCity/\"String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path;%&gt;&lt;base href=\"&lt;%=basePath%&gt;\" &gt; 引用 - index.jsp 123456&lt;%@ include file=\"/WEB-INF/jsp/common/common_tag.jsp\"%&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;link href=\"static/styles/custom/style.css\" rel=\"stylesheet\"&gt; &lt;/head&gt;&lt;/html lang=\"en\"&gt; 或者 定义 - common_tag.jsp 1234&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!-- 相对路径, baseurl = \"/SmartCity/\" --&gt;&lt;c:set var=\"baseurl\" value=\"$&#123;pageContext.request.contextPath&#125;/\"&gt;&lt;/c:set&gt; 引用 - index.jsp 123456&lt;%@ include file=\"/WEB-INF/jsp/common/common_tag.jsp\"%&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;link href=\"$&#123;baseurl&#125;static/styles/custom/style.css\" rel=\"stylesheet\"&gt; &lt;/head&gt;&lt;/html lang=\"en\"&gt; 五、controller及配置文件中的路径 controller中的路径是根据SpringMVC中视图解析器的定义来决定的。 而SpringMVC等配置文件的地址一般相对于服务端的根目录或用classpath来定义。 六、结语 拦截器拦截与不拦截的区别，及客户端（浏览器）与服务端解析区别，有待后续完善。 七、参考文章 java中相对路径，绝对路径问题总结 JSP、Servlet中的相对路径和绝对路径 页面跳转问题 JSP之项目路径问题（${pageContext.request.contextPath},&lt;%=request.getContextPath()%&gt;以及绝对路径获取）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/模块化设计","date":"2019-03-12T06:57:56.332Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/模块化设计/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/模块化设计/","excerpt":"","text":"12345678910代码框架设计楼主认为框架设计的目的是：1. 将整个项目合理的拆分为许多模块，各个模块功能职责明确，降低各个模块的依赖，耦合；做到想用某一个模块时就用，不用时就去除掉，并且不影响其他模块2. 合理设计类与类之间的继承关系，接口的实现关系，和利用java的public、private、protected、default权限，来掩藏代码内部逻辑，争取做到只暴露外部开发接口，完全掩藏内部逻辑楼主认为：以功能为单位划分模块，无论功能大小均划分成模块，方便后期代码升级可以进行添加；模块设计准则：a.模块设计准则：在一个功能模块下，放于同一个package下，根据功能点为这个模块创建一个接口，创建两个功能管理类并实现前面的该接口，一个用于对外部模块开放接口，另一个用于控制模块内部逻辑。最后，在将模块内部真正实现的代码逻辑类全部设置为default权限，保证package以外的无法访问；如下图：模块设计b. 类与类的继承、接口实现；如果有多个相同的功能的代码块，都为其写一个基类，子类来继承即可；接口方面，如果多个类有相同的功能，但实现不一样则就用接口来实现","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/架构设计和技术选型","date":"2019-03-12T06:57:56.332Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/架构设计和技术选型/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/软件架构/架构设计和技术选型/","excerpt":"","text":"九、参考资料 架构设计和技术选型的思路总结","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/浅谈怎样写业务逻辑","date":"2019-03-12T06:57:56.332Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/浅谈怎样写业务逻辑/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/浅谈怎样写业务逻辑/","excerpt":"","text":"可以获取那些元素 需要实现那些功能 如何实现 需要判断那些逻辑","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/以快速迭代与敏捷开发应对客户不断变化的需求","date":"2019-03-12T06:57:56.328Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/以快速迭代与敏捷开发应对客户不断变化的需求/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/以快速迭代与敏捷开发应对客户不断变化的需求/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/术业有专攻 - 前后端工程师专注方向","date":"2019-03-12T06:57:56.328Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/术业有专攻 - 前后端工程师专注方向/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/术业有专攻 - 前后端工程师专注方向/","excerpt":"","text":"对于后端java工程师：把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。 对于前端工程师：把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/抽象，软件设计设计的灵魂","date":"2019-03-12T06:57:56.328Z","updated":"2018-12-31T08:15:32.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/抽象，软件设计设计的灵魂/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/抽象，软件设计设计的灵魂/","excerpt":"","text":"封装与映射（面向对象的设计思想）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向接口开发","date":"2019-03-12T06:57:56.316Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向接口开发/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向接口开发/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向对象编程SOLID原则","date":"2019-03-12T06:57:56.312Z","updated":"2018-12-31T08:15:49.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向对象编程SOLID原则/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程思想/面向对象编程SOLID原则/","excerpt":"","text":"[TOC] 一、前言SOLID 是面向对象设计和编程(OOD &amp; OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。 目的： 解耦、复用、易拓展 缩写 全称 说明 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 DIP The Dependency Inversion Principle 依赖倒置原则 ISP The Interface Segregation Principle 接口分离原则 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.22 1.0 ZZ 初稿 三、面向对象概述3.1、如何理解面向对象的编程思想3.11、定义对世界万物的状态与行为进行归纳与分类，以此分析个体与个体间的相互作用与影响方法。 3.12、一句话描述面向对象把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）／泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派 （dynamic dispatch）。 3.13、知乎关于这个问题的回答 面向对象：妈，我饿。面向过程：《生猪养殖技术》《大棚蔬菜栽培实用技术 》《家常菜谱大全》 编年体史书是面向过程的，纪传体史书是面向对象的。 把面向过程中功能的实现交给某个服务者就是面向对象了。 面向过程是自己做，面向对象是叫别人做。 面向过程，侧重于解决一个问题。面向对象，侧重于解决一类问题。 面向过程是，从上到下，逐行写函数来实现功能 面向对象是，封装函数实现的这个功能代码，想要使用的时候直接调用就可以 面向对象 是对 面向过程 的进一步抽象。 区别在于抽象层级高低。无非就是抽象的程度不一样罢了。把面向过程一般化模块化不关注不重要的细节那就是面向对象。实际上面向对象，到底层都是面向过程，面向对象底层还是面向过程。 面向过程优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 3.2、面向对象核心思想是抽象面向对象将程序的各个行为化为对象，而又用抽象的办法将这些对象归类（抽象），从而将错综复杂的事情简化为几个主要的有机组合。 3.21、抽象的两个原则 最少承诺原则：对象的接口只提供它的基本行为。 最少惊奇原则：抽象捕捉了某个对象的全部行为，不多也不少，并且不提供抽象之外的惊奇效果和副作用 3.22、评判抽象的品质 耦合：模块之间的关联强度应该是比较弱的，即低耦合。 内聚：模块内的各个元素的联系时紧密的，即高内聚。 充分性：类或模块应该记录某个抽象足够多的特征，从而允许有意义的、有效的交互。 完整性：类和模块的接口记录了它的全部特征。 基础性：只有访问该抽象的底层表现形式才能够有效的实现那些操作。 3.3、方法是分解和成组3.4、手段有封装、继承和多态四、面向对象三大基本原则4.1、封装变化点将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。 4.2、针对接口编程而不是实现编程这里“接口”的含义表示的程序设计语言中的interface ,或者abstract class。对接口编程的一个好处在于客户端程序并不需要了解具体的实现，而只需要了解接口中声明的方法。更大的好处在于能够使用多态性执行动态性的行为。 4.3、多使用组合而不是继承多使用组合，而不是继承。Has-a关系要比Is-a关系更好。因为继承是静态行为，也就是编译时行为。这种设计缺乏灵活度，并且具有比组合更高的耦合度。而组合是动态行为，即运行时行为。可以通过使用组合的方式在设计上获得更高的灵活性。 五、面向对象七大细则5.1、单一职责原则（Single Responsibility Principle）就一个类而言，应该仅有一个引起它变化的原因。通俗的说，即一个类只负责一项职责。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。同时，一个类承担过多职责，会加大代码编写、阅读以及维护的难度。 所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。 例如内存、CPU、硬盘责任单一。 5.2、里氏替换原则（Liskov Substitution Principle）里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。或者说子类必须能够替换掉他们的父类型。 只有当子类可以替换掉父类，软件功能不受影响的时候，父类才能真正被复用，而子类也能在父类的基础上增加新的行为．假如子类不做重写，那么它调用父类方法的时候其实就是多态的体现（向上转型）。 由于子类型的可替换性才使得父类类型的模块在无需修改的情况下就可以拓展，才使得开放－封闭原则成为了可能。 它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 5.3、依赖倒置原则（Dependence Inversion Principle）解耦最重要的原则就是依赖倒置：设计要依赖于抽象（接口或抽象类）而不是具体实现。针对接口编程，不针对实现编程。 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来描写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 尽量做到： 任何变量都不应该持有一个指向具体类的引用。 任何类都不应该从具体类派生。 任何方法都不应该覆写它的任何基类中的已经实现的方法。 《资本论》中都曾阐释依赖倒转原则 – 在商品经济的萌芽时期，出现了物物交换。假设你要买一个IPhone，卖IPhone的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的APP来换他一头猪，他说换猪可以，但是得用一条金项链来换 – 所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象 – 也就是货币 – 来进行交换，这样一来耦合度就大为降低了。 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性，面对接口（抽象）编程，是降低耦合，实现易拓展的必要条件。。 5.4、接口隔离原则（Interface Segregation Principle）提供尽可能小的单独接口，而不要提供大的总接口。不应该强迫客户依赖于它们不用的方法，会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。 如何实现接口隔离原则： 利用委托分离接口。 利用多继承分离接口 利用接口提供子类行为 ： 继承父类抽象行为，各自表述。针对接口编程，父类调用的是接口（中的方法）。方法与接口绑定，与具体类解耦。用if else 的地方就考虑是否可以用抽象、接口、泛型，由子类实现 5.5、迪米特法则（最少知道原则）（Law Of Demeter） 迪米特法则根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。 类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式。在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。 通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 5.6、开放 - 关闭原则（Open Close Principle）对拓展开放（通过接口，拓展功能），对修改关闭（封装到类）。 猜测最有可能发生变换的类，构造抽象来隔离变化。面对需求，程序是通过增加新的代码进行的，而不是更改现有的代码。在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。换言之，定义一个一劳永逸的抽象设计层，允许尽可能多的行为在实现层被实现。 5.7、组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再重新创建。新对象通过向这些对象的委派达到复用已有功能的。简而言之，要尽量使用合成/聚合，尽量不要使用继承。如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。 六、23种设计模式 详见 23种设计模式 七、拓展阅读面向过程、面向对象、面向资源、面向接口 八、参考资料 如何用一句话说明什么是面向对象思想？ 大话设计模式（一）设计模式遵循的七大原则九、结语 极限编程先写测试类，后写实现 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/责任链模式","date":"2019-03-12T06:57:56.304Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/责任链模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/责任链模式/","excerpt":"","text":"[TOC] 一、前言避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，这就是职责链模式。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.24 1.0 ZZ 初稿 三、责任链模式四、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/单例模式","date":"2019-03-12T06:57:56.296Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/单例模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/单例模式/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.24 1.0 ZZ 初稿 三、策略模式四、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/23种设计模式概述","date":"2019-03-12T06:57:56.296Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/23种设计模式概述/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/23种设计模式概述/","excerpt":"","text":"[TOC] 一、前言设计模式正是对面向对象设计原则的应用。从广义角度讲设计模式是可解决一类软件问题并能重复使用的设计方案。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.21 1.0 ZZ 初稿 三、正文3.1、创建型3.11、Factory Method（工厂方法）3.12、Abstract Factory（抽象工厂）3.13、Builder（建造者）3.14、Prototype（原型）3.15、Singleton（单例）3.2、结构型3.21、Adapter Class/Object（适配器）3.22、Bridge（桥接）3.23、Composite（组合）3.24、Decorator（装饰）3.25、Facade（外观）3.26、Flyweight（享元）3.27、Proxy（代理）3.3、行为型3.31、Interpreter（解释器）3.32、Template Method（模板方法）3.33、Chain of Responsibility（责任链）3.34、Command（命令）3.35、Iterator（迭代器）3.36、Mediator（中介者）3.37、Memento（备忘录）3.38、Observer（观察者）3.39、State（状态）3.310、Strategy（策略）3.311、Visitor（访问者）3.4、MVC 架构模型-视图-控制器 八、参考资料 图说设计模式 23种设计模式（概念、原则、场景、优点、缺点、应用）简述 设计模式在jdk中的应用 CNSD专栏 - 设计模式 CNSD专栏 - 设计模式 CNSD专栏 - 设计模式 CNSD专栏 - 设计模式 设计模式读书笔记文档 [x] 百度百科 - 反模式 [x] J2EE反模式 [x] Head.First.设计模式.中文版 设计模式_可复用面向对象软件的基础 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/策略模式","date":"2019-03-12T06:57:56.296Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/策略模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/策略模式/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.24 1.0 ZZ 初稿 三、策略模式策略模式是一种定义一系列算法的方法，所有这些算法完成的都是相同的工作（抽象策略类中的方法），只是实现不同（具体策略类），它可以以相同的方式调用所有算法（通过Context类实现），减少了各种算法类与使用算法类之间的耦合。 四、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/工厂模式","date":"2019-03-12T06:57:56.296Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/工厂模式/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/设计模式/工厂模式/","excerpt":"","text":"[TOC] 一、前言从设计模式的类型上来说简单工厂模式（Simple Factory）、抽象工厂模式(Abstract Factory)、工厂方法模式(Factory Method)同属创建型设计模式。但简单工厂模式不属于23种GOF设计模式之一。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.24 1.0 ZZ 初稿 三、简单工厂模式简单工厂模式又称之为静态工厂方法，属于创建型模式。在简单工厂模式中，可以根据传递的参数不同，返回不同类的实例。简单工厂模式定义了一个工厂类，这个类专门用于创建其他类的实例，这些被创建的类都有一个共同的抽象父类。 简单工厂模式将对象的创建和对象本身业务处理分离了，可以降低系统的耦合度。在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。 简单工厂模式的特点：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 UML类图 模式分析 Factory：工厂角色。专门用于创建实例类的工厂，提供一个方法，该方法根据传递的参数不同返回不同类的具体实例。 Product：抽象产品角色。为所有产品的父类。 ConcreteProduct：具体的产品角色。 代码实现 123456789101112131415161718192021package 简单工厂;/** * 工厂类 * @author zz * @date 下午5:28 18-4-24 */public class Factory &#123; public static AbstractProduct createProduct(String product) &#123; AbstractProduct pro = new ConcreteProductA(); switch (product) &#123; case \"ProductA\": pro = new ConcreteProductA(); break; case \"ProductB\": pro = new ConcreteProductB(); break; &#125; return pro; &#125;&#125; 12345678910package 简单工厂;/** * 抽象产品类 * @author zz * @date 下午5:27 18-4-24 */public interface AbstractProduct &#123; void createProduct();&#125; 12345678910111213package 简单工厂;/** * 具体产品类A * @author zz * @date 下午5:27 18-4-24 */public class ConcreteProductA implements AbstractProduct &#123; @Override public void createProduct() &#123; System.out.println(\"生产产品A\"); &#125;&#125; 12345678910111213package 简单工厂;/** * 具体产品类B * @author zz * @date 下午5:27 18-4-24 */public class ConcreteProductB implements AbstractProduct &#123; @Override public void createProduct() &#123; System.out.println(\"生产产品B\"); &#125;&#125; 12345678910111213package 简单工厂;/** * 测试类 * @author zz * @date 下午5:26 18-4-24 */public class Client &#123; public static void main(String[] args) &#123; AbstractProduct Product = Factory.createProduct(\"ProductA\"); Product.createProduct(); &#125;&#125; 四、工厂方法模式工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式让实例化推迟到子类。 UML类图 模式分析 AbstractFactory：抽象工厂。它实现了所有操纵产品的方法，但不实现工厂方法。AbstractFactory所有的子类都必须要实现factoryMethod()方法。 AbstractProduct：抽象产品。所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类可以引用这个接口。 ConcreteFactoryA：具体工厂。制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteFactory类知道如何创建这些产品。 ConcreteProductA：具体产品。 代码实现 12345678910package 工厂模式;/** * 抽象工厂生产抽象产品 * @author zz * @date 下午9:50 18-4-24 */public interface AbstractFactory &#123; AbstractProduct CreateProduct();&#125; 1234567891011121314151617181920212223242526272829package 工厂模式;/** * 抽象产品 * @author zz * @date 下午10:37 18-4-24 */public interface AbstractProduct &#123; public void step1(); public void step2(); public void step3();&#125;```javapackage 工厂模式;/** * 具体工厂A生产具体产品A * @author zz * @date 下午9:50 18-4-24 */public class ConcreteFactoryA implements AbstractFactory &#123; @Override public AbstractProduct CreateProduct() &#123; return new ConcreteProductA(); &#125;&#125; 12345678910111213package 工厂模式;/** * 具体工厂B生产具体产品B * @author zz * @date 下午9:50 18-4-24 */public class ConcreteFactoryB implements AbstractFactory &#123; @Override public AbstractProduct CreateProduct() &#123; return new ConcreteProductB(); &#125;&#125; 1234567891011121314151617181920212223package 工厂模式;/** * 具体产品A * @author zz * @date 下午9:49 18-4-24 */public class ConcreteProductA implements AbstractProduct &#123; @Override public void step1() &#123; System.out.println(\"添加咖啡粉\"); &#125; @Override public void step2() &#123; System.out.println(\"添加奶油\"); &#125; @Override public void step3() &#123; System.out.println(\"添加糖\"); &#125;&#125; 1234567891011121314151617181920212223package 工厂模式;/** * 具体产品B * @author zz * @date 下午10:37 18-4-24 */public class ConcreteProductB implements AbstractProduct &#123; @Override public void step1() &#123; System.out.println(\"添加咖啡粉\"); &#125; @Override public void step2() &#123; System.out.println(\"添加巧克力粉\"); &#125; @Override public void step3() &#123; System.out.println(\"添加水\"); &#125;&#125; 12345678910111213141516package 工厂模式;/** * 测试类 * @author zz * @date 下午9:48 18-4-24````````````````````````````````````````````````````````````````````````````````````````````` */public class Client &#123;````````````````````````````````````````````````````````````````````````````````````````````` public static void main(String[] args) &#123; AbstractFactory factory = new ConcreteFactoryA(); AbstractProduct Product = factory.CreateProduct(); Product.step1(); Product.step2(); Product.step3(); &#125;&#125; 五、抽象工厂模式在工厂方法模式中，我们使用一个工厂创建一个产品，也就是说一个具体的工厂对应一个具体的产品。但是有时候我们需要一个工厂能够提供多个产品对象，而不是单一的对象，这个时候我们就需要使用抽象工厂模式。 在讲解抽象工厂模式之前，我们需要厘清两个概念： 产品等级结构。产品的等级结构也就是产品的继承结构。例如一个为空调的抽象类，它有海尔空调、格力空调、美的空调等一系列的子类，那么这个抽象类空调和他的子类就构成了一个产品等级结构。 产品族。产品族是在抽象工厂模式中的。在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如，海尔工厂生产海尔空调。海尔冰箱，那么海尔空调则位于空调产品族中。 UML类图 模式分析 AbstractFactory：抽象工厂。抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含了一组方法用来生产产品。 ConcreteFactory：具体工厂。具体工厂是用于生产不同产品族。要创建一个产品，客户只需要使用其中一个工厂完全不需要实例化任何产品对象。 AbstractProduct：抽象产品。这是一个产品家族，每一个具体工厂都能够生产一整组产品。 ConcreteProduct：具体产品。 代码实现 1234567891011package 抽象工厂;/** * 抽象工厂类，可以生产产品组产品 * @author zz * @date 下午2:31 18-4-25 */public interface AbstractFactory &#123; AbstractProductA createProductA(); AbstractProductB createProductB();&#125; 123456789101112package 抽象工厂;/** * 抽象产品类A * @author zz * @date 下午2:26 18-4-25 */public interface AbstractProductA &#123; void step1(); void step2();&#125; 1234567891011package 抽象工厂;/** * 抽象产品类B * @author zz * @date 下午2:26 18-4-25 */public interface AbstractProductB &#123; void materialA(); void materialB();&#125; 123456789101112131415161718package 抽象工厂;/** * 具体工厂A * @author zz * @date 下午3:14 18-4-25 */public class ConcreteFactoryA implements AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductAFromFactoryA(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductBFromFactoryA(); &#125;&#125; 123456789101112131415161718package 抽象工厂;/** * 具体工厂类B * @author zz * @date 下午2:26 18-4-25 */public class ConcreteFactoryB implements AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductAFromFactoryB(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductBFromFactoryB(); &#125;&#125; 123456789101112131415161718package 抽象工厂;/** * 具体产品类A，来自工厂A * @author zz * @date 下午2:29 18-4-25 */public class ConcreteProductAFromFactoryA implements AbstractProductA &#123; @Override public void step1() &#123; System.out.println(\"ProducAtStep1FromFactoryA\"); &#125; @Override public void step2() &#123; System.out.println(\"ProductAStep2FromFactoryA\"); &#125;&#125; 123456789101112131415161718package 抽象工厂;/** * 具体产品类B，来自工厂B * @author zz * @date 下午2:28 18-4-25 */public class ConcreteProductAFromFactoryB implements AbstractProductA &#123; @Override public void step1() &#123; System.out.println(\"ProductAStep1FromFactoryB\"); &#125; @Override public void step2() &#123; System.out.println(\"ProductAStep2FromFactoryB\"); &#125;&#125; 123456789101112131415161718package 抽象工厂;/** * 具体产品类B，来自工厂A * @author zz * @date 下午3:15 18-4-25 */public class ConcreteProductBFromFactoryA implements AbstractProductB &#123; @Override public void materialA() &#123; System.out.println(\"materialAFromFactoryA\"); &#125; @Override public void materialB() &#123; System.out.println(\"materialBFactoryA\"); &#125;&#125; 123456789101112131415161718package 抽象工厂;/** * 具体产品类B，来自工厂B * @author zz * @date 下午3:13 18-4-25 */public class ConcreteProductBFromFactoryB implements AbstractProductB &#123; @Override public void materialA() &#123; System.out.println(\"materialAFromFactoryB\"); &#125; @Override public void materialB() &#123; System.out.println(\"materialBFromFactoryB\"); &#125;&#125; 六、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/UML 模型","date":"2019-03-12T06:57:56.292Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/UML 模型/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/UML 模型/","excerpt":"","text":"[TOC] 一、前言Java的类之间的关系有泛化、依赖、关联、聚合、组合、实现。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.04.21 1.0 ZZ 初稿 三、概念解析 车的类图结构为&lt;&gt;，表示车是一个抽象类；它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；学生与班级之间是聚合关系，使用带空心箭头的实线表示；学生与身份证之间为关联关系，使用一根实线表示；学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 泛化关系(Generalization) 也就是继承关系，也称为“is-a-kind-of”关系。在UML中，泛 化关系用带空心三角形的直线来表示。依赖关系(Dependency) 是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。而这种使用关系是具有偶然性的、临时性的、非常弱的。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。关联关系(Association) 是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。关联有两元关系和多元关系。在UML类图中，用实线连接有关联的对象所对应的类。如老师与学生。聚合关系(Aggregation) 表示一个整体与部分的关系。在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。如轮胎与汽车。组合关系(Composition) 也表示类之间整体和部分的关系，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在UML中，组合关系用带实心菱形的直线表示。如公司与部门。接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所 声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。 耦合强弱关系：依赖 &lt; 关联 &lt; 聚合 &lt; 组合&lt;泛化（继承）。关于关联，聚合，组合在实现上并没有显著区别，相区别他们只有通过判断关系双方之间的实际关系，如关系强弱、创建与销毁之间有无必要关联等。实现方式区别：依赖关系：关系对象出现在局部变量或方法的参数里，或关系类的静态方法被调用。关联关系：关系对象出现在实例变量中聚合关系：关系对象出现在实例变量中合成关系：关系对象出现在实例变量中 三、UML 模型分类3.1、类图3.1、时序图3.1、用例图八、参考资料九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/JavaWeb 项目目录规范","date":"2019-03-12T06:57:56.276Z","updated":"2018-12-18T06:28:51.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/JavaWeb 项目目录规范/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/JavaWeb 项目目录规范/","excerpt":"","text":"[TOC] 一、前言本文介绍基于Maven的前后端分离模式的JavaWeb项目目录规范，用于项目的规范化创建参考。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.09.13 1.0 ZZ 初稿 三、项目结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283lapland├── lapland-Service-1 // 模块一，服务端模块│ ├── doc // 导出文件及模板文件，文档，sql备份│ ├── src│ │ ├── main│ │ │ ├── java│ │ │ │ └── com│ │ │ │ └── lapland│ │ │ │ ├── common // 公共类│ │ │ │ ├── core // 核心类│ │ │ │ │ ├── aop│ │ │ │ │ ├── converter│ │ │ │ │ ├── filter│ │ │ │ │ ├── interceptor│ │ │ │ │ ├── listener│ │ │ │ │ ├── mq│ │ │ │ │ ├── redis│ │ │ │ │ ├── response│ │ │ │ │ ├── shiro│ │ │ │ │ ├── swagger│ │ │ │ │ └── validation│ │ │ │ ├── etl // 业务类│ │ │ │ │ ├── controller│ │ │ │ │ ├── dao│ │ │ │ │ ├── pojo│ │ │ │ │ │ └── vo│ │ │ │ │ ├── quartz│ │ │ │ │ ├── service│ │ │ │ │ │ └── impl│ │ │ │ │ └── utils│ │ │ │ └── web│ │ │ │ ├── dao│ │ │ │ ├── pojo│ │ │ │ ├── service│ │ │ │ │ └── impl│ │ │ │ └── utils│ │ │ └── resources // 资源文件│ │ │ ├── config.properties│ │ │ ├── jdbc.properties│ │ │ ├── log4j.properties│ │ │ ├── mappers // Mapper文件│ │ │ │ ├── etl│ │ │ │ └── web│ │ │ ├── spring│ │ │ │ ├── spring-context-database.xml│ │ │ │ ├── spring-context-quartz.xml│ │ │ │ ├── spring-context.xml│ │ │ │ └── spring-mvc.xml│ │ │ └── lib // 外部包│ │ └── test│ │ └── java│ │ ├── ETLtest.java│ │ └── javaConnSSQL.java│ ├── target // 编译文件目录│ ├── webapp // Web应用部署根目录│ │ └── WEB-INF│ │ └── web.xml│ ├── lapland-Service-1.iml│ └── pom.xml├── lapland-Service-2 // 模块二，服务端模块│ ├── lapland-Service-2.iml│ └── pom.xml├── lapland-Web // 模块三，前端静态页面│ ├── json│ ├── resources│ │ ├── audio│ │ ├── images│ │ │ ├── common│ │ │ ├── error│ │ │ ├── index│ │ │ └── login│ │ └── video│ ├── style│ │ ├── common│ │ ├── css│ │ └── js│ ├── views│ │ ├── error│ │ ├── etl│ │ ├── manage│ │ └── project│ └── lapland-Web.iml└── README.md 说明：下划线表示一个单词：ChengDu_Cuturl_Relic中划线表示上下层次：ChengDu-Web、ChengDu-Service 八、参考资料 异常处理_百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/Java代码生成UML","date":"2019-03-12T06:57:56.276Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/Java代码生成UML/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/UML/Java代码生成UML/","excerpt":"","text":"StarUML逆向工程: 通过代码生成类图 [x] 从Java代码直接生成UML [x] intellij idea 高级用法之：集成JIRA、UML类图插件、集成SSH、集成FTP、Database管理.","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/Java编程风格与命名规范","date":"2019-03-12T06:57:56.264Z","updated":"2018-12-18T06:40:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/Java编程风格与命名规范/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/Java编程风格与命名规范/","excerpt":"","text":"[TOC] Java命名规范 Java开发命名规范总结 版权声明：公司内部资料，禁止外传。 一、前言来自《The Elements of Java Style》-《Java编程风格》一书，值得一读的书籍，会让你在细节上节省很多时间，合作之间更加愉快！好处不多说了，但是有几个原则如下： 保持原有风格 坚持最小惊奇原则 第一次就做对 记录所有非规范行为 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.06 1.0 ZZ 初稿 三、格式规范 缩进嵌套的代码 在每个代码块和嵌套中加入缩进，缩进代码，加强可读性。这些地方包括(类定义，内部类定义，方法定义，静态块，for循环语句，if-else语句，try、catch和finally块，匿名内部类，while语句，do-while语句)。把每个块语句开始的大括弧“{”放置在块语句所在行最后字符的后面。将块结束的大括弧“}”放置在块后另起一行的第一个字符处。 断开很长的句子 如果包含了逗号，那么在每一个逗号后面都另起一行，把逗号后面的每一个表达式都和逗号前面的表达式的第一个字母对齐。应该在优先级最低的运算符之前断行。 使用空白 关键字和其后左括号之间，右括号和紧随其后的关键字，除了”.”之外的运算符与其前后的表达式之间用空格隔开。每个逻辑上独立的方法和代码段之间，定义类或者接口的成员之间，每个类和接口之间应该加入空白行。 不要直接使用Tab控制符不同环境对Tab控制符的解释也是不同的。应配置编辑器将TAB字符替换成空格符 不要直接使用Tab控制符 不同环境对Tab控制符的解释也是不同的。应配置编辑器将TAB字符替换成空格符 四、命名约定 名称应该具有实际意义,临时变量除外 使用人们熟悉的名称 谨慎使用过长的名字，可以使用简明通用的缩写 尽量保留元音字母 缩写词的第一个字母大写 不要使用大小写来区分的名字 4.1、包命名 用你所在组织的域名的倒序小写形式作为包的根限定词 使用单独的小写词作为每个包的根名 仅当新旧版本二进制兼容的时候，其包可以使用相同的名字，否则，请使用新名字 4.2、类型命名 类和接口名中的每个单词的第一个字母大写 不能为关键字 4.3、类命名 用名词命名类 具有成组相关属性，静态服务或者常量的类名字使用复数形式 4.3、接口命名 用名词或者形容词命名接口 4.5、方法命名 方法名中的第一个单词小写，其后每个单词的第一个字母大写 用动词命名方法 遵循JavaBean中命名属性访问函数方法：set，get，is 4.6、变量命名 变量命中的第一个单词小写，其后的每个单词的第一个字母大写 用名词命名变量 集合引用名要用复数形式 为不重要的临时变量简历并使用一套标准名字 4.7、字段命名 使用this字段变量可以区分开局部变量 4.8、参数命名 构造函数或者”set”方法给字段分配参数赋值，参数名应该和字段名相同 4.9、常量命名 常量的每个单词均大写，单词之间使用下划线连接 五、文档约定 为使用和维护你的代码的人编写文档 注释和代码要同步 使用积极的语气，省略无用的词语 5.1、注释类型 用文档注释来描述编程接口 用标准注释格式隐藏代码而不必删除它们 用单行注释解释实现细节 5.2、文档注释 在编写代码前描述编程接口 为公用，受保护，包，私有成员建立文档 为每个包编写总结和概述 为包的每个应用程序或组编写概述 5.3、注释风格 对所有文档注释使用统一的格式和组织结构 关键字，标识符和常量应放到…标签中 将代码放入…标签中 在标识符第一次出现的时候用{@link}标签 为Javadoc标签简历并使用一套固定的顺序 使用第三人称叙述的形式 编写独立的概述 省略概述中动作和服务的主语 省略事物概述中的对象和动词 使用this而不是the来指代当前类中的实例 方法名或者构造函数名不需圆括号，除非你想突出一个特殊的签名 5.4、注释内容 每个类、接口、字段和方法都编写概述（Controller、Service（Impl）、Mapper、POJO） 完整描述每个方法的签名 包含示例 为前置、后置、不变条件编写文档 为已知的缺陷和不足编写文档 为同步语法编写文档 5.5、内部注释 仅添加有助于理解你的代码的内部注释 描写代码为什么这样做，而不是在做什么 避免使用行尾注释 用行尾注释解释局部变量声明 建立并使用一套关键词来标识尚未解决的问题 在嵌套程度高的控制结构中标记出嵌套结束位置 如果两个case标记之间没有break语句，就在中间加入“fall-through”注释 标记空语句 六、编程约定 将表示基础数据类型的类声明为final类型 通过本地类型和其他具体类型建立具体类型 定义小的类和小的方法 定义子类，以便任何使用超类的地方都可以使用子类 使所有字段私有 使用多态来替代instanceof 6.1、类型安全 以java.lang.Object包装通用类，提供静态类型检查 以类的形式封装枚举类型 尽量使用泛型 6.2、语句和表达式 用等价的方法替换重复的、复杂的表达式 使用块语句代替控制流结构的表达式 使用括号明确操作顺序 在switch语句中的最后一个case体使用break语句 使用equals()，而不是==来检测对象的对等关系 6.3、构造 构造状态有效的对象 不要从构造函数中调用非final方法 用嵌套的构造函数消除冗余代码 6.4、异常处理 使用不受检查、运行时的异常来报告可能在程序逻辑中出错的严重未查明错误 使用检查异常来报告可能发生，而在正常的程序运行时极少发生的错误 用返回代码报告可预知的状态改变 仅转化异常来添加信息 不要私自处置运行时或者错误异常 用finally语句块释放资源 6.5、断言 按照约定编程 用无用代码消除机制实现断言 用断言捕捉代码中的逻辑错误 用断言检测方法的前置条件和后置条件 6.6、并发 仅在适当的地方使用线程 6.7、同步 避免同步 用同步的包装器，提供同步接口 如果方法包含几个不需要同步的重要操作，那么不要同步整个方法 读写实例变量的时候避免不必要的同步 使用notify()而不是notifyAll() 为同步初始化使用双重检查模式 6.8、效率 使用懒惰初始化 避免创建不必要的对象 重新初始化并重新使用对象，尽量不要新建对象 把优化工作放到最后 七、包约定 将经常使用、更改、同时发布或者互相依存的类型，放在同一个包里 共同封闭原则 重用/发布等价原则 无环依赖原则 将不稳定的类和接口隔离在单独的包中 易于修改的包不要依赖于难以修改的包 最大化抽象最大化稳定性 将高层设计和架构作为稳定的抽象，组织为稳定的包 八、拓展阅读九、参考资料 Java命名规范 Java开发命名规范总结 十、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] Java开发手册","date":"2019-03-12T06:57:56.264Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] Java开发手册/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] Java开发手册/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] JSON语法及JSON定义规范化","date":"2019-03-12T06:57:56.252Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] JSON语法及JSON定义规范化/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC02 编程思想 & 设计模式 & 架构/编程风格及命名规范/[已发布] JSON语法及JSON定义规范化/","excerpt":"","text":"[TOC] 一、前言JSON(JavaScript Object Notation, JS对象标记) 是一种轻量级的数据交换格式。它是基于 ECMAScript 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、JSON 语法规则在 JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型： 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。JSON 和 JS 对象可以互转。 JS 对象 –&gt; JSON 字符串，使用 JSON.stringify() 方法 12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);==&gt; json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' JSON 字符串 –&gt; JS 对象，使用 JSON.parse() 方法 12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');==&gt; obj = &#123;a: 'Hello', b: 'World'&#125; 三、和XML的比较3.1、实例比较 用XML表示中国部分省市数据如下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;province&gt; &lt;name&gt;黑龙江&lt;/name&gt; &lt;cities&gt; &lt;city&gt;哈尔滨&lt;/city&gt; &lt;city&gt;大庆&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;cities&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;珠海&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;台湾&lt;/name&gt; &lt;cities&gt; &lt;city&gt;台北&lt;/city&gt; &lt;city&gt;高雄&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;新疆&lt;/name&gt; &lt;cities&gt; &lt;city&gt;乌鲁木齐&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt;&lt;/country&gt; 用JSON表示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; \"name\": \"中国\", \"province\": [ &#123; \"name\": \"黑龙江\", \"cities\": &#123; \"city\": [ \"哈尔滨\", \"大庆\" ] &#125; &#125;, &#123; \"name\": \"广东\", \"cities\": &#123; \"city\": [ \"广州\", \"深圳\", \"珠海\" ] &#125; &#125;, &#123; \"name\": \"台湾\", \"cities\": &#123; \"city\": [ \"台北\", \"高雄\" ] &#125; &#125;, &#123; \"name\": \"新疆\", \"cities\": &#123; \"city\": [ \"乌鲁木齐\" ] &#125; &#125; ]&#125; 可以看到，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。 四、标准JSON格式定义虽然在JSON并没有特殊的格式要求，但是在实践过程中，JSON有比较认可的格式规范： JSON格式的定义一般遵循如下规范： 123456&#123; \"status\": // 接口访问成功或者失败的状态码 \"message\": // 接口访问错误返回的错误提示，访问成功返回空字符 \"data\":&#123; // 服务端实际返回的数据 &#125;&#125; 请求接口失败的例子 1234&#123; \"status\": \"1\", \"message\": \"您尚未登录,请登录后继续操作\"&#125; 请求接口成功的例子 123456789101112131415161718&#123; \"status\": \"0\", \"message\": \"\", \"data\": &#123; \"userId\": \"1\", \"username\": \"zhangsan\", \"worklist\": [ &#123; \"workId\": \"1\", \"workname\": \"完成登陆界面设计\" &#125;, &#123; \"workId\": \"2\", \"workname\": \"完成用户中心功能编码\" &#125; ] &#125;&#125; 五、JSON 工具 格式化工具 JSON-XML互转 六、参考资料 JSON_百度百科","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/算法习题","date":"2019-03-12T06:57:56.252Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/算法习题/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/算法习题/","excerpt":"","text":"算法习题1.练习：对两个变量的数据进行互换。 int a = 3,b = 5;–&gt;b = 3,a = 5;方法一： a = a + b; a = 8;//可能会超出int范围 b = a - b; b = 3; a = a - b; a = 5;方法二： a = a ^ b;// b = a ^ b;// b = a ^ b ^ b = a a = a ^ b;// a = a ^ b ^ a = b;方法三： temp = a； a=b; b=temp;2.练习：高效的算出 2*8 = 2&lt;&lt;3;3.死循环方法一： for(;;) {System.out.println(“这是测试”);}方法二： While(ture) {}4.for 循环一例for (int x = 0, y = 9;x&lt;3;x++,y++) {System.out.println(“这是测试”);}","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java多线程并发编程/Java多线程并发编程","date":"2019-03-12T06:57:56.248Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java多线程并发编程/Java多线程并发编程/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java多线程并发编程/Java多线程并发编程/","excerpt":"","text":"开多线程增加了并发数，提高资源了的利用率。 多线程有什么用？ java多线程并发","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/小知识点/平台目录结构说明","date":"2019-03-12T06:57:56.248Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/小知识点/平台目录结构说明/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/小知识点/平台目录结构说明/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990│├─main│ │ │ ├─java│ │ ││ │ └─cn.jeeweb----------------平台主代码│ │ ││ │ ├─core----------------平台核心模块存放目录│ │ │ ││ │ │ ├─common----------------项目公用的部分(例如基础controller、dao、service、以及动态SQL/HQL实现)│ │ │ ││ │ │ ├─disruptor-------------并发框架的实现(短信发送模块、邮件发送模块)│ │ │ ││ │ │ ├─filter、interceptor---安全过滤器、其他一些公用拦截器│ │ │ ││ │ │ ├─mapper----------------各种Object到Xml、Object到Json的映射转换类│ │ │ ││ │ │ ├─model-----------------前段暂时的各种JSON实体│ │ │ ││ │ │ ├─quartz----------------quartz定时任务实现│ │ │ ││ │ │ ├─query-----------------前端请求，后端自动组装、以及分页的查询模块│ │ │ ││ │ │ ├─repository------------持久层相关类│ │ │ ││ │ │ ├─security--------------安全相关类│ │ │ ││ │ │ ├─tag-------------------GRID标签、form标签、html组件加载标签等│ │ │ ││ │ │ └─utils-----------------一些工具类│ │ │ │ │ └─modules----------------内置功能模块（按照业务模块分类）│ │ ││ │ ├─charts----------------图表模块│ │ ││ │ └─sys-------------------权限模块│ │ ││ │ ├─controller---控制层│ │ ││ │ ├─entity-------实体层│ │ ││ │ ├─service------服务层│ │ ││ │ ├─security-----安全相关│ │ ││ │ ├─tags----------------标签│ │ ││ │ └─utils-----------------一些工具类│ │ │ ││ ├─resources----------------平台资源文件│ │ ││ │ ├─ehcache----------------缓存配置目录（ehcache.xml缓存配置文件）│ │ │ │ │ ├─i18n-------------------国际化信息所在的文件名文件目录（messages.properties项目国际化、ValidationMessages.propertieshibernate validator验证）│ │ │ │ │ ├─mapper-----------------一些映射（特别tag/html/中的文件，为html组件加载包）│ │ │ │ │ ├─statement--------------动态SQL/HQL(是更灵活的操作SQL/HQL)│ │ │ │ │ ├─codegen.properties-----代码生成配置│ │ │ │ │ ├─dbconfig.properties----数据库配置│ │ │ │ │ ├─jeeweb.properties------项目的一些配置│ │ │ │ │ ├─shiro.properties-------shiro配置│ │ │ │ │ ├─shiro.properties-------代码生成器的模板文件，以及其他模板存放目录│ │ │ │ │ ├─*.properties----------（其他配置，可以查看配置的前缀，对应具体业务的配置,如何:sms.properties短信、email.properties邮件配置）│ │ │ │ │ └─spring-*.xml-----------Spring相关文件│ ││ └─webapp----------------web页面和静态资源存放的目录│ ││ └─WEB-INF│ ││ ├─static----------------静态资源目录│ │ ││ │ ├─ace----------------ace样式JS,CSS文件│ │ ├─vendors----------------第三方的JS，css,按照第三方包名单独保存│ │ ├─common-----------------系统的公用JS.CSS文件│ │ └─modules----------------功能模块CSS,以及JS,按照模板名单独存放│ ││ └─webpage----------------视图文件目录│ ││ ├─decorators-------------视图装饰目录│ ├─error------------------系统异常映射相关页面│ └─modules----------------内置核心功能模块视图相关文件（按照模板名单独存放）","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/[未发布]计算机编程语言","date":"2019-03-12T06:57:56.248Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/[未发布]计算机编程语言/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/数据结构与算法 & 编译原理/[未发布]计算机编程语言/","excerpt":"","text":"[TOC] 一、前言计算机语言通常是一个能完整、准确和规则地表达人们的意图,并用以指挥或控制计算机工作的“符号系统”。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、计算机语言的分类2.1、机器语言机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。这种指令集，称机器码（machine code），是电脑的CPU可直接解读的数据。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。机器语言具有直接执行和速度快等特点。 不同型号的计算机其机器语言是不相通的，按着一种计算机的机器指令编制的程序，不能在另一种计算机上执行。 用机器语言编写程序,编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时,程序员得自己处理每条指令和每一数据的存储分配和输入输出,还得记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作。 2.2、汇编语言（Assembly Languages）为了克服机器语言难读、难编、难记和易出错的缺点,人们就用与代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码,于是就产生了汇编语言。所以说,汇编语言是一种用助记符表示的仍然面向机器的计算机语言。汇编语言亦称符号语言。 汇编语言中由于使用了助记符号,用汇编语言编制的程序送入计算机,计算机不能象用机器语言编写的程序一样直接识别和执行,必须通过预先放入计算机的“汇编程序“的加工和翻译,才能变成能够被计算机识别和处理的二进制代码程序。 用汇编语言等非机器语言书写好的符号程序称源程序,运行时汇编程序要将源程序翻译成目标程序。目标程序是机器语言程序,它一经被安置在内存的预定位置上,就能被计算机的CPU处理和执行。 汇编语言像机器指令一样,是硬件操作的控制信息,因而仍然是面向机器的低级语言。但是,汇编语言用来编制系统软件和过程控制软件,其目标程序占用内存空间少,运行速度快,有着高级语言不可替代的用途。 2.3、高级语言不论是机器语言还是汇编语言都是面向硬件的具体操作的，语言对机器的过分依赖，要求使用者必须对硬件结构及其工作原理都十分熟悉。 随着计算机事业的发展,促使人们去寻求一些与人类自然语言相接近且能为计算机所接受的语意确定、规则明确、自然直观和通用易学的计算机语言。这种与自然语言相近并为计算机所接受和执行的计算机语言称高级语言。高级语言是面向用户的语言。 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。 翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。编译型语言（Compiling Languages），如C/C++、JAVA。写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了，因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。依赖编译器，跨平台性差些。 解释则不同，解释型语言（Interpreted Languages）的程序不需要编译。运行时，由其所对应的解释器（或称虚拟机）解释执行。每执行一次翻译一次，效率比较低。依赖解释器，跨平台性好。 Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是虚拟机编译成为字节码，运行时以解释方式在虚拟机中执行字节码。 2.31、脚本语言脚本语言是一种解释性的语言,例如Python、VBScript、JavaScript、PHP、JSP、 Ruby、CSS、HTML等,它不象C/C++等可以编译成二进制代码,以可执行文件的形式存在，脚本语言不需要编译，可以直接用，由解释器来负责解释。 作为批次处理语言或工作控制语言。许多脚本语言用来执行一次性任务，尤其是系统管理方面。DOS，Windows的批处理文件和Unix的shell脚本都属于这种应用。 为通用的编程语言存在，如Perl、Python、Ruby等。由于“解释执行，内存管理，动态”等特性，它们仍被称为脚本语言。但它们已经用于应用程序编写，用户也不把它们看作脚本语言。 网页中的嵌入式脚本语言。熟知的HTML(Hyper Text Mark-up Language)即超文本标记语言，就是一种脚本语言，它的解释器就是浏览器。JavaScript直到现在仍然是网页浏览器内的主要编程语言，它的ECMAScript标准化保证了它成为流行的通用嵌入式脚本语言。另外，随着动态网页技术发展，ASP、JSP、PHP等嵌入网页的脚本语言正被广泛使用，不过这些脚本要通过Web Server解释,而Html则被浏览器执行。 三、参考资料 百度百科 - 脚本语言 程序的编译与解释有什么区别？ Java 是编译型语言还是解释型语言？","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/JVM 简介","date":"2019-03-12T06:57:56.236Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/JVM 简介/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/JVM 简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/从Java.lang.NoClassDefFoundError看JVM的类的加载机制","date":"2019-03-12T06:57:56.236Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/从Java.lang.NoClassDefFoundError看JVM的类的加载机制/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JVM虚拟机/从Java.lang.NoClassDefFoundError看JVM的类的加载机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/过滤器 & 拦截器 & 监听器的配置和应用","date":"2019-03-12T06:57:56.232Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/过滤器 & 拦截器 & 监听器的配置和应用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/过滤器 & 拦截器 & 监听器的配置和应用/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 二、基本概念 过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。 拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。 监听器（Listener）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。 三、四、五、参考资料六、结语","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java元注解","date":"2019-03-12T06:57:56.220Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java元注解/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java元注解/","excerpt":"","text":"[x] Java元注解和注解的解析 [x] Java内置系统注解和元注解","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Tomcat类加载机制","date":"2019-03-12T06:57:56.216Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Tomcat类加载机制/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Tomcat类加载机制/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 加载顺序： $java_home/lib 目录下的java核心api $java_home/lib/ext 目录下的java扩展jar包 java -classpath/-Djava.class.path所指的目录下的类与jar包 $CATALINA_HOME/common目录下按照文件夹的顺序从上往下依次加载 $CATALINA_HOME/server目录下按照文件夹的顺序从上往下依次加载 $CATALINA_BASE/shared目录下按照文件夹的顺序从上往下依次加载 我们的项目路径/WEB-INF/classes下的class文件 我们的项目路径/WEB-INF/lib下的jar文件 在同一个文件夹下，jar包是按顺序从上到下依次加载 由ClassLoader的双亲委托模式加载机制我们可以知道，假设两个包名和类名完全相同的class文件不再同一个jar包，如果一个class文件已经被加载java虚拟机里了，那么后面的相同的class文件就不会被加载了。 五、结语六、参考资料","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java 非空判断","date":"2019-03-12T06:57:56.216Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java 非空判断/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java 非空判断/","excerpt":"","text":"那些地方要做非空判断 关于java方法里的非空判断的疑问，谢谢","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/软件设计概念解析","date":"2019-03-12T06:57:56.216Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/软件设计概念解析/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/软件设计概念解析/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2017.05.08 1.0 ZZ 初稿 三、基础概念3.1、SDK (Software Development Kit)即软件开发工具包，它是软件厂商为软件的开发者提供的一个工具包。包括集成封装的类库（library）、API、相关文档、范例和工具的集合等。 3.2、JDK (Java Development Kit)即Java开发工具包，它是Sun公司为Java开发者提供的一个工具包。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。包括了Java运行环境、Java工具和Java基础类库等。 3.3、JRE (Java RuntimeEnvironment)即Java运行环境。所有的Java程序都要在JRE下才能运行。 3.4、JVM (Java VirtualMachine）即Java虚拟机，它是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。 3.5、API (Application Program Interface)即应用程序接口。它是一组定义、程序及协议的集合，通过 API 接口实现计算机软件之间的相互通信。API的一个主要功能是提供通用功能集。程序员通过调用 API函数对应用程序进行开发，可以减轻编程任务。 API同时也是一种中间件，为各种不同平台提供数据共享。 3.6、IDE (Integrated Development Environm)即集成开发环境。它是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。常用的IDE有Eclipse、IntelliJ IDEA、Android studio、Visual Studio、DreamWeaver、WebStorm、Aptana Studio。 3.7、ADT (Android Development tools)即Android开发工具，它是Eclipse的插件，在Eclipse和SDK之间起了一个桥梁的作用。 3.8、什么是 开发环境、测试环境、生产环境、UAT环境、仿真环境开发环境(DEV)：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。 测试环境(UAT)：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。 生产环境(PROD)：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。可以理解为包含所有的功能的环境，任何项目所使用的环境都以这个为基础，然后根据客户的个性化需求来做调整或者修改。 三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。 UAT环境：UAT，(User Acceptance Test),用户接受度测试 即验收测试，所以UAT环境主要是用来作为客户体验的环境。 仿真环境：顾名思义是和真正使用的环境一样的环境（即已经出售给客户的系统所在环境，也成为商用环境），所有的配置，页面展示等都应该和商家正在使用的一样，差别只在环境的性能方面。 如何保证测试环境与真实生产的一致性 3.9、SDK与API的区别 在概念上，SDK是一系列文件的组合，包括lib、dll、.h、文档、示例等等；API是对程序而言的，提供用户编程时的接口，即一系列模块化的类和函数。可以认为API是包含在SDK中的。 3.10、系统架构,技术架构,应用架构、业务架构,功能架构的区别 题目中给出的几种，都是大家平常口头说的，比较模糊，没有统一的规范、标准。不同的架构方法论，会将架构分为不同视图，每个视图侧重某一个方面、领域的问题。 目前国际上运用比较广泛的是TOGAF架构体系，他把架构分为业务架构、数据架构、应用架构、技术架构等几个方面。 系统架构（业务、功能架构） 指的完整系统的组成架构，例如系统分成几个部分？服务平台、管理门户、终端门户、ATM门户、外部系统以及接口、支撑系统等，将这些系统进行合理的划分。然后再进行功能分类细分，例如服务平台内部划分为系统管理、用户管理、帐号管理、支付管理、接口层、统计分析等逻辑功能。总之，将整个系统业务分解为逻辑功能模块，并且科学合理，就是系统架构了。 技术架构（技术选型，技术实现） 从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。 应用架构 应用功能的划分、应用功能集成和应用功能部署。如何支持灵活扩展、大并发量、安全性等，需要画出物理网络部署图。按照应用进行划分的话，还需要考虑是否支持分布式SOA。 网络架构（网络拓扑结构） 3.11、什么是RPC？ RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 3.12、CPU的核心数和CPU的线程数CPU的核心数即CPU芯片个数，线程数是一种逻辑的概念，简单地说，就是模拟出的CPU核心数。 开多线程增加了并发数，提高资源了的利用率。 核心数相当于大脑数量，线程数相当于一个大脑能同时处理多少件事情（左手画方，右手画圆）。 3.13、PO/POJO/VO/BO/DAO/DTO PO(persistant object) 持久对象 在o/r 映射的时候出现的概念,如果没有o/r映射,就没有这个概念存在了.通常对应数据模型(数据库),本身还有部分业务逻辑的处理.可以看成是与数据库中的表相映射的java对象.最简单的PO就是对应数据库中某个表中的一条记录,多个记录可以用PO的集合.PO中应该不包含任何对数据库的操作. VO(value object) 值对象 通常用于业务层之间的数据传递,和PO一样也是仅仅包含数据而已.但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递. BO(business object) 业务对象 从业务模型的角度看,见UML元件领域模型中的领域对象.封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作. POJO(plain ordinary java object) 简单无规则java对象 传统意义的java对象.就是说在一些Object/Relation Mapping工具中,能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象,没有增加别的属性和方法.我的理解就是最基本的Java Bean,只有属性字段及setter和getter方法!. DAO(data access object) 数据访问对象 是sun的一个标准j2ee设计模式,这个模式中有个接口就是DAO,它负责持久层的操作.为业务层提供接口.此对象用于访问数据库.通常和PO结合使用,DAO中包含了各种数据库的操作方法.通过它的方法,结合PO对数据库进行相关的操作.夹在业务逻辑与数据库资源中间.配合VO, 提供数据库的CRUD操作… DTO (Data Transfer Object)数据传输对象 主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO O/R Mapper 对象/关系 映射 定义好所有的mapping之后,这个O/R Mapper可以帮我们做很多的工作.通过这些mappings,这个O/R Mapper可以生成所有的关于对象保存,删除,读取的SQL语句,我们不再需要写那么多行的DAL代码了.实体Model(实体模式) [x] 浅析VO、DTO、DO、PO的概念、区别和用处 五、其他概念 5.1、 side effects 函数调用是一个表达式，返回值是其主要作用。而除了返回值之外，我们需要函数做的任务都叫做副作用。虽然，有时这个“副作用”才是我们的本来目的。 Side effect–what’s this? 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java乱码问题总结","date":"2019-03-12T06:57:56.212Z","updated":"2018-12-11T05:02:06.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java乱码问题总结/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java乱码问题总结/","excerpt":"","text":"[TOC] 一、前言二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.02.07 1.0 ZZ 初稿 三、为什么要编码版权声明：公司内部资料，禁止外传。 不知道大家有没有想过一个问题，那就是为什么要编码？我们能不能不编码？要回答这个问题必须要回到计算机是如何表示我们人类能够理解的符号的，这些符号也就是我们人类使用的语言。由于人类的语言有太多，因而表示这些语言的符号太多，无法用计算机中一个基本的存储单元—— byte 来表示，因而必须要经过拆分或一些翻译工作，才能让计算机能理解。我们可以把计算机能够理解的语言假定为英语，其它语言要能够在计算机中使用必须经过一次翻译，把它翻译成英语。这个翻译的过程就是编码。所以可以想象只要不是说英语的国家要能够使用计算机就必须要经过编码。这看起来有些霸道，但是这就是现状，这也和我们国家现在在大力推广汉语一样，希望其它国家都会说汉语，以后其它的语言都翻译成汉语，我们可以把计算机中存储信息的最小单位改成汉字，这样我们就不存在编码问题了。所以总的来说，编码的原因可以总结为： 计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个 人类要表示的符号太多，无法用一个字节来完全表示 要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码 3.1、如何“翻译”明白了各种语言需要交流，经过翻译是必要的，那又如何来翻译呢？计算中提拱了多种翻译方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。它们都可以被看作为字典，它们规定了转化的规则，按照这个规则就可以让计算机正确的表示我们的字符。目前的编码格式很多，例如 GB2312、GBK、UTF-8、UTF-16 这几种格式都可以表示一个汉字，那我们到底选择哪种编码格式来存储汉字呢？这就要考虑到其它因素了，是存储空间重要还是编码的效率重要。根据这些因素来正确选择编码格式，下面简要介绍一下这几种编码格式。 ASCII 码 学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。 ISO-8859-1 128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。 GB2312 它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。 GBK 全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。 GB18030 全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。 UTF-16 说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。 UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8 UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。 UTF-8 有以下编码规则： 如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。 如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。 如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 四、Java 中需要编码的场景前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。 4.1、I/O 操作中存在的编码我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口： Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示： 同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。如下面一段代码，实现了文件的读写功能： 清单 1.I/O 涉及的编码示例 12345678910111213141516171819202122232425String file = &quot;c:/stream.txt&quot;; String charset = &quot;UTF-8&quot;; // 写字符换转成字节流FileOutputStream outputStream = new FileOutputStream(file); OutputStreamWriter writer = new OutputStreamWriter( outputStream, charset); try &#123; writer.write(&quot;这是要保存的中文字符&quot;); &#125; finally &#123; writer.close(); &#125; // 读取字节转换成字符FileInputStream inputStream = new FileInputStream(file); InputStreamReader reader = new InputStreamReader( inputStream, charset); StringBuffer buffer = new StringBuffer(); char[] buf = new char[64]; int count = 0; try &#123; while ((count = reader.read(buf)) != -1) &#123; buffer.append(buffer, 0, count); &#125; &#125; finally &#123; reader.close(); &#125; 在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。 4.2、内存中操作中的编码在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例： String s = “这是一段中文字符串”; 12byte[] b = s.getBytes(&quot;UTF-8&quot;); String n = new String(b,&quot;UTF-8&quot;); 另外一个是已经被被废弃的 ByteToCharConverter 和 CharToByteConverter 类，它们分别提供了 convertAll 方法可以实现 byte[] 和 char[] 的互转。如下代码所示： 1234ByteToCharConverter charConverter = ByteToCharConverter.getConverter(&quot;UTF-8&quot;); char c[] = charConverter.convertAll(byteArray); CharToByteConverter byteConverter = CharToByteConverter.getConverter(&quot;UTF-8&quot;); byte[] b = byteConverter.convertAll(c); 这两个类已经被 Charset 类取代，Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示： 123Charset charset = Charset.forName(&quot;UTF-8&quot;); ByteBuffer byteBuffer = charset.encode(string); CharBuffer charBuffer = charset.decode(byteBuffer); 编码与解码都在一个类中完成，通过 forName 设置编解码字符集，这样更容易统一编码格式，比 ByteToCharConverter 和 CharToByteConverter 类更方便。 Java 中还有一个 ByteBuffer 类，它提供一种 char 和 byte 之间的软转换，它们之间转换不需要编码与解码，只是把一个 16bit 的 char 格式，拆分成为 2 个 8bit 的 byte 表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。如下代码所以： 12ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024); ByteBuffer byteBuffer = heapByteBuffer.putChar(c); 以上这些提供字符和字节之间的相互转换只要我们设置编解码格式统一一般都不会出现问题。 五、Java 中如何编解码前面介绍了几种常见的编码格式，这里将以实际例子介绍 Java 中如何实现编码及解码，下面我们以“I am 君山”这个字符串为例介绍 Java 中如何把它以 ISO-8859-1、GB2312、GBK、UTF-16、UTF-8 编码格式进行编码的。 清单 2.String 编码 123456789101112131415161718public static void encode() &#123; String name = &quot;I am 君山&quot;; toHex(name.toCharArray()); try &#123; byte[] iso8859 = name.getBytes(&quot;ISO-8859-1&quot;); toHex(iso8859); byte[] gb2312 = name.getBytes(&quot;GB2312&quot;); toHex(gb2312); byte[] gbk = name.getBytes(&quot;GBK&quot;); toHex(gbk); byte[] utf16 = name.getBytes(&quot;UTF-16&quot;); toHex(utf16); byte[] utf8 = name.getBytes(&quot;UTF-8&quot;); toHex(utf8); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; 我们把 name 字符串按照前面说的几种编码格式进行编码转化成 byte 数组，然后以 16 进制输出，我们先看一下 Java 是如何进行编码的。下面是 Java 中编码需要用到的类图 图 1. Java 编码类图 首先根据指定的 charsetName 通过 Charset.forName(charsetName) 设置 Charset 类，然后根据 Charset 创建 CharsetEncoder 对象，再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面是 String. getBytes(charsetName) 编码过程的时序图 图 2.Java 编码时序图 从上图可以看出根据 charsetName 找到 Charset 类，然后根据这个字符集编码生成 CharsetEncoder，这个类是所有字符编码的父类，针对不同的字符编码集在其子类中定义了如何实现编码，有了 CharsetEncoder 对象后就可以调用 encode 方法去实现编码了。这个是 String.getBytes 编码方法，其它的如 StreamEncoder 中也是类似的方式。下面看看不同的字符集是如何将前面的字符串编码成 byte 数组的？如字符串“I am 君山”的 char 数组为 49 20 61 6d 20 541b 5c71，下面把它按照不同的编码格式转化成相应的字节。 按照 ISO-8859-1 编码 字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果： 从上图看出 7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 这个编码导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题，后面将会分析不同的乱码形式是怎么出现的。 按照 GB2312 编码 字符串“I am 君山”用 GB2312 编码，下面是编码结果： GB2312 对应的 Charset 是 sun.nio.cs.ext. EUC_CN 而对应的 CharsetDecoder 编码类是 sun.nio.cs.ext. DoubleByte，GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。查表的规则如下：1c2b[c2bIndex[char &gt;&gt; 8] + (char &amp; 0xff)] 如果查到的码位值大于 oxff 则是双字节，否则是单字节。双字节高 8 位作为第一个字节，低 8 位作为第二个字节，如下代码所示： 12345678910if (bb &gt; 0xff) &#123; // DoubleByte if (dl - dp &lt; 2) return CoderResult.OVERFLOW; da[dp++] = (byte) (bb &gt;&gt; 8); da[dp++] = (byte) bb; &#125; else &#123; // SingleByte if (dl - dp &lt; 1) return CoderResult.OVERFLOW; da[dp++] = (byte) bb; &#125; 从上图可以看出前 5 个字符经过编码后仍然是 5 个字节，而汉字被编码成双字节，在第一节中介绍到 GB2312 只支持 6763 个汉字，所以并不是所有汉字都能够用 GB2312 编码。 按照 GBK 编码 字符串“I am 君山”用 GBK 编码，下面是编码结果： 你可能已经发现上图与 GB2312 编码的结果是一样的，没错 GBK 与 GB2312 编码结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。 按照 UTF-16 编码字符串“I am 君山”用 UTF-16 编码，下面是编码结果： 用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值，UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。 按照 UTF-8 编码 字符串“I am 君山”用 UTF-8 编码，下面是编码结果： UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。它的编码规则如下： 清单 3.UTF-8 编码代码片段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private CoderResult encodeArrayLoop(CharBuffer src, ByteBuffer dst)&#123; char[] sa = src.array(); int sp = src.arrayOffset() + src.position(); int sl = src.arrayOffset() + src.limit(); byte[] da = dst.array(); int dp = dst.arrayOffset() + dst.position(); int dl = dst.arrayOffset() + dst.limit(); int dlASCII = dp + Math.min(sl - sp, dl - dp); // ASCII only loop while (dp &lt; dlASCII &amp;&amp; sa[sp] &lt; &apos;\\u0080&apos;) da[dp++] = (byte) sa[sp++]; while (sp &lt; sl) &#123; char c = sa[sp]; if (c &lt; 0x80) &#123; // Have at most seven bits if (dp &gt;= dl) return overflow(src, sp, dst, dp); da[dp++] = (byte)c; &#125; else if (c &lt; 0x800) &#123; // 2 bytes, 11 bits if (dl - dp &lt; 2) return overflow(src, sp, dst, dp); da[dp++] = (byte)(0xc0 | (c &gt;&gt; 6)); da[dp++] = (byte)(0x80 | (c &amp; 0x3f)); &#125; else if (Character.isSurrogate(c)) &#123; // Have a surrogate pair if (sgp == null) sgp = new Surrogate.Parser(); int uc = sgp.parse(c, sa, sp, sl); if (uc &lt; 0) &#123; updatePositions(src, sp, dst, dp); return sgp.error(); &#125; if (dl - dp &lt; 4) return overflow(src, sp, dst, dp); da[dp++] = (byte)(0xf0 | ((uc &gt;&gt; 18))); da[dp++] = (byte)(0x80 | ((uc &gt;&gt; 12) &amp; 0x3f)); da[dp++] = (byte)(0x80 | ((uc &gt;&gt; 6) &amp; 0x3f)); da[dp++] = (byte)(0x80 | (uc &amp; 0x3f)); sp++; // 2 chars &#125; else &#123; // 3 bytes, 16 bits if (dl - dp &lt; 3) return overflow(src, sp, dst, dp); da[dp++] = (byte)(0xe0 | ((c &gt;&gt; 12))); da[dp++] = (byte)(0x80 | ((c &gt;&gt; 6) &amp; 0x3f)); da[dp++] = (byte)(0x80 | (c &amp; 0x3f)); &#125; sp++; &#125; updatePositions(src, sp, dst, dp); return CoderResult.UNDERFLOW; &#125; UTF-8 编码与 GBK 和 GB2312 不同，不用查码表，所以在编码效率上 UTF-8 的效率会更好，所以在存储中文字符时 UTF-8 编码比较理想。 几种编码格式的比较 对中文字符后面四种编码格式都能处理，GB2312 与 GBK 编码规则类似，但是 GBK 范围更大，它能处理所有汉字字符，所以 GB2312 与 GBK 比较应该选择 GBK。UTF-16 与 UTF-8 都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，想比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。 六、Java Web 涉及到的编码对于使用中文来说，有 I/O 的地方就会涉及到编码，前面已经提到了 I/O 操作会引起编码，而大部分 I/O 引起的乱码都是网络 I/O，因为现在几乎所有的应用程序都涉及到网络操作，而数据经过网络传输都是以字节为单位的，所以所有的数据都必须能够被序列化为字节。在 Java 中数据被序列化必须继承 Serializable 接口。 这里有一个问题，你是否认真考虑过一段文本它的实际大小应该怎么计算，我曾经碰到过一个问题：就是要想办法压缩 Cookie 大小，减少网络传输量，当时有选择不同的压缩算法，发现压缩后字符数是减少了，但是并没有减少字节数。所谓的压缩只是将多个单字节字符通过编码转变成一个多字节字符。减少的是 String.length()，而并没有减少最终的字节数。例如将“ab”两个字符通过某种编码转变成一个奇怪的字符，虽然字符数从两个变成一个，但是如果采用 UTF-8 编码这个奇怪的字符最后经过编码可能又会变成三个或更多的字节。同样的道理比如整型数字 1234567 如果当成字符来存储，采用 UTF-8 来编码占用 7 个 byte，采用 UTF-16 编码将会占用 14 个 byte，但是把它当成 int 型数字来存储只需要 4 个 byte 来存储。所以看一段文本的大小，看字符本身的长度是没有意义的，即使是一样的字符采用不同的编码最终存储的大小也会不同，所以从字符到字节一定要看编码类型。另外一个问题，你是否考虑过，当我们在电脑中某个文本编辑器里输入某个汉字时，它到底是怎么表示的？我们知道，计算机里所有的信息都是以 01 表示的，那么一个汉字，它到底是多少个 0 和 1 呢？我们能够看到的汉字都是以字符形式出现的，例如在 Java 中“淘宝”两个字符，它在计算机中的数值 10 进制是 28120 和 23453，16 进制是 6bd8 和 5d9d，也就是这两个字符是由这两个数字唯一表示的。Java 中一个 char 是 16 个 bit 相当于两个字节，所以两个汉字用 char 表示在内存中占用相当于四个字节的空间。这两个问题搞清楚后，我们看一下 Java Web 中那些地方可能会存在编码转换？ 用户从浏览器端发起一个 HTTP 请求，需要存在编码的地方是 URL、Cookie、Parameter。服务器端接受到 HTTP 请求后要解析 HTTP 协议，其中 URI、Cookie 和 POST 表单参数需要解码，服务器端可能还需要读取数据库中的数据，本地或网络中其它地方的文本文件，这些数据都可能存在编码问题，当 Servlet 处理完所有请求的数据后，需要将这些数据再编码通过 Socket 发送到用户请求的浏览器里，再经过浏览器解码成为文本。这些过程如下图所示： 图 3. 一次 HTTP 请求的编码示例 如上图所示一次 HTTP 请求设计到很多地方需要编解码，它们编解码的规则是什么？下面将会重点阐述一下：URL 的编解码用户提交一个 URL，这个 URL 中可能存在中文，因此需要编码，如何对这个 URL 进行编码？根据什么规则来编码？有如何来解码？如下图一个 URL： 图 4.URL 的几个组成部分 上图中以 Tomcat 作为 Servlet Engine 为例，它们分别对应到下面这些配置文件中：Port 对应在 Tomcat 的 中配置，而 Context Path 在 中配置，Servlet Path 在 Web 应用的 web.xml 中的 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;junshanExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlets/servlet/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 中配置，PathInfo 是我们请求的具体的 Servlet，QueryString 是要传递的参数，注意这里是在浏览器里直接输入 URL 所以是通过 Get 方法请求的，如果是 POST 方法请求的话，QueryString 将通过表单方式提交到服务器端，这个将在后面再介绍。上图中 PathInfo 和 QueryString 出现了中文，当我们在浏览器中直接输入这个 URL 时，在浏览器端和服务端会如何编码和解析这个 URL 呢？为了验证浏览器是怎么编码 URL 的我们选择 FireFox 浏览器并通过 HTTPFox 插件观察我们请求的 URL 的实际的内容，以下是 URL：HTTP://localhost:8080/examples/servlets/servlet/ 君山 ?author= 君山在中文 FireFox3.6.12 的测试结果 图 5. HTTPFox 的测试结果 君山的编码结果分别是：e5 90 9b e5 b1 b1，be fd c9 bd，查阅上一届的编码可知，PathInfo 是 UTF-8 编码而 QueryString 是经过 GBK 编码，至于为什么会有“%”？查阅 URL 的编码规范 RFC3986 可知浏览器编码 URL 是将非 ASCII 字符按照某种编码格式编码成 16 进制数字然后将每个 16 进制表示的字节前加上“%”，所以最终的 URL 就成了上图的格式了。默认情况下中文 IE 最终的编码结果也是一样的，不过 IE 浏览器可以修改 URL 的编码格式在选项 -&gt; 高级 -&gt; 国际里面的发送 UTF-8 URL 选项可以取消。从上面测试结果可知浏览器对 PathInfo 和 QueryString 的编码是不一样的，不同浏览器对 PathInfo 也可能不一样，这就对服务器的解码造成很大的困难，下面我们以 Tomcat 为例看一下，Tomcat 接受到这个 URL 是如何解码的。解析请求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，这个方法把传过来的 URL 的 byte[] 设置到 org.apache.coyote.Request 的相应的属性中。这里的 URL 仍然是 byte 格式，转成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的： 12345678910111213141516171819202122232425262728293031protected void convertURI(MessageBytes uri, Request request) throws Exception &#123; ByteChunk bc = uri.getByteChunk(); int length = bc.getLength(); CharChunk cc = uri.getCharChunk(); cc.allocate(length, -1); String enc = connector.getURIEncoding(); if (enc != null) &#123; B2CConverter conv = request.getURIConverter(); try &#123; if (conv == null) &#123; conv = new B2CConverter(enc); request.setURIConverter(conv); &#125; &#125; catch (IOException e) &#123;...&#125; if (conv != null) &#123; try &#123; conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd()); uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength()); return; &#125; catch (IOException e) &#123;...&#125; &#125; &#125; // Default encoding: fast conversion byte[] bbuf = bc.getBuffer(); char[] cbuf = cc.getBuffer(); int start = bc.getStart(); for (int i = 0; i &lt; length; i++) &#123; cbuf[i] = (char) (bbuf[i + start] &amp; 0xff); &#125; uri.setChars(cbuf, 0, length); &#125; 从上面的代码中可以知道对 URL 的 URI 部分进行解码的字符集是在 connector 的 中定义的，如果没有定义，那么将以默认编码 ISO-8859-1 解析。所以如果有中文 URL 时最好把 URIEncoding 设置成 UTF-8 编码。QueryString 又如何解析？ GET 方式 HTTP 请求的 QueryString 与 POST 方式 HTTP 请求的表单参数都是作为 Parameters 保存，都是通过 request.getParameter 获取参数值。对它们的解码是在 request.getParameter 方法第一次被调用时进行的。request.getParameter 方法被调用时将会调用 org.apache.catalina.connector.Request 的 parseParameters 方法。这个方法将会对 GET 和 POST 方式传递的参数进行解码，但是它们的解码字符集有可能不一样。POST 表单的解码将在后面介绍，QueryString 的解码字符集是在哪定义的呢？它本身是通过 HTTP 的 Header 传到服务端的，并且也在 URL 中，是否和 URI 的解码字符集一样呢？从前面浏览器对 PathInfo 和 QueryString 的编码采取不同的编码格式不同可以猜测到解码字符集肯定也不会是一致的。的确是这样 QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 中的 useBodyEncodingForURI 设置为 true。这个配置项的名字有点让人产生混淆，它并不是对整个 URI 都采用 BodyEncoding 进行解码而仅仅是对 QueryString 使用 BodyEncoding 解码，这一点还要特别注意。从上面的 URL 编码和解码过程来看，比较复杂，而且编码和解码并不是我们在应用程序中能完全控制的，所以在我们的应用程序中应该尽量避免在 URL 中使用非 ASCII 字符，不然很可能会碰到乱码问题，当然在我们的服务器端最好设置 中的 URIEncoding 和 useBodyEncodingForURI 两个参数。 6.2、HTTP Header 的编解码当客户端发起一个 HTTP 请求除了上面的 URL 外还可能会在 Header 中传递其它参数如 Cookie、redirectPath 等，这些用户设置的值很可能也会存在编码问题，Tomcat 对它们又是怎么解码的呢？对 Header 中的项进行解码也是在调用 request.getHeader 是进行的，如果请求的 Header 项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASCII 字符解码肯定会有乱码。 我们在添加 Header 时也是同样的道理，不要在 Header 中传递非 ASCII 字符，如果一定要传递的话，我们可以先将这些字符用 org.apache.catalina.util.URLEncoder 编码然后再添加到 Header 中，这样在浏览器到服务器的传递过程中就不会丢失信息了，如果我们要访问这些项时再按照相应的字符集解码就好了。 6.3、POST 表单的编解码在前面提到了 POST 表单提交的参数的解码是在第一次调用 request.getParameter 发生的，POST 表单参数传递方式与 QueryString 不同，它是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端，在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置。另外针对 multipart/form-data 类型的参数，也就是上传的文件编码同样也是使用 ContentType 定义的字符集编码，值得注意的地方是上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及到字符编码，而真正编码是在将文件内容添加到 parameters 中，如果用这个编码不能编码时将会用默认编码 ISO-8859-1 来编码。 6.4、HTTP BODY 的编解码当用户请求的资源已经成功获取后，这些内容将通过 Response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端，浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。 6.5、其它需要编码的地方除了 URL 和参数编码问题外，在服务端还有很多地方可能存在编码，如可能需要读取 xml、velocity 模版引擎、JSP 或者从数据库读取数据等。 xml 文件可以通过设置头来制定编码格式 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; Velocity 模版设置编码格式： 1services.VelocityService.input.encoding=UTF-8 JSP 设置编码格式： 1&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;%&gt; 访问数据库都是通过客户端 JDBC 驱动来完成，用 JDBC 来存取数据要和数据的内置编码保持一致，可以通过设置 JDBC URL 来制定如 1MySQL：url=&quot;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK&quot;。 七、常见问题分析在了解了 Java Web 中可能需要编码的地方后，下面看一下，当我们碰到一些乱码时，应该怎么处理这些问题？出现乱码问题唯一的原因都是在 char 到 byte 或 byte 到 char 转换中编码和解码的字符集不一致导致的，由于往往一次操作涉及到多次编解码，所以出现乱码时很难查找到底是哪个环节出现了问题，下面就几种常见的现象进行分析。中文变成了看不懂的字符例如，字符串“淘！我喜欢！”变成了“? ? ? ?? ? ???? ? ?”编码过程如下图所示 字符串在解码时所用的字符集与编码字符集不一致导致汉字变成了看不懂的乱码，而且是一个汉字字符变成两个乱码字符。一个汉字变成一个问号例如，字符串“淘！我喜欢！”变成了“？？？？？？”编码过程如下图所示 将中文和中文符号经过不支持中文的 ISO-8859-1 编码后，所有字符变成了“？”，这是因为用 ISO-8859-1 进行编解码时遇到不在码值范围内的字符时统一用 3f 表示，这也就是通常所说的“黑洞”，所有 ISO-8859-1 不认识的字符都变成了“？”。一个汉字变成两个问号例如，字符串“淘！我喜欢！”变成了“？？？？？？？？？？？？”编码过程如下图所示 这种情况比较复杂，中文经过多次编码，但是其中有一次编码或者解码不对仍然会出现中文字符变成“？”现象，出现这种情况要仔细查看中间的编码环节，找出出现编码错误的地方。一种不正常的正确编码还有一种情况是在我们通过 request.getParameter 获取参数值时，当我们直接调用String value = request.getParameter(name);会出现乱码，但是如果用下面的方式String value = String(request.getParameter(name).getBytes(“ISO-8859-1”), “GBK”);解析时取得的 value 会是正确的汉字字符，这种情况是怎么造成的呢？看下如所示： 这种情况是这样的，ISO-8859-1 字符集的编码范围是 0000-00FF，正好和一个字节的编码范围相对应。这种特性保证了使用 ISO-8859-1 进行编码和解码可以保持编码数值“不变”。虽然中文字符在经过网络传输时，被错误地“拆”成了两个欧洲字符，但由于输出时也是用 ISO-8859-1，结果被“拆”开的中文字的两半又被合并在一起，从而又刚好组成了一个正确的汉字。虽然最终能取得正确的汉字，但是还是不建议用这种不正常的方式取得参数值，因为这中间增加了一次额外的编码与解码，这种情况出现乱码时因为 Tomcat 的配置文件中 useBodyEncodingForURI 配置项没有设置为”true”，从而造成第一次解析式用 ISO-8859-1 来解析才造成乱码的。 八、参考资料 异常处理_百度百科 九、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/JAVA与JS常用字符串操作","date":"2019-03-12T06:57:56.212Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JAVA与JS常用字符串操作/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/JAVA与JS常用字符串操作/","excerpt":"","text":"[TOC] 一、前言本文介绍了在JavaScript和Java常用的字符串操作及转换方法，以作备忘，方便查询。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.01.04 1.0 ZZ 初稿 三、概念解析3.1、JS对象1234var employee = &#123; firstName: \"Bill\", lastName : \"Gates\"&#125; 3.2、JS数组1234567var employees = [&#123; firstName: \"Bill\", lastName : \"Gates\"&#125;, &#123; firstName: \"George\", lastName : \"Bush\"&#125;]; 3.1、Java对象 Java中创建的对象。 1略略略 3.1、JSON对象 JSON 对象在花括号中书写，对象可以包含多个名称/值对。 1234&#123; \"firstname\": \"John\", \"lastname\": \"Doe\",&#125; 3.1、JSON数组 JSON 数组在方括号中书写，数组可包含多个对象。 123456789101112&#123; \"employees\": [ &#123; \"firstName\": \"John\", \"lastName\": \"Doe\" &#125;, &#123; \"firstName\": \"Anna\", \"lastName\": \"Smith\" &#125; ]&#125; 3.1、JSON字符串 JS或Java对象的字符串表示法。 1var a = '&#123;firstname:\"John\",lastname:\"Doe\"&#125;'; 四、JS字符串操作4.1、JS截取字符串，去掉前几位1234var str=\"abc12345\";var a = str.substr(3);var a = str.substr(3,b.length());==&gt; a = \"12345\" 123var str=\"abc12345\";var a = str.slice(3);==&gt; a = \"12345\" 4.2、JS截取字符串，取前几位123var str =\"abc12345\";var a = str.substr(0,3); ==&gt; a = \"abc\" 4.3、JS以特殊符号拆分字符串1234str=\"Bill,Georg,Gates,Bush\"; strArray=str.split(\",\"); var a = strArray[0];==&gt; a = \"Georg\" 4.4、字符串类 –&gt; Number类型123str=\"10086\";var a = parseInt(str);==&gt; a = 10086 4.5、JS 对象 –&gt; JSON 字符串，使用 JSON.stringify()方法12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;); ==&gt; json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' 4.6、JSON 字符串 –&gt; JS 对象，使用 JSON.parse()方法12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');==&gt; obj = &#123;a: 'Hello', b: 'World'&#125; 五、Java字符串操作5.1、提取下标区间字段123String s1 = \"abc12345\";String s2 = s1.substring(1,5);==&gt; s2 = \"bc123\" 5.2、字符串拆分,用数组接收1234String s1 = \"abc+12345\";String[] strArray = s5.split(\"+ |，|？\"); // 正则String s2 = strArray[0];==&gt; s2 = \"abc\" 5.3、连接字符串12345String s1 = \"abc\";String s2 = \"+\";String s3 = \"12345\";String s5 = s1.concat(s2.concat(s3));==&gt; s2 = \"abc+12345\" 5.4、字符串类型 –&gt; int类型12int num = Integer.parseInt(\"10086\");==&gt; num = \"10086\" 5.5、Java 对象 –&gt; JSON 字符串，FastJSON12345User user = new User();user.setId(1);user.setName(\"admin\");String json = JSON.toJSONString(user);==&gt; json = '&#123;\"id\": \"1\", \"name\": \"admin\"&#125;' 5.6、JSON 字符串 –&gt; Java 对象，FastJSON1234String json = '&#123;\"id\": \"1\", \"name\": \"admin\"&#125;';User user = JSON.parseObject(jsonString, User.class);String name = user.name;==&gt; name = \"admin\"; 六、拓展阅读 JSON语法及JSON定义规范化 七、参考资料 FastJSON 使用方法 八、结语 未完待续","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java开发常用Util工具类-StringUtil、CollectionUtil等","date":"2019-03-12T06:57:56.200Z","updated":"2019-01-25T01:26:54.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java开发常用Util工具类-StringUtil、CollectionUtil等/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java开发常用Util工具类-StringUtil、CollectionUtil等/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用Jenkins 搭建自动化 CI/CD 流水线。以实现软件服务的快速迭代。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2019.01.25 1.0 ZZ 初稿 三、字符串工具类3.1、占位四、集合工具类四、数据类型转换类四、JSON工具类四、时间操作工具类 在java的程序里date类型怎么比较大小 四、Properties文件操作工具类八、参考资料 Java开发常用Util工具类-StringUtil、CastUtil、CollectionUtil、ArrayUtil、PropsUtil 九、结语 文章仅作为个人学习总结之用，水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java反射机制及其项目应用","date":"2019-03-12T06:57:56.200Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java反射机制及其项目应用/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java反射机制及其项目应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/Java回调函数举例","date":"2019-03-12T06:57:56.184Z","updated":"2019-02-26T17:27:13.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java回调函数举例/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/Java回调函数举例/","excerpt":"","text":"回调函数的本质是异步地由被调用者主动调用调用者，实现通知一类的操作。 角色 :老板Boss 员工Employee 回调接口 CallBack Boss实现CallBack接口 场景 :老板让员工去工作，工作完成后向老板汇报 解决方案:老板持有员工对象,老板让员工去工作时传入Boss的引用,即调用CallBack接口,员工使用CallBack完成回调 定义回调函数 123456789package top.lapland.callback.asyn.callback;/** * 回调接口 * 约定工作完成后的联系方式 */public interface CallBack &#123; public void execute(String result);&#125; 定义员工类 123456789101112131415package top.lapland.callback.asyn.entity;import top.lapland.callback.asyn.callback.CallBack;/** * 员工类 */public class Employee &#123; // 员工含有接收老板引用的方法 public void doWork(String work,CallBack callBack) &#123; // 工作了一段时间 Thread.sleep(10000l); // 通知老板说工作完成了 callBack.execute(work+\"已经做完!!\"); &#125;&#125; 定义老板类 123456789101112131415161718192021package top.lapland.callback.asyn.entity;import top.lapland.callback.asyn.callback.CallBack;/** * 老板类 */public class Boss implements CallBack&#123; // 安排工作 public arrange(String work) &#123; new Employee.doWork(work, this); &#125; /** * 回调函数 * 实现具体的联系方式 */ @Override public void execute(String result) &#123; System.out.println(result); &#125;&#125; 测试方法 12345678910111213141516package top.lapland.callback.asyn.client;import top.lapland.callback.asyn.entity.Boss;import top.lapland.callback.asyn.entity.Employee;/** * * 异步回调函数测试 */public class AsynClient &#123; public static void main(String[] args) &#123; // Boss持有emp Boss boss = new Boss(); // boss让emp去工作 然后向boss报告 boss.execute(\"xx任务.\"); &#125;&#125; java回调函数-异步回调-简明讲解 Java中关于回调函数的使用 java回调函数","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC01 程序设计基础/过滤器，拦截器，监听器的区别","date":"2019-03-12T06:57:56.172Z","updated":"2018-12-20T14:20:23.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC01 程序设计基础/过滤器，拦截器，监听器的区别/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC01 程序设计基础/过滤器，拦截器，监听器的区别/","excerpt":"","text":"[TOC] 一、前言本文主要讲述如何使用Jenkins 搭建自动化 CI/CD 流水线。以实现软件服务的快速迭代。 测试环境：JDK1.8 + Maven 3.5.1 + Tomcat 7 + IDEA。 二、版本 编号 修改日期 版本号 修改人 修改说明 1 2018.12.20 1.0 ZZ 初稿 三、概念解析过滤器：用于属性甄别，对象收集（不可改变过滤对象的属性和行为）监听器：用于对象监听，行为记录（不可改变监听对象的属性和行为）拦截器：用于对象拦截，行为干预（可以改变拦截对象的属性和行为） 过滤器：对象收集监听器：行为记录拦截器：行为干预 能力逐渐增强：过滤器–&gt;监听器–&gt;拦截器 六、相关术语七、拓展阅读八、参考资料 [x] 请教一下关于过滤器，拦截器，监听器具体应用上的区别？ [x] 过滤器（Filter）与拦截器（Interceptor )区别 [x] 拦截器和过滤器的区别以及AOP概念 九、结语 文章仅作为个人学习总结之用，如能惠及他人，不胜荣幸。作者知识水平有限，欢迎批评指正。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 文章导读/关于","date":"2019-03-12T06:57:56.148Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 文章导读/关于/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 文章导读/关于/","excerpt":"","text":"个人简介： 且听风吟_z Java程序员 现居杭州 Email: oo1605#163.com 关于本站： 域名：万网域名 图床：七牛云存储 云服务器：阿里云 代码托管：码云Git CDN加速：阿里云 域名解析：阿里云DNS hexo主题托管在hexo-theme 旧版博客搭建于Github,欢迎Fork 新版博客托管于Coding.net Hexo搭建博客指南:Next主题 折腾开始于2014年6月1日，基本在2014年6月15日完工。 其他 未女昏人士； 阿森纳球迷； 实况足球忠实粉丝；","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Lapland 建站日记","date":"2019-03-12T06:57:56.028Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Lapland 建站日记/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Lapland 建站日记/","excerpt":"","text":"[TOC] 一、前言Lapland 是作者尝试搭建的第一个个人网站，初步构想网站主体内容为”技术博客“和”个人思维体系建设“两大模块，如有需要会将”人工智障研究中心模块“作为子域名单独划分出。本文作为”Lapland开发实录”系列文章的开篇和索引，以日志的形式记录网站的整个发展历程。 二、建站日志 2017-03-26：申请www.Lapland.top万网域名，有效期一年； 2017-03-26：购买腾讯云主机，有效期一个月； 2017-03-26：通过FTP上传第一个静态主页； 2017-04-28：购买阿里云虚拟主机，有效期一年； 三、技术架构1、1.1.1_Base [2017-03-26] 源码及内容托管：Git DNS 服务器：阿里云 Web服务器：阿里云虚拟主机 数据库服务器：阿里云虚拟主机 2、1.2.1_Base [2017-08-05] 源码及内容托管：Git DNS 服务器：阿里云 Web服务器：阿里云虚拟主机 数据库服务器：阿里云虚拟主机 对象存储服务器：七牛 四、结语 本文会随着网站的建设和优化持续更新,长期记录。欢迎各位看官不吝赐教。基于网站的安全考虑，项目暂不开源。","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Java 项目常用工具箱","date":"2019-03-12T06:57:56.004Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Java 项目常用工具箱/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 文章导读/[置顶]已发布]Java 项目常用工具箱/","excerpt":"","text":"[TOC] 一、前言本文记录和整理软件开发过程中所会用到的在线工具、开源项目、开放平台及其简介和链接,旨在方便在实际项目中的索引和使用。 二、 版本 编号 修改日期 版本号 修改人 修改说明 1 2017.09.24 1.0 ZZ 初稿 三、在线工具1、编程工具 在线工具 – 开源中国 http://tool.oschina.net/ 在线工具 – 在线工具 http://tool.lu 2、在线API3、开放平台四、开源工具1、代码格式类2、项目管理类 CrapApi API接口管理系统、API接口调试工具 3、快速开发类 JavaTools 常用工具类 mybatis-generator mybatis 代码生成器，根据数据库字段，生成mapper和xml JeeSite 信息化快速开发平台 jfinal 信息化快速开发平台 jeesite_autocode 4、系统监控运维类 kind 后台监控平台 lmt-op-server 运维发布平台 5、系统安全类 jfinalQ-encrypt 源代码加密解密工具 6、其他类 HData 一个支持多数据源的ETL数据导入/导出工具 五、自定义工具六、拓展阅读 编程常用工具破解方案汇总 七、结语本文用于日常记录，会长期不断更新和完善，并会以表格和思维导图的形式分别呈现。 链接［Doc］［XML］［XMind］","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/Linux常用命令速查表","date":"2019-03-12T06:57:55.984Z","updated":"2019-03-11T06:13:04.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/Linux常用命令速查表/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/Linux常用命令速查表/","excerpt":"","text":"3.1、软件安装deepin系统使用包管理工具apt-get。 3.11、常用的APT命令参数 命令 描述 apt-cache search package 搜索包 apt-cache show package 获取包的相关信息 sudo apt-get install package 安装包 sudo apt-get install package – reinstall 重新安装包 sudo apt-get -f install 修复安装”-f = –fix-missing” sudo apt-get remove package 删除包 sudo apt-get remove package – purge 删除包，包括删除配置文件等 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 12345678910111213141516171819202122232425whereis javaifconfigtopps -ef | grep javawget urlyum install javasudo apt-get install javacurl www.baidu.comfind . -type f -name *设计模式*sudo vim /etc/profilesource /etc/profilesudo cp -R mysql/* /home/zz/Desktop/mysql-data-backupzip -r test.zip test.exe 安装软件123456789 wget:类似于迅雷，是一种下载工具，通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理名字是World Wide Web”与“get”的结合。yum:是redhat, centos 系统下的软件安装方式，基于Linux，全称为 Yellow dog Updater, Modified，是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。rpm:软件管理; redhat的软件格式 rpm r=redhat p=package m=management用于安装 卸载 .rpm软件使用wget下载一个 rpm包, 然后用 rpm -ivh xxx.rpm 安装这个软件，嫌麻烦的话，就可以直接用 yum install sqoop 来自动下载和安装依赖的rpm软件。&gt; ap-get:是ubuntu下的一个软件安装方式，它是基于debain。 [x] 让你真正了解chmod和chown命令的用法 CentOS如何查看端口是被哪个应用/进程占用 12345678一、检查端口被哪个进程占用netstat -lnp|grep 8088二、查看进程的详细信息ps 1777杀掉进程kill -9 1777","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/SQL常用语句速查表","date":"2019-03-12T06:57:55.984Z","updated":"2018-11-29T15:24:11.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/SQL常用语句速查表/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/SQL常用语句速查表/","excerpt":"","text":"123456789101112131415161718# 创建表CREATE TABLEIF NOT EXISTS `sys_dict` ( `id` INT (10) NOT NULL AUTO_INCREMENT COMMENT '主键id', `dict_type` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典类型', `dict_key` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典key', `dict_value` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典value', `sort` INT (10) NOT NULL DEFAULT '0' COMMENT '字典排序值', `add_uid` INT (10) NOT NULL DEFAULT '0' COMMENT '添加人', `update_uid` INT (10) NOT NULL DEFAULT '0' COMMENT '更新人', `add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间', `del_flag` TINYINT (4) NOT NULL DEFAULT '0' COMMENT '删除标记', `remark` VARCHAR (100) NOT NULL DEFAULT '' COMMENT '备注', PRIMARY KEY (`id`), UNIQUE `uniq_dict_type` (`dict_type`), KEY `idx_dict_key` (`dict_key`)) ENGINE = INNODB CHARSET = utf8 COMMENT '数据字典表'; 12345# 随机填充UPDATE syn_case_typeSET case_num = ceiling(rand() * 60 + 20)WHERE (id IS NOT NULL); 1234567# 查询并去重SELECT DISTINCT COUNT(1)FROM case_infoWHERE url_1 IS NULL 123456# 查询字典表替换法院名称UPDATE dict_depart s, dict_court dSET s.court_name = d.court_nameWHERE s.court_id = d.id 123456# case_num第13个字符为数字并且fydm不等于1315B20UPDATE zx_case_infoSET zzh =0WHERE substring(case_num, 13,1) REGEXP '[^0-9.]'AND fydm != '1315B20' 1234567# 模糊查询SELECT COUNT(1)FROM zx_case_infoWHERE case_num LIKE '%执字%' 123456789# 区间查询SELECT *FROM wfycatjWHERE type IN ( 'WFYKTSLSC', 'WSYWFYKTSLAJS' 1234567891011# 格式化时间，获取本月数据SELECT*FROM wfycatjWHERE TYPE IN ( 'WFYMSSAJ', 'WFYXSAJ' )AND DATE_FORMAT(STARTTIME, '%Y-%m') = DATE_FORMAT(CURDATE(), '%Y-%m') 123456789101112131415161718# 创建表CREATE TABLEIF NOT EXISTS `sys_dict` ( `id` INT (10) NOT NULL AUTO_INCREMENT COMMENT '主键id', `dict_type` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典类型', `dict_key` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典key', `dict_value` VARCHAR (50) NOT NULL DEFAULT '' COMMENT '字典value', `sort` INT (10) NOT NULL DEFAULT '0' COMMENT '字典排序值', `add_uid` INT (10) NOT NULL DEFAULT '0' COMMENT '添加人', `update_uid` INT (10) NOT NULL DEFAULT '0' COMMENT '更新人', `add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间', `del_flag` TINYINT (4) NOT NULL DEFAULT '0' COMMENT '删除标记', `remark` VARCHAR (100) NOT NULL DEFAULT '' COMMENT '备注', PRIMARY KEY (`id`), UNIQUE `uniq_dict_type` (`dict_type`), KEY `idx_dict_key` (`dict_key`)) ENGINE = INNODB CHARSET = utf8 COMMENT '数据字典表'; 1234567891011121314# 统计制定法院时间段内的立案类型SELECT case_type, COUNT(*)FROM case_infoWHERE court_name = '宁波市中级人民法院'AND opencourt_time &gt; '2018-08-01 'AND opencourt_time &lt; '2018-08-31'GROUP BY case_typeORDER BY COUNT(*) DESC 12345# 随机填充UPDATE syn_case_typeSET case_num = ceiling(rand() * 60 + 20)WHERE (id IS NOT NULL); 1234567# 查询并去重SELECT DISTINCT COUNT(1)FROM case_infoWHERE url_1 IS NULL 123456# 查询字典表替换法院名称UPDATE dict_depart s, dict_court dSET s.court_name = d.court_nameWHERE s.court_id = d.id 123456# case_num第13个字符为数字并且fydm不等于1315B20UPDATE zx_case_infoSET zzh =0WHERE substring(case_num, 13,1) REGEXP '[^0-9.]'AND fydm != '1315B20' 1234567# 模糊查询SELECT COUNT(1)FROM zx_case_infoWHERE case_num LIKE '%执字%' 123456789# 区间查询SELECT *FROM wfycatjWHERE type IN ( 'WFYKTSLSC', 'WSYWFYKTSLAJS' 1234567# 格式化时间SELECT *FROM wfycatjWHERE DATE_FORMAT(STARTTIME, '%Y-%m') = DATE_FORMAT(CURDATE(), '%Y-%m') 12345678910111213141516-- 插入遗留的案件INSERT INTO zx_case_info(case_id) SELECT s.AJBSFROM sjxx sWHERE s.YYSJ &gt;= '2018-01-01'AND s.YYSJ &lt; '2018-11-01'AND s.TYPE = 'YysF'AND s.SP_ZX = '2'AND s.AJBS NOT IN ( SELECT z.case_id FROM zx_case_info z) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 统计运用时间段内sjxx数据 （优化）SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SFBS` AS `SFBH`, `s`.`SP_ZX` AS `SP_ZX`, `s`.`SSDW` AS `SSDW`, ( CASE `s`.`TYPE` WHEN 'FgYys' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Yys' THEN count(DISTINCT `s`.`AJBS`) WHEN 'YysF' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Zsyfdsr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'zxSqr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'zxBzxr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Bg' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Dsr' THEN count(DISTINCT `s`.`SFBS`) ELSE sum(`s`.`NUM`) END ) AS `sum`FROM ( `sjxx` `s` JOIN `case_info` `c` ON ((`s`.`AJBS` = `c`.`case_id`)) )WHERE ( (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') )GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX`, `s`.`SSDW`, `s`.`SFBS` 1234567891011121314151617181920212223242526272829303132# 当事人地图统计SELECT dc.id id, dc.court_name courtName, dp.province_name province, SUM(s.NUM) litigantCountFROM ( SELECT AJBS, SFBS, TYPE, COUNT(DISTINCT SFBS, AJBS) NUM, YYSJ FROM sjxx WHERE TYPE = 'Dsr' AND YYSJ &gt;= '2018-09-01' AND YYSJ &lt; '2018-10-01' GROUP BY AJBS ) AS s, dict_court dc, dict_province dpWHERE dc.court_name = '宁波市中级人民法院'AND LEFT (s.AJBS, 4) = dc.idAND LEFT (s.SFBS, 2) = dp.idGROUP BY LEFT (s.AJBS, 4), LEFT (s.SFBS, 2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 当事人汇总 - 联合字段去重SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SP_ZX` AS `SP_ZX`, count( DISTINCT `s`.`SFBS`, `s`.`AJBS` ) AS `sum`FROM ( `sjxx` `s` JOIN `case_info` `c` )WHERE ( (`s`.`AJBS` = `c`.`case_id`) AND (`s`.`TYPE` = 'Dsr') AND (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') )GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX`UNION SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SP_ZX` AS `SP_ZX`, count( DISTINCT `s`.`SFBS`, `s`.`AJBS` ) AS `sum` FROM ( `sjxx` `s` JOIN `zx_case_info` `c` ) WHERE ( (`s`.`AJBS` = `c`.`case_id`) AND (`s`.`TYPE` = 'Dsr') AND (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') ) GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX` 12345678910111213141516# 查询效率测试SELECT *FROM case_infoWHERE court_name = '宁波市中级人民法院'AND ( url_2 IS NOT NULL OR url_3 IS NOT NULL OR url_4 IS NOT NULL OR url_5 IS NOT NULL OR url_6 IS NOT NULL)# ORDER BY opencourt_time DESCLIMIT 1,4 1234567891011121314# 统计制定法院时间段内的立案类型SELECT case_type, COUNT(*)FROM case_infoWHERE court_name = '宁波市中级人民法院'AND opencourt_time &gt; '2018-08-01 'AND opencourt_time &lt; '2018-08-31'GROUP BY case_typeORDER BY COUNT(*) DESC 12345678910111213141516-- 插入遗留的案件INSERT INTO zx_case_info(case_id) SELECT s.AJBSFROM sjxx sWHERE s.YYSJ &gt;= '2018-01-01'AND s.YYSJ &lt; '2018-11-01'AND s.TYPE = 'YysF'AND s.SP_ZX = '2'AND s.AJBS NOT IN ( SELECT z.case_id FROM zx_case_info z) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 统计运用时间段内sjxx数据 （优化）SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SFBS` AS `SFBH`, `s`.`SP_ZX` AS `SP_ZX`, `s`.`SSDW` AS `SSDW`, ( CASE `s`.`TYPE` WHEN 'FgYys' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Yys' THEN count(DISTINCT `s`.`AJBS`) WHEN 'YysF' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Zsyfdsr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'zxSqr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'zxBzxr' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Bg' THEN count(DISTINCT `s`.`AJBS`) WHEN 'Dsr' THEN count(DISTINCT `s`.`SFBS`) ELSE sum(`s`.`NUM`) END ) AS `sum`FROM ( `sjxx` `s` JOIN `case_info` `c` ON ((`s`.`AJBS` = `c`.`case_id`)) )WHERE ( (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') )GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX`, `s`.`SSDW`, `s`.`SFBS` 1234567891011121314151617181920212223242526272829303132# 当事人地图统计SELECT dc.id id, dc.court_name courtName, dp.province_name province, SUM(s.NUM) litigantCountFROM ( SELECT AJBS, SFBS, TYPE, COUNT(DISTINCT SFBS, AJBS) NUM, YYSJ FROM sjxx WHERE TYPE = 'Dsr' AND YYSJ &gt;= '2018-09-01' AND YYSJ &lt; '2018-10-01' GROUP BY AJBS ) AS s, dict_court dc, dict_province dpWHERE dc.court_name = '宁波市中级人民法院'AND LEFT (s.AJBS, 4) = dc.idAND LEFT (s.SFBS, 2) = dp.idGROUP BY LEFT (s.AJBS, 4), LEFT (s.SFBS, 2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 当事人汇总 - 联合字段去重SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SP_ZX` AS `SP_ZX`, count( DISTINCT `s`.`SFBS`, `s`.`AJBS` ) AS `sum`FROM ( `sjxx` `s` JOIN `case_info` `c` )WHERE ( (`s`.`AJBS` = `c`.`case_id`) AND (`s`.`TYPE` = 'Dsr') AND (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') )GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX`UNION SELECT `c`.`court_name` AS `court_name`, `c`.`organizer` AS `organizer`, `c`.`judge` AS `judge`, `s`.`TYPE` AS `TYPE`, `s`.`SP_ZX` AS `SP_ZX`, count( DISTINCT `s`.`SFBS`, `s`.`AJBS` ) AS `sum` FROM ( `sjxx` `s` JOIN `zx_case_info` `c` ) WHERE ( (`s`.`AJBS` = `c`.`case_id`) AND (`s`.`TYPE` = 'Dsr') AND (`s`.`YYSJ` &gt;= '2018-10-01') AND (`s`.`YYSJ` &lt; '2018-11-01') ) GROUP BY `c`.`court_name`, `c`.`organizer`, `c`.`judge`, `s`.`TYPE`, `s`.`SP_ZX` 12345678910111213141516# 查询效率测试SELECT *FROM case_infoWHERE court_name = '宁波市中级人民法院'AND ( url_2 IS NOT NULL OR url_3 IS NOT NULL OR url_4 IS NOT NULL OR url_5 IS NOT NULL OR url_6 IS NOT NULL)# ORDER BY opencourt_time DESCLIMIT 1,4 1234567891011121314# 统计制定法院时间段内的立案类型SELECT case_type, COUNT(*)FROM case_infoWHERE court_name = '宁波市中级人民法院'AND opencourt_time &gt; '2018-08-01 'AND opencourt_time &lt; '2018-08-31'GROUP BY case_typeORDER BY COUNT(*) DESC","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/常用JS代码片段-2","date":"2019-03-12T06:57:55.960Z","updated":"2018-11-29T15:52:10.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/常用JS代码片段-2/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/常用JS代码片段-2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// 操作 document - 1var time1 = document.getElementById(\"time1\"); // 获取节点time1.innerHTML = ndate1; // 填充数据var button = document.getElementsByClassName('button')[0];iframe.src = url;// 文章列表function loadArticleList() &#123;$.ajax(&#123; type: \"get\", url: \"../../json/blog.json\", async: true, success: function (data) &#123; var data = data.data; var parentDiv = document.getElementsByClassName(\"bloglist\"); for (var i = 0; i &lt; data.length; i++) &#123; var childDiv_1 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_1.appendTo(parentDiv[0]); var childDiv_2 = $('&lt;div&gt;&lt;/div&gt;'); childDiv_2.addClass('arrow_box'); childDiv_2.appendTo(childDiv_1); // 三角形 var childDiv_3 = $('&lt;div&gt;&lt;/div&gt;'); childDiv_3.addClass('ti'); childDiv_3.appendTo(childDiv_2); // 圆形 var childDiv_4 = $('&lt;div&gt;&lt;/div&gt;'); childDiv_4.addClass('ci'); childDiv_4.appendTo(childDiv_2); // 标题 var childDiv_5 = $('&lt;h2&gt;&lt;/h2&gt;'); childDiv_5.addClass('title'); var childDiv_5_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_5_1.text(data[i].title); childDiv_5_1.attr('href', data[i].url); childDiv_5_1.appendTo(childDiv_5); childDiv_5.appendTo(childDiv_2); // 摘要 var childDiv_6 = $('&lt;ul&gt;&lt;/ul&gt;'); childDiv_6.addClass('abstract'); childDiv_6.appendTo(childDiv_2); var childDiv_6_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_6_1.attr('href', data[i].url); childDiv_6_1.appendTo(childDiv_6); var childDiv_6_1_1 = $('&lt;img&gt;'); childDiv_6_1_1.attr('src', data[i].img_url); childDiv_6_1_1.appendTo(childDiv_6_1); var childDiv_6_2 = $('&lt;p&gt;&lt;/p&gt;'); childDiv_6_2.text(data[i].abstract); childDiv_6_2.appendTo(childDiv_6); // 文章信息 var childDiv_7 = $('&lt;ul&gt;&lt;/ul&gt;'); childDiv_7.addClass('details'); childDiv_7.appendTo(childDiv_2); // 发布/更新日期 var childDiv_7_1 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_7_1.appendTo(childDiv_7); var childDiv_7_1_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_7_1_1.attr('href', ''); childDiv_7_1_1.attr('title', '发布日期：' + data[i].details.update_date); childDiv_7_1_1.appendTo(childDiv_7_1); var childDiv_7_1_1_1 = $('&lt;i&gt;&lt;/i&gt;'); childDiv_7_1_1_1.addClass('fa fa-clock-o'); childDiv_7_1_1_1.appendTo(childDiv_7_1_1); $(childDiv_7_1_1_1).after(data[i].details.update_date); // 作者 var childDiv_7_2 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_7_2.appendTo(childDiv_7); var childDiv_7_2_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_7_2_1.attr('href', ''); childDiv_7_2_1.attr('title', '作者：' + data[i].details.author); childDiv_7_2_1.appendTo(childDiv_7_2); var childDiv_7_2_1_1 = $('&lt;i&gt;&lt;/i&gt;'); childDiv_7_2_1_1.addClass('fa fa-user'); childDiv_7_2_1_1.appendTo(childDiv_7_2_1); $(childDiv_7_2_1_1).after(data[i].details.author); // 评论数 var childDiv_7_3 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_7_3.appendTo(childDiv_7); var childDiv_7_3_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_7_3_1.attr('href', ''); childDiv_7_3_1.attr('title', '已有' + data[i].details.comment_num + '条评论'); childDiv_7_3_1.appendTo(childDiv_7_3); var childDiv_7_3_1_1 = $('&lt;i&gt;&lt;/i&gt;'); childDiv_7_3_1_1.addClass('fa fa-commenting'); childDiv_7_3_1_1.appendTo(childDiv_7_3_1); $(childDiv_7_3_1_1).after(data[i].details.comment_num); // 阅览数 var childDiv_7_4 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_7_4.appendTo(childDiv_7); var childDiv_7_4_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_7_4_1.attr('href', ''); childDiv_7_4_1.attr('title', '已有' + data[i].details.look_num + '次浏览'); childDiv_7_4_1.appendTo(childDiv_7_4); var childDiv_7_4_1_1 = $('&lt;i&gt;&lt;/i&gt;'); childDiv_7_4_1_1.addClass('fa fa-eye'); childDiv_7_4_1_1.appendTo(childDiv_7_4_1); $(childDiv_7_4_1_1).after(data[i].details.look_num); // 分类 var childDiv_7_5 = $('&lt;li&gt;&lt;/li&gt;'); childDiv_7_5.appendTo(childDiv_7); var childDiv_7_5_1 = $('&lt;a&gt;&lt;/a&gt;'); childDiv_7_5_1.attr('href', ''); childDiv_7_5_1.attr('title', '分类：' + data[i].details.category); childDiv_7_5_1.appendTo(childDiv_7_5); var childDiv_7_5_1_1 = $('&lt;i&gt;&lt;/i&gt;'); childDiv_7_5_1_1.addClass('fa fa-th-list'); childDiv_7_5_1_1.appendTo(childDiv_7_5_1); $(childDiv_7_5_1_1).after(data[i].details.category); &#125; &#125;, error: function (data) &#123; console.log(\"数据请求失败！\" + data.msg); &#125;&#125;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 操作 document - 2window.onload = function () &#123; getLogs();&#125;;function getLogs() &#123; $.ajax(&#123; type: \"get\", url: \"http://localhost:8080/SmartCity-Service/monitor/monitor-logger\", async: true, success: function (data) &#123; var data = data.data; var div_1 = document.getElementsByTagName('tbody')[0]; for (i = 0; i &lt; data.length; i++) &#123; var div_1_1 = $('&lt;tr&gt;&lt;/tr&gt;'); div_1_1.addClass('tr-row1'); div_1_1.attr('align', \"center\"); div_1_1.appendTo(div_1); var div_1_1_0 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_1 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_2 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_3 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_4 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_5 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_6 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_7 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_8 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_9 = $('&lt;td&gt;&lt;/td&gt;'); var div_1_1_10 = $('&lt;td&gt;&lt;/td&gt;'); div_1_1_0.text(data[i].id); div_1_1_1.text(data[i].title); div_1_1_2.text(data[i].level); div_1_1_3.text(data[i].userName); div_1_1_4.text(formatUnixtimestamp(data[i].operTime)); div_1_1_5.text(data[i].reqIp); div_1_1_6.text(data[i].reqUri); div_1_1_7.text(data[i].method); div_1_1_8.text(data[i].operEvent); if (1 == data[i].operStatus) &#123; div_1_1_9.text('操作成功'); &#125; else &#123; div_1_1_9.text('操作失败'); &#125; var div_1_1_10_1 = $('&lt;bottom&gt;&lt;/bottom&gt;'); div_1_1_10_1.addClass('btn btn-primary btn-sm'); div_1_1_10_1.text('删除'); div_1_1_10_1.attr('onclick', 'deleteLogById(' + data[i].id + ')'); div_1_1_10_1.appendTo(div_1_1_10); div_1_1_0.appendTo(div_1_1); div_1_1_1.appendTo(div_1_1); div_1_1_2.appendTo(div_1_1); div_1_1_3.appendTo(div_1_1); div_1_1_4.appendTo(div_1_1); div_1_1_5.appendTo(div_1_1); div_1_1_6.appendTo(div_1_1); div_1_1_7.appendTo(div_1_1); div_1_1_8.appendTo(div_1_1); div_1_1_9.appendTo(div_1_1); div_1_1_10.appendTo(div_1_1); &#125; &#125; &#125;);&#125;// 时间戳转 YYYY-MM-dd HH:mm:ssfunction formatUnixtimestamp(unixtimestamp) &#123; var unixtimestamp = new Date(unixtimestamp); var year = 1900 + unixtimestamp.getYear(); var month = \"0\" + (unixtimestamp.getMonth() + 1); var date = \"0\" + unixtimestamp.getDate(); var hour = \"0\" + unixtimestamp.getHours(); var minute = \"0\" + unixtimestamp.getMinutes(); var second = \"0\" + unixtimestamp.getSeconds(); return year + \"-\" + month.substring(month.length - 2, month.length) + \"-\" + date.substring(date.length - 2, date.length) + \" \" + hour.substring(hour.length - 2, hour.length) + \":\" + minute.substring(minute.length - 2, minute.length) + \":\" + second.substring(second.length - 2, second.length);&#125;function deleteLogById(id) &#123; var a = confirm(\"是否确认删除\"); if (a == true) &#123; $.ajax(&#123; type: \"post\", url: \"http://localhost:8080/SmartCity-Service/monitor/deleteLogById\", async: true, data: &#123; id: id &#125;, success: function () &#123; window.location.reload(); &#125; &#125;); &#125; ;&#125;function deleteLogAll() &#123; var a = confirm(\"是否确认清空日志\"); if (a == true) &#123; $.ajax(&#123; type: \"get\", url: \"http://localhost:8080/SmartCity-Service/monitor/deleteLogAll\", async: true, success: function () &#123; window.location.reload(); &#125; &#125;); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/常用JS代码片段-1","date":"2019-03-12T06:57:55.940Z","updated":"2018-11-29T15:52:55.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/常用JS代码片段-1/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/常用JS代码片段-1/","excerpt":"","text":"123456789101112debugger;console.log(\"====TEST====\");console.log(data);console.log(event);console.log(typeof event);var addressDate = loadAddress(data[i].addrid);$(span3).html(addressDate.name);var addressDate = loadAddress(data[i].addrid);var coor = addressDate.coord.split(','); 12345678910//定时更新图表setInterval(function () &#123; loadTourCharts(); loadWorkMessage(); loadVolumeStatictics(); loadDigital(); loadAccident(); loadDistributed();&#125;, 30000); 12345678910111213141516171819// AJAX请求function loadAir() &#123; $.ajax(&#123; type: \"get\", url: DBServiceURI + \"order/getAir.do\", async: true, success: function (data) &#123; var data = data.data; var AirData = []; for (var i = 0; i &lt; data.length; i++) &#123; var subData = []; subData[0] = data[i].id; subData[1] = data[i].value; AirData.push(subData); &#125; air(AirData); &#125; &#125;);&#125;","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/常用快捷键","date":"2019-03-12T06:57:55.924Z","updated":"2018-11-29T08:44:04.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/常用快捷键/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/常用快捷键/","excerpt":"","text":"|- Myeclipse 的快捷键及应用:|- Close Project 关闭项目|- 按住Shift 切换大小写，比CapsLk方便|- 右键 -preperences– java - Editor - Hovers - Combined Hover 取消自动提示 可用F2手动提示 |- outline视口–导航|- 在包下面建立class 可以自动把java文件加进包里。|- 单词匹配查询: Windows—Edit|- 运行报错信息仅观察表头和自己认识的包即可。|- Eclipse 可以直接复制不用安装使用。 Debug的方法:Breakpoint: |- F5：跳入方法 / F6：向下逐行调试 / F7：跳出方法 / F8：直接跳转到下一个断点。|- Line Breakpoint： 可设置一个Conditional条件（条件断点），当程序满足设定的条件，会被中断。手动修改变量值然后下一步。|- Watchpoint Breakpoint：当变量值被调用或值改变时会中断,可设置仅只改变。定义在变量初始化处。|- Method Breakpoint: 当函数被调用时会中断。|- Class Load Breakpoint：当类被调用时会中断。|- Exception Breakpoint：特定异常发生时程序能够被中断。 点击相应的位置程序会自动生成断点类型 Junit 4 case：@Test|- @Before 修饰方法，在每个测试方法调用之前，该方法都会被调用|- @After 修饰方法，在每个测试方法调用之后，该方法都会被调用|- @Ignore 修饰方法，该方法会被忽略 双击选中一个方法,可以单独测试一个方法 参数化测试,通过 Assert.assertEquals(true, x);设置期望值和实际值，不符时，即使控制台输出成功，Junit也会报错","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/SC00 速查表/常用JAVA代码片段","date":"2019-03-12T06:57:55.908Z","updated":"2018-11-29T16:07:58.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/SC00 速查表/常用JAVA代码片段/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/SC00 速查表/常用JAVA代码片段/","excerpt":"","text":"12345678910// 非空判断List：CollectionUtils.isNotEmpty(caseInfoList)String：StringUtils.isNotEmpty(flag)StringUtils.isBlank(courtName)Object ：null！= object 1234567891011121314151617// 1、日期类操作，获取当前年月日public void getToday() &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Calendar calendar = Calendar.getInstance(); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int date = calendar.get(Calendar.DATE); Date today_1 = calendar.getTime(); String time_1 = sdf.format(today_1); System.out.println(year + month + date + time_1); Date today_2 = new Date(); String time_2 = sdf.format(today_2); System.out.println(time_2); &#125; 123456789101112131415161718192021// 2、日期类操作Calendar c = Calendar.getInstance();c.add(Calendar.MONTH, -1);Date date = c.getTime();String lastMonth = sdf.format(date);// 3、日期类操作SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");Date date = new Date();String today = sdf.format(date);// 4、日期类操作Calendar ca = Calendar.getInstance();// 得到一个Calendar的实例//ca.setTime(new Date()); // 设置时间为当前时间ca.set(2011, 11, 17);// 月份是从0开始的，所以11表示12月ca.add(Calendar.YEAR, -1); // 年份减1ca.add(Calendar.MONTH, -1);// 月份减1ca.add(Calendar.DATE, -1);// 日期减1Date resultDate = ca.getTime(); // 结果SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");System.out.println(sdf.format(resultDate)); 1234567891011121314151617// 查询超长 - 分页public void updateCaseList(Integer pageSize) &#123; int pageNum = spbzkMapper.count() / pageSize; for (int pageIndex = 0; pageIndex &lt;= pageNum; pageIndex++) &#123; // 处理分页索引 Integer offset = null; if (null != pageSize) &#123; offset = pageSize * (pageIndex - 1); &#125; List&lt;Spbzk&gt; spbzkList = spbzkMapper.selectAll(offset, pageSize); for (Spbzk spbzk : spbzkList) &#123; // &#125; &#125;&#125; 12345678910111213141516171819202122232425// 读取json文件public static String getJson(String path) &#123; String laststr = \"\"; File file = new File(path);// 打开文件 BufferedReader reader = null; try &#123; FileInputStream in = new FileInputStream(file); reader = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));// 读取文件 String tempString = null; while ((tempString = reader.readLine()) != null) &#123; laststr = laststr + tempString; &#125; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException el) &#123; &#125; &#125; &#125; return laststr;&#125; 12345678910111213141516// 时间解析for (Map.Entry&lt;String, String&gt; entry : timeMap.entrySet()) &#123; String startTime = entry.getKey(); String endTime = entry.getValue(); Date date = null; try &#123; date = df.parse(startTime); &#125; catch (ParseException e) &#123; LOGGER.error(\"日期格式解析错误\", e); &#125; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); //获取年份和月份 String year = String.valueOf(calendar.get(Calendar.YEAR)); String month = String.valueOf(calendar.get(Calendar.MONTH) + 1);&#125; 1234// List添加List&lt;Wfycatj&gt; wfycatjList = wfycatjMapper.selectCaBywfyType();/List&lt;Wfycatj&gt; ljList = wfycatjMapper.selectLjBywfyType();wfycatjList.addAll(ljList); 12345678910111213141516//筛选Listpublic List&lt;CaseListInfo&gt; checkDepart(List&lt;CaseListInfo&gt; caseListInfoList, String departType) &#123; Iterator&lt;CaseListInfo&gt; iterator = caseListInfoList.iterator(); while (iterator.hasNext()) &#123; CaseListInfo caseListInfoItem = iterator.next(); DictDepart dictDepartList = dictDepartMapper.selectDepartByCourtNameAndDepartName( caseListInfoItem.getCourtName(), caseListInfoItem.getDepartName(), departType); if (null != dictDepartList) &#123; caseListInfoItem.setDepartName(dictDepartList.getDepartShowName()); &#125; else &#123; iterator.remove(); &#125; &#125; return caseListInfoList;&#125; 12345/** 代码中发送http请求，非法字符错误* 产生原因：url中有汉字或特殊字符(非字母和数字的字符)，没有转码。* 解决办法：将带有特殊字符或汉字的参数进行转码，再放入url发送即可。*/param1 = URLEncoder.encode(param1, \"UTF-8\");","categories":[],"tags":[]},{"title":"","slug":"[置顶] 博客文章/小贴士/小贴士 - 前端开发","date":"2019-03-12T06:57:55.896Z","updated":"2018-11-28T08:32:34.000Z","comments":true,"path":"2019/03/12/[置顶] 博客文章/小贴士/小贴士 - 前端开发/","link":"","permalink":"http://www.lapland.top/2019/03/12/[置顶] 博客文章/小贴士/小贴士 - 前端开发/","excerpt":"","text":"1、 为什么要在根目录下放 index.html ? 答案：假设网站的默认首页是home/www/项目名/web/home.html。在开发环境中静态网页的没有根目录，当前目录为home.html，页面的跳转采用相对路径。然而生产环境，在nginx代理时设置根目录home/www/项目名，主页设置为/web/home.html，打开域名时，当前目录为根目录，则页面的跳转就会出现问题。加一层index.html放在根目录下，做自动跳转，则可以避免这个问题。 index代码如下12345&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"refresh\" content=\"0.1;url=web/home.html\"&gt; &lt;title&gt;正在跳转，请稍后...&lt;/title&gt;&lt;/head&gt; 2、JavaScript中的标签语句即给一条语句起一个名字，这样在程序的任何地方都可以使用这个名字来引用它，可以标记任何语句。如条件循环，回调语句等。","categories":[],"tags":[]}]}